p. 

h1(#multi_state_machine_modelling). Multi state machine modeling

The behavior of large systems is often too complex to be captured by a single statechart. So if a statechart gets too large you should think about splitting it into two or more smaller pieces. Beside the fact that the smaller state machines are easier to handle  and maintain there are additional reasons for using multiple state machine instead of single monolithic ones:

* Separation of concerns enables a better software architecture.
* State machines can be reused at different places. So if you have identical copies of sub states spread around your stat e machines then this could be a good point.   
* If you build a distributed system then the you require separate state machines for the different nodes. 

This chapter describes how you can model and simulate a system which consists of multiple collaborating state machines and how you can embed a statechart as a sub machines into another statechart. The relevant aspects will be explained using the example of the different traffic light on a street crossing.


*PICTURE !! : structural overview of the street crossing*
 
The traffic control of a street crossing using traffic lights can become quite complex. In this example we ... TBD  
 

h2(#multi_state_machine_referencing). Referencing state machines   

First of all - in order to enable collaboration between different state machines instances a state machine can reference other state machines. 

bc. 
import: "TrafficLight.sct"
interface: 
    var trafficLightA : TrafficLight
    var trafficLightB : TrafficLight
 
 

!(small)images/multi_state_machine_controller.png(Controller state machine interacting with other state machine.)!

h2(#multi_state_machine_events_variables). Sending events, receiving events, and accessing variables 
    
All events and variables which are defines by a statecharts named and default interfaces are visible as members in the state machines API. This means that a state machine instance can raise events which are in events of a referenced state machine. It can react to out events of the other machine and it can access variables. 

A loosely coupled architecture make use of asynchronous message passing and this perfectly matches to statechart events. Accessing variables imply a tighter coupling of state machines as these are accessed synchronously. 

h2(#multi_state_machine_life_cycle). Controlling a state machines life cycle   

the life cycle methods of a state machine object are the same that exist in the generated state machines API. These are:

- enter
- exit
- isFinal
- isActive
- isStateActive
- runCycle

controlling life cycle imply a tighter coupling between the involved machines. 
these machines should not be distributed and should run in the same thread 


h2(#multi_state_machine_submachine). Using sub machines   

- Basic semantics of sub state machines
- Refer to UML sub state machines
- Life ccle of sub state machines
- long running operations as sub state machine 


example is
* watchdog
* release control cycle
explain example

- a sub machien is comparable with a sub region
- A state can contain regions and sub machines

- A machine can only be sub machine in one active state at once.
- A machine can subsequently be sub machine of many state if no two or more of them are active at the same time.

- execution order of sub machines and regions in parent and child first execution

- impact of order of submachine statement in state

- Sub machines in event driven scenarios
- sub machines in cycle based scenarios


h2(#multi_state_machine_simulation). Simulating multiple state machines



h2(#multi_state_machine_testing). Testing multiple state machines



h2(#multi_state_machine_code_gen). Generating code for multi state machine systems
