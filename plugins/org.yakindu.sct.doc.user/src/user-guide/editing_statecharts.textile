
p. 

h1(#edit_editing_statecharts). Editing statecharts

This section explains how you can edit statecharts using YAKINDU Statechart Tools.




h2(#edit_creating_and_deleting_statecharts). Creating and deleting statecharts

Statecharts are comprised in *statechart model files*. The filename extension of these files is @.sct@. Their internal format is "XML Metadata Interchange":https://en.wikipedia.org/wiki/XML_Metadata_Interchange or "XMI":https://en.wikipedia.org/wiki/XML_Metadata_Interchange, which is an XML language.



h3(#edit_creating_a_statechart). Creating a statechart

###. FIXME: Unify the following with the tutorial text!

In order to create a new statechart, use the _project explorer_ view:
# Right-click on a project or on a folder you want to create the new statechart in. The context menu appears.
# In the context menu, select _New → Other…_. The _New_ dialog appears.
# In the _New_ dialog, select _YAKINDU SCT → Statechart Model_ and click _Next >_. The _New YAKINDU Statechart_ wizard appears.
# In the _File Name_ field, enter a filename for the statechart file to be created. The filename extension must be _.sct_.
# Click _Next >_.
# In the wizard, select a statechart domain. Which domains are available depend on your YAKINDU Statechart Tools license. The _Default_ domain for "normal" statecharts without any language integration is always available.
# Click _Finish_.
# If the _Confirm Perspective Switch_ dialog appears, answer its question as you see fit.
# The new statechart file is created in the location you specified and opened in the "statechart editor":#edit_editor_ui.



h3(#edit_copying_an_existing_statechart). Copying an existing statechart

In order to copy an existing statechart file, proceed as follows:
# In the _project explorer_ view, right-click on the statechart's filename. The context menu appears.
# In the context menu, select _Copy_.
# Right-click on the project or folder you want to insert the copied file in. The context menu appears.
# In the context menu, select _Paste_.
# If there is already a file with the same name as the file to be copied in the target project or folder – which is always the case if you are copying a file within the same project or directory –, the _Name conflict_ dialog appears.
## Specify a name for the new file. The _Name conflict_ dialog and makes a suggestion, which you can modify.
## Click _OK_ to paste the new file to the target project or folder.
# If the target project or folder does not contain a file with the same name as the source file, the copied file will have the same name as the original.



h3(#edit_deleting_a_statechart). Deleting a statechart

In order to delete a statechart file, proceed as follows:
# Right-click on the statechart file in the _Project Explorer_ view. The context menu appears.
# In the context menu, select _Delete_.
# The _Delete Resources_ confirmation dialog appears. You have three choices:
## Click _Preview >_ to inspect what the delete operation is going to do, if confirmed.
## Click _Cancel_ to cancel the delete operation. Your statechart file will persist.
## Click _OK_ to actually delete the statechart file.




h2(#edit_editor_ui). Editor UI

YAKINDU Statechart Tools comes with a *statechart editor*. This section explains the statechart editor and how you can use it to graphically edit your statecharts.



h3(#edit_the_sc_modeling_perspective). The _SC Modeling_ perspective

_SC Modeling_ is an Eclipse perspective supporting the modeling of statecharts. The perspective defines the following views and their positions:
* _Project Explorer_ (left): This view displays your workspace and projects, folders, and files contained therein. You can also use the _Project Explorer_ to inspect the internal structure of your statechart models.
* _Properties_ (bottom): This view displays properties, regarding the semantic model or the graphical appearance, of the selected element in the statechart editor. You can directly edit these properties in this view.
* _Problems_ (bottom): This view displays errors and warnings existing in your workspace. Double-clicking on an entry typically opens the location of the respective error or warning.
* _Tasks_ (bottom): This view displays any tasks you have defined in your statechart previously. Section "&quot;Working with statechart tasks&quot;":#edit_working_with_statechart_tasks explains how to do that.
* _Outline_ (right): This view is a bird's eye view on the opened statechart. It also indicates the current viewport for better orientation in large models.

You can change the positions and sizes of these views, you can delete them, or add more views, using standard Eclipse mechanisms.



h3(#edit_canvas). Canvas

The canvas is the statechart editor's drawing area. When you create a new statechart model, the canvas comprises the "definition section":../user-guide/statechart_language.html#sclang_definition_section and a single "region":../user-guide/statechart_language.html#sclang_regions.

The following list gives an overview of what kind of actions you can perform on the canvas:
* Add or remove a region
** To add a region to the canvas, select _Region_ in the "editor palette":#edit_editor_palette, then click on the canvas location you want to place the region.
** To remove a region from the canvas, select the region, then
*** press the @[Del]@ key, or
*** select _Delete from model_ in the context menu, or
*** select _Edit → Delete_ in the menu bar.
* Zooming
** Press and hold @[Ctrl]@ and turn the mouse wheel to zoom in or out.
** Right-click on the canvas to open its context menu. In the context menu, several zooming functions are available in the _Zoom_ submenu.



h3(#edit_editor_palette). Editor palette

The editor palette provides you with a set of various actions and statechart editing tools. By default, the palette is located right of the canvas, but you can also drag it to the left.

You can hide the palette by clicking on the small triangle on the right-hand side in the palette's title bar. Click on the triangle again to make the palette reappear.

!(tiny)images/docu_editor_palette_010_overview.png(Editor palette)!

p=. Editor palette


h4(#edit_editing_action_tools). Editing action tools

Below its title bar, the palette contains a toolbar with the following editing action tools (from left to right):
| *Symbol* | *Action* | *Description* |
| !(inlinemediaobject)images/docu_editor_palette_020_symbol_select.png(Editor palette symbol "Select")! | Select | Left-click at an object to select it. |
| !(inlinemediaobject)images/docu_editor_palette_030_symbol_zoom_in.png(Editor palette symbol "Zoom in")! | Zoom in | Left-click to zoom in. Press @[Shift]@ and left-click to zoom out. Drag to zoom to selection. |
| !(inlinemediaobject)images/docu_editor_palette_040_symbol_zoom_out.png(Editor palette symbol "Zoom out")! | Zoom out | Left-click to zoom out. Press @[Shift]@ and left-click to zoom in. |
| !(inlinemediaobject)images/docu_editor_palette_070_symbol_note.png(Editor palette symbol "Note")! | Note | Create a note, a text or a note attachment. |


h4(#edit_statechart_elements_tools). Statechart elements tools

The palette comprises a couple of tools serving to add statechart elements to the diagram (from top to bottom):

| *Symbol* | *Description* |
| !images/docu_editor_palette_210_tool_transition.png(Editor palette element tool "Transition")! | Adds a "transition":../user-guide/statechart_language.html#sclang_transitions. |
| !images/docu_editor_palette_220_tool_state.png(Editor palette element tool "State")! | Adds a "state":../user-guide/statechart_language.html#sclang_states. |
| !images/docu_editor_palette_230_tool_composite_state.png(Editor palette element tool "Composite state")! | Adds a "composite state":../user-guide/statechart_language.html#sclang_composite_states. |
| !images/docu_editor_palette_240_tool_orthogonal_state.png(Editor palette element tool "Orthogonal state")! | Adds an "orthogonal state":../user-guide/statechart_language.html#sclang_orthogonal_states. |
| !images/docu_editor_palette_250_tool_region.png(Editor palette element tool "Region")! | Adds a "region":../user-guide/statechart_language.html#sclang_regions. |
| !images/docu_editor_palette_260_tool_entry.png(Editor palette element tool "Entry point")! | Adds an "entry point":../user-guide/statechart_language.html#sclang_entry_points. |
| !images/docu_editor_palette_270_tool_shallow_history.png(Editor palette element tool "Shallow history")! | Adds a "shallow history state":../user-guide/statechart_language.html#sclang_shallow_history_states. |
| !images/docu_editor_palette_280_tool_deep_history.png(Editor palette element tool "Deep history")! | Adds a "deep history state":../user-guide/statechart_language.html#sclang_deep_history_states. |
| !images/docu_editor_palette_290_tool_final_state.png(Editor palette element tool "Final state")! | Adds a "final state":../user-guide/statechart_language.html#sclang_final_state. |
| !images/docu_editor_palette_300_tool_exit_point.png(Editor palette element tool "Exit point")! | Adds an "exit point":../user-guide/statechart_language.html#sclang_exit_points. |
| !images/docu_editor_palette_310_tool_choice.png(Editor palette element tool "Choice")! | Adds a "choice":../user-guide/statechart_language.html#sclang_choices. |
| !images/docu_editor_palette_320_tool_synchronization.png(Editor palette element tool "Synchronization")! | Adds a "synchronization":../user-guide/statechart_language.html#sclang_synchronizations. |



h3(#edit_outline_view). Outline view

The _Outline_ view allows you to keep the big picture of your statechart model and navigate it easily. It displays the model outline either as a graphical overview or as a hierarchical outline.


h4(#edit_graphical_overview). Graphical overview

Click on the _Overview_ icon in the _Outline_ view's title bar to engage the graphical overview.

While the statechart editor window – due to zooming or the size of the whole statechart – might display a cutout only, the _Outline_ view shows the whole diagram as an overview. It is scaled down as needed to completely fit into the available area.

A light-grey overlay rectangle represents the statechart editor's "viewport":https://en.wikipedia.org/wiki/Viewport.
* Drag this rectangle with your mouse to move the statechart editor's viewport.
* Click into the outline view to position the rectangle's center to the point you have clicked.


h4(#edit_hierarchical_outline). Hierarchical outline

Click on the _Outline_ icon in the _Outline_ view's title bar to engage the hierarchical outline.



h3(#edit_problems_view). Problems view

The _problems_ view by default lists all errors, warnings and other types of messages in all open projects.

The messages are grouped by message type, typically "error" or "warning". Click on the show/hide symbol to open or close the respective message group's contents.

Double-clicking on an entry in the _problems_ view takes you directly to the resource or model element causing the problem.

You can configure the _problems_ view in a multitude of ways, e.g., to group entries by different criteria, to sort them in a specific way, or to restrict them to certain projects. You can even define multiple _problems_ views, each with different selection or display criteria.

To start configuring the _problems_ view, click on the small triangle pointing downwards in the _Problem_ view's title bar. A drop-down menu will open and display the options that you have.

To configure the view click the small triangle pointing downwards in the view's title bar. A drop-down menu opens and shows the options you have.

bq. *Please note:* The _problems_ view reflects the error/warning status of _persisted_ statecharts only, i.e., statecharts that have been saved to the statechart file. If you create an error during editing, for example a new state that is not (yet) connected to any other state, the respective element will have an error marker on the canvas, however, it will not appear in the _problems_ view, unless you have saved the statechart. The same holds true for resolved errors: An error will disappear from the _problems_ view only after you saved the fixed error to the statechart file.




h2(#edit_editing_states_and_other_nodes). Editing states and other nodes

Generally, there are two different ways to edit states and other nodes:
* Using the graphical editor to modify a node in the diagram.
* Selecting a node and editing its properties in the _properties_ view.

There are certain properties that you can only edit with one of these methods. For example, to modify a state's position or size, you have to use the statechart editor. To change a state's transitions' priorities, you have to use the _properties_ view.




h2(#edit_editing_transitions). Editing transitions

Generally, there are two different ways to edit transitions:
* Using the graphical editor to modify a transition in the diagram.
* Selecting a transition and editing its properties in the _properties_ view.

There are certain properties that you can only edit with one of these methods. For example, to add guidance points to a transition's arrow, you have to use the statechart editor. To change a transition's arrow's color, you have to use the _properties_ view.




h2(#edit_editing_the_documentation_of_states_and_transitions). Editing the documentation of states and transitions

You can attach documentation to states and transitions. In this context, documentation is some text offering additional information to a human reader. In the model, it does not serve any functional purpose.

By default, a state's rectangle shows the state's behaviour, and a transition shows its expression alongside its arrow. You can instead display an objects's documentation, i.e., the documentation of a state or transition:
# Right-click on the object.
# In the context menu, select _Toggle documentation_.
# The object now shows its documentation in place of the formerly displayed text.

In order to return back to the object's normal view, select _Toggle documentation_ again.

While the documentation is shown, you can modify it in the statechart editor. Double-click on the documentation text field to start editing it. Click outside the state or transition to quit editing.

The _properties_ view of states and transition always shows both documentation and statechart language elements side by side in different compartments. This might be a more comfortable way of editing any of them.




h2(#edit_editing-regions). Editing regions

In a statechart model, you can have
* top-level regions, which are directly placed on the "canvas":#edit_canvas, and
* regions inside of composite or orthogonal states.

Their graphical representation differ somewhat, thus editing them is also somewhat different.



h3(#edit_editing-top-level-regions). Editing top-level regions

You can place a top-level region anywhere on the "canvas":#edit_canvas, and you can change its size at will. To change the location or the size of a region, use the graphical editor. Drag the region to move it elsewhere. Use a selected region's handles to resize it.



h3(#edit_editing_regions_in_orthogonal_states). Editing regions in orthogonal states

Regions inside an orthogonal or composite state are confined by their enclosing state. They are sized automatically, depending on their contents, and they are arranged either vertically or horizontally.

You can toggle between vertical and horizontally representation of regions in an orthogonal state as follows:
# Right-click on the orthogonal state's title. The context menu opens.
# In the context menu, select _Toggle Subregion Alignment_.
# The layout of the regions switches from horizontal to vertical or vice versa.



h3(#edit_changing_the_name_of_a_region). Changing the name of a region

You can change the name of a region in the statechart editor as well as in the _properties_ view.
* In the statechart editor,
** double-click on the region's current name,
** edit the name in the text field that appeares after double-clicking,
** press the @[Return]@ key to finish editing.
* In the properties view,
** modify the _Region Name_ property. It is a region's only property you can access through the properties view.




h2(#edit_editing_hierarchies). Editing hierarchies

Statecharts can get rather big and complex. *"Composite states":../user-guide/statechart_language.html#sclang_composite_states* are a way to reduce complexity and thus make statecharts easier to create, comprehend and maintain. A composite state comprises a state machine of its own within a "region":../user-guide/statechart_language.html#sclang_regions. The states belonging to such a nested state machine are called substates. *"Orthogonal states":../user-guide/statechart_language.html#sclang_orthogonal_states* are a generalization of composite states, comprising two or more independent state machines in separate regions that are executed virtually concurrently.

A complementary way to mitigate the size of large statecharts are *subdiagrams*. A subdiagram externalizes the possibly large region(s) contained by a composite state into a subdiagram. In this case the composite state no longer displays its substates. Instead it is visualized very similarly to a regular state. The only difference is a small icon in its lower right corner, marking it as a composite state and giving access to its internal structure: the subdiagram. This way a composite state consumes much less space and gives the user the opportunity to better envision the overall picture. Section "&quot;Using subdiagrams&quot;":#edit_using_subdiagrams explains how to work with subdiagrams, how to create them and how to inline them again, if needed.

Composite states resp. subdiagrams can be nested to any depth.

The statechart editor provides various "refactorings":#edit_refactorings to support editing these hierarchies.




h2(#edit_using_subdiagrams). Using subdiagrams

As a statechart grows, it may easily become too big to still give a comprehensive overview of the whole model. Subdiagrams come as a solution. Basically, you can "fold away" a composite state into a subdiagram.

!images/docu_subdiagram_010_inline.png(Composite state)!

p=. Composite state

When the _Extract Subdiagram_ "refactoring":#edit_refactorings is executed on a composite state, all containing regions are extracted into a separate diagram. The composite state no longer clutters the diagram with all its internal details, but instead appears almost like a normal state. The only difference is a small decorator icon in the lower-right corner of the state, indicating the existence of a subdiagram. When you hover over this decorator with the mouse cursor, you'll see a small preview of the subdiagram's content.

Extracting a subdiagram creates "entry and exit points":../user-guide/statechart_language.html#sclang_entry_and_exit_points in the subdiagram as needed.

!images/docu_subdiagram_020_preview.png(Subdiagram pop-up window)!

p=. Subdiagram pop-up window

A click on the decorator opens the subdiagram in a separate editor tab. The breadcrumb at the top allows easy navigation throughout the hierachy levels.

!images/docu_subdiagram_030_subdiagram_editor.png(Subdiagram editor)!

p=. Subdiagram editor

Using the "inlining subdiagram refactoring":#edit_inlining_subdiagram, you can turn a subdiagram back into the composite state.


h2(#edit_using_the_definition_section). Using the definition section

By default, a statechart's "definition section":../user-guide/statechart_language.html#sclang_definition_section is positioned at the left-hand side of the "canvas":#edit_canvas.

You can edit the definition section in two different modes: _Legacy mode_ and the new _pinnable mode_.  Starting with version 3.3 of YAKINDU Statechart Tools the "pinnable mode":#edit_pinnable_mode is the default editing mode.



h3(#edit_legacy_mode). Legacy mode

Legacy mode is the definition section's traditional editing mode, which has been available in YAKINDU Statechart Tools for a long time already.

To edit the definition section, double-click into it and enter your statements. While editing, syntax highlighting is applied to the text in the definition section. To quit editing, click outside the definition section. Now the text will appear without any syntax coloring.

Technically, the definition section is part of the "canvas":#edit_canvas. If you print the canvas or save it to an image file, the definition section is included in the result. Definition section and top-level region are always scrolled in sync, which might have the rather unwanted effect that your statechart diagram is scrolled off your screen if you have a very long definition section and you are editing something down below in it.



h3(#edit_pinnable_mode). Pinnable mode

Pinnable mode is an improved editing mode that has been introduced with YAKINDU Statechart Tools 3.20. However, it is slightly incompatible with previous versions, so you have the choice to use it or not.

In pinnable mode, the definition section can be either part of the "canvas":#edit_canvas ("inlined") or not ("pinned"), and you can change that at will. The definition section comes with a little pin symbol !(inlinemediaobject)images/button_pin.png("pin")! at its top-left. Click on it, and the definition section will be detached from the canvas. This has a couple of advantages:
* You can edit definition section and graphical statechart independently of each other. In particular, you can scroll either area as you like, while the other one will remain where it is.
* The definition section is syntax-highlighted all the time.
* If you don't need to see the definition section you can collapse resp. fold it away by clicking on the little triangle in the top-left corner. Click on it once more to make the definition section visible again. Another way to expand the definition section is to click on the vertical bar labeled "Definition section".

!images/docu_editor_definition_section_collapse.png(Collapsing the pinned definition section)!

p=. Collapsing the pinned definition section

!images/docu_editor_definition_section_expand.png(Expanding the pinned definition section)!

p=. Expanding the pinned definition section

By default, the pinned definition section takes 20 percent of the canvas' view, but you can resize it as you like.

You can unpin the definition section and inline it with the canvas. To do so, click on the pin symbol !(inlinemediaobject)images/button_pin.png("pin")!, which in the pinned state is in the definition section's upper-right corner.

bq. *Please note:* The definition section is available for top-level diagrams only. If you are editing a "subdiagram":#edit_using_subdiagrams you will need to use the _Properties View_ to edit the definition of your statechart model.

bq. *Please also note:* Pinning and inlining the definition section changes your statechart model. You have to save it in order to maintain the current status.

!images/docu_editor_definition_section_pin.png(Pinning the statechart diagram definition section)!

p=. Pinning the statechart diagram definition section

!images/docu_editor_definition_section_inline.png(Inlining the statechart diagram definition section)!

p=. Inlining the statechart diagram definition section

In the pinned definition section, you can edit the name of the statechart by changing the displayed text in the top-center of the section.

!images/docu_editor_definition_section_name_edit.png(Changing the statechart name)!

p=. Changing the statechart name




h2(#edit_refactorings). Refactorings

Refactoring means modifying certain model aspects while maintaining the model's semantics. The statechart editor allows for the refactoring of variables, events, interfaces, and states, including composite and orthogonal states. A state's context menu contains the _Refactor_ submenu with the individual refactoring actions explained below. Depending on certain conditions, a refactoring might be executable or not, which will be explained below.



h3(#edit_renaming_variables_events_and_interfaces). Renaming variables, events and interfaces

Using the _Rename_ refactoring, you can change the name of a variable, event or interface throughout your statechart model. Each occurrence of that name will be changed to the new name.

To initiate renaming, right-click on the name of a variable, event or interface in the diagram editor, in the definition section, or in a text field in the _properties_ view, then select _Rename …_.

!images/docu_refactoring_rename_010_renaming_variable.png(Renaming a variable)!

p=. Renaming a variable

* The _Rename …_ dialog opens.
* In that dialog, type the entity's new name into the text field.
* Click on _OK_ to change each occurence of the old name to the new name.
* Click on _Cancel_ to not rename anything.



h3(#edit_folding_incoming_actions). Folding incoming actions

When building a statechart model step by step, you may come into a situation where you have defined several transitions having the same target state and sharing a common set of actions.

The _Fold Incoming Actions_ refactoring moves these actions from the transitions to the target state's entry block. To preserve model semantics, only actions that are defined on _all_ incoming transitions will be moved. Since the execution order must be preserved, the refactoring algorithm starts with the right-most action and proceeds action by action to the left. As soon as it detects an action that is not defined on _all_ incoming transitions, it stops moving actions to the entry block.

Consider the following model:

!images/docu_refactoring_fold_incoming_actions_010_example_01.png(Moving incoming actions to entry block)!

p=. Moving incoming actions to entry block

Only the most-right action _y += 42_ can be moved to the entry block of the target state. Although _x += 1_ is also a common action of both transitions, it cannot be moved to the target state, because the semantics of the _B → Target_ transition would change, in that _y = x_ would be executed before _x_ had been incremented.

Another aspect to take into account are transitions leading to target states that are nested in composite states. Consider the following example:

!images/docu_refactoring_fold_incoming_actions_020_example_02.png(Moving incoming actions into a nested state's entry block)!

p=. Moving incoming actions into a nested state's entry block

The actions _y = x_ of the two incoming transitions leading to the _Target_ state cannot be moved to _Target_'s entry block, because doing so would change the model's semantics. The reason is the composite state's entry action _x += 1_. It will be executed _after_ the action of transition _A → Target_ and _before_ the actions in the entry block of _Target_. Moving _y = x_ from the transition to _Target_'s entry block would change that order. The statechart editor pays regard to this constraint and prohibits the refactoring.

To fold incoming actions, right-click on the state to refactor, then select _Refactor → Fold Incoming Actions_ in the context menu. The menu entry is active only if there are actual actions to move into the target state's entry block, with the above rules applied.



h3(#edit_folding_outgoing_actions). Folding outgoing actions

The _fold outgoing actions_ refactoring is similar to "folding incoming actions":#edit_folding_incoming_actions, except that it moves actions from outgoing transitions to the source state's exit block. To preserve model semantics, only actions that are defined on _all_ outgoing transitions will be moved. Since the execution order must be preserved, the refactoring algorithm starts with the left-most action and proceeds action by action to the right. As soon as it detects an action that is not defined on _all_ outgoing transitions, it stops moving actions to the exit block.

Preconditions for this refactoring are analog to "&quot;Folding incoming actions&quot;":#edit_folding_incoming_actions. Consider the following example:

!images/docu_refactoring_fold_outgoing_actions_010_example_01.png(Moving outgoing actions to exit block)!

p=. Moving outgoing actions to exit block

Here, the actions _y = x_ cannot be moved from the outgoing transitions to the exit block of the source state, because the composite state has an exit action. For the _Source → A_ transition, the proper execution order is to first execute _x += 1_ of the nesting composite state's exit block, followed by _y = x_ of the transition. Moving _y = x_ to the exit block of state _Source_ would reverse this order and thus will be prohibited by the statechart editor.

To fold outgoing actions, right-click on the state to refactor, then select _Refactor → Fold Outgoing Actions_ in the context menu. The menu entry is active only if there are actual actions to move into the source state's exit block, with the above rules applied.



h3(#edit_unfolding_entry_actions). Unfolding entry actions

This refactoring is the reverse of "folding incoming actions":#edit_folding_incoming_actions. It removes all entry actions from a target state and appends them to each of its incoming transition's actions.

Transitions crossing the borders of composite states enclosing the target state might inhibit refactoring, see section "&quot;Unfolding exit actions&quot;":#edit_unfolding_exit_actions for an analogous example.

To unfold entry actions, right-click on the state to refactor, then select _Refactor → Unfold Entry Actions_ in the context menu. The menu entry is active only if there are actual actions in the state's entry block that can be moved to the state's incoming transitions while maintaining semantic equivalence and preserving execution order.



h3(#edit_unfolding_exit_actions). Unfolding exit actions

This refactoring is the reverse of "folding outgoing actions":#edit_folding_outgoing_actions. It moves all exit actions from a source state and prepends them to each of its outgoing transition's actions.

Transitions crossing the borders of composite states enclosing the source state might inhibit refactoring. Consider the following example:

!images/docu_refactoring_unfold_outgoing_actions_010_example_01.png(Unfolding exit actions to outgoing transitions)!

p=. Unfolding exit actions to outgoing transitions

Unfolding the exit action _y = x_ of the _Source_ state to the two outgoing transitions would be invalid, because the execution order of said action and the composite state's exit action would be reversed.

To unfold exit actions, right-click on the state to refactor, then select _Refactor → Unfold Exit Actions_ in the context menu. The menu entry is active only if there are actual actions in the state's exit block that can be moved to the state's outgoing transitions, while maintaining semantic equivalence and preserving execution order.



h3(#edit_grouping_states_into_composite). Grouping states into composite

This refactoring creates a new composite state containing the selected states. The latter must belong to the same region.

To execute this refactoring, select one or more states from the same region, right-click on one of them, and select _Refactor → Group States Into Composite_ in the context menu. The menu entry is active only if the selected states belong to the same region.



h3(#edit_extracting_subdiagram). Extracting subdiagram

This refactoring extracts the regions of the selected composite or orthogonal state into a subdiagram. Entry and exit points are created as needed in the subdiagram. See section "&quot;Using subdiagrams&quot;":#edit_using_subdiagrams for more details.

To extract a subdiagram, right-click on the composite or orthogonal state to refactor, then select _Refactor → Extract Subdiagram_ in the context menu.



h3(#edit_inlining_subdiagram). Inlining subdiagram

This refactoring inlines the selected node's subdiagram in order to show it directly in the composite state's diagram region. See section "&quot;Using subdiagrams&quot;":#edit_using_subdiagrams for more details.

To inline a subdiagram, right-click on a composite state with a subdiagram, then select _Refactor → Inline Subdiagram_ in the context menu.




h2(#edit_using_editing_proposals). Using editing proposals

h3(#edit_using_text_proposals). Using text proposals

Proposals assist you when writing statechart language expressions. Whenever editing some text anywhere in the graphical statechart editor or in the properties view, at any point you can press the @[Ctrl+Space]@ key combination to get some context-sensitive help.

Certain proposals, like statechart language keywords, have documentation associated with them. When such a proposal is selected, either using the mouse or the keyboard, this information is shown in a secondary pop-up window next to the proposal.

You can either use the mouse or the keyboard to select and insert a proposal in the text:
* Double-click on a proposal to insert it in the text at the current position.
* Use the up and down arrow keys to navigate to the proposal you want to insert in the text, then press @[Return]@ to actually insert the proposal at the current position.



h3(#edit_using_action_proposals_on_states). Using actions proposals on states

When a state is selected, @[Ctrl+Space]@ opens a pop-up window showing a context-sensitive menu with possible action choices to perform on the state.

These action proposals have additional information associated to them. When a proposal is selected either using the mouse or the keyboard, this information is shown in a secondary pop-up window next to the proposal.

You can either use the mouse or the keyboard to execute a proposal:
* Double-click on a proposal to execute it.
* Use the up and down arrow keys to navigate to the proposal you want to execute, then press @[Return]@ to actually execute it.



h2(#search_and_nav_searching_and_navigating_in_statecharts). Searching and navigating in statecharts

YAKINDU Statechart Tools support you in quickly finding model elements and navigating to them.

The larger the model, the greater the need to quickly search for certain elements, e.g., for all states with a given name or name pattern, all occurrences of a certain variable, etc. YAKINDU Statechart Tools' searching functionality helps you master even large statecharts.

###. FIXME (RKL): Describe how to find transitions!




h3(#search_and_nav_searching_via_search_dialog). Searching via search dialog

One option, and the most complex one, is to use the search dialog. You can open it using the @[Ctrl+H]@ shortcut or by selecting _Search → Search…_ in the main menu.

Doing so will open a dialog with several tabs, as shown in the following screenshot:<br/>!images/search_and_nav_search_dialog.png(Search Dialog)!

The tab you want to use is _Statechart search_.

bq.. *Please note:* If you cannot find this tab, you probably disabled it in the past by mistake. You can enable it again by clicking on the _Customize…_ button and selecting _Statechart Search_, as shown by the following figure:

!images/search_and_nav_customize_dialog.png(Customize Dialog)!

Switching to _Statechart search_ will show you a clean and easy to understand dialog, which can be extended using the _Show advanced settings_ check box for a more professional usage. The following subsection describes the possible settings.

bq.. *User tip:* Checking the _Remember last used page_ option in the _Customize_ dialog will help you to keep the focus on the _Statechart Search_ tab for further search processes.



h4(#search_and_nav_search_dialog_settings). Search dialog settings

The _Statechart search_ dialog has several options to control your search.

!images/search_and_nav_model_search_dialog_extended.png(Advanced search dialog)!

The following table lists the various search options and explains what the search function does if the corresponding checkmark is set.

|_. Setting |_. Description |
| _Case sensitive_ | Differentiate between upper-case and lower-case letters in the search string. If this option is not checked, upper-case letters and their corresponding lower-case letters are regarded the same. |
| _Regular expression_ | Interpret the search string as a "regular expression":https://en.wikipedia.org/wiki/Regular_expression. Please note that YAKINDU Statechart Tools supports Java regular expressions, as explained in the "java.util.regex.Pattern class API documentation":https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html. |
| _Search for states/regions_ | Include states and regions with matching _names_ in the search result. |
| _Search for declarations_ | Include matching declarations in the search result. _Declarations_ are statechart language elements in the definition section, such as variables, events, operations, and named interfaces. The search function will find all occurrences of matching elements. |
| _Search for properties_ | Include elements with matching _properties_ in the search result. The following items are regarded as properties: <ul><li>_Documentation_ of model elements</li><li>_Behavior_ of states, i.e., local actions, etc.</li><li>_Text_ of text elements and notes !(inlinemediaobject)images/docu_editor_palette_070_symbol_note.png(editor palette symbol "Note")!</li></ul> |
| _Scope: workspace_ | Perform the search operation on _all_ statecharts in the workspace. |
| _Scope: selected resources_ | If a statechart editor has the focus, perform the search operation only on that statechart. If the _Project explorer_ view has the focus, perform the search operation on all statecharts in the selected resources. |

###. CHECK: The documentation above refers to the Java 8 documentation as reference of Java regular expressions. Is this still appropriate?




h3(#search_and_nav_search_view). Search view

After setting the search options as needed, run the search using the _Search_ button. The search results will be shown in a view called _Search_.

We will demonstrate the search view using the light switch example from our "five-minutes tutorial":../tutorials/tutorials.html#tutorial_five-minutes_tutorial, using the following settings:

|_. Setting                   |_. Value |
| _Search string_             | O* |
| _Case sensitive_            | ✘  |
| _Regular expression_        | ✘  |
| _Search for states/regions_ | ✔  |
| _Search for declarations_   | ✔  |
| _Search for properties_     | ✔  |
| _Scope: Workspace_          | ✔  |
| _Scope: Selected resource_  | ✘  |

###. FIXME: Don't use an "O" in the example, because of danger of confusion with a "0".

###. FIXME: A screenshot would be better than a table.

The search view consists of three main components and looks like the following screenshot.

!(full)images/search_and_nav_result_view.png(Search view)!

|_. Component |_. Functions |
| !(inlinemediaobject)images/search_and_nav_number_1.png(Searchbar text section)! Searchbar text section | Displays the search string and the number of matches. The latter is updated while the search is running. |
| !(inlinemediaobject)images/search_and_nav_number_2.png(Toolbar section)! Toolbar section| See section "&quot;Toolbar section&quot;":#search_and_nav_search_toolbar_section |
| !(inlinemediaobject)images/search_and_nav_number_3.png(Result section)! Result section | See section "&quot;Result section&quot;":#search_and_nav_search_result_section |



h4(#search_and_nav_search_toolbar_section). Toolbar section

The toolbar section consists of ten buttons with the following functionalities:

|_ Button |_ Action |_ Functionality |
| !(inlinemediaobject)images/search_and_nav_icon_redo.png(Redo search)! | Redo search |Executes the same search again on the possibly changed model. |
| !(inlinemediaobject)images/search_and_nav_icon_stop.png(Cancel searching)! | Cancel searching | Cancels a currently running search. The button is active only if a search run is being executed. |
| !(inlinemediaobject)images/search_and_nav_icon_search.png(History)!!(inlinemediaobject)images/search_and_nav_icon_list.png(History)! | History | Use this function to display the search history, to select a formerly-executed search (click on _Redo search_ to actually execute it), or to clear the history. |
| !(inlinemediaobject)images/search_and_nav_icon_pin.png(Pin search)! | Pin search | Pins the results view. Future search results will be shown in a new search view, instead of rewriting the pinned search view. |
| !(inlinemediaobject)images/search_and_nav_icon_collapse.png(Collapse all)! | Collapse all | Collapses the search result tree and displays the root entries only. |
| !(inlinemediaobject)images/search_and_nav_icon_expand.png(Expand all)! | Expand all | Expands the search result tree and displays all search result entries. |
| !(inlinemediaobject)images/search_and_nav_icon_menu.png(Search menu)! | Search menu |Contains various search options. |
| !(inlinemediaobject)images/search_and_nav_icon_minimize.png(Minimize)! | Minimize |Minimizes the search view and all its sibling views. A "restore" symbol is shown in a sidebar. |
|  !(inlinemediaobject)images/search_and_nav_icon_maximize.png(Maximize)! | Maximize |Maximizes the search view and all its sibling views to the full window size. |
|  !(inlinemediaobject)images/search_and_nav_icon_restore.png(Restore)!| Restore | Undoes the _Maximize_ function. This button is shown only if the search view is maximized. |



h4(#search_and_nav_search_result_section). Result section

The result section displays the matching statechart elements in a two-column, tree-based view.
* The left-hand column, named _Location_, shows _location_ and _type_ of each match. Additionally, the whole path from the project down to the matching element is shown.
* The right-hand column, named _Matches_ shows the matches themselves. Intermediate path elements that are no matches but are displayed in the _Location_ column don't have a counterpart in the _Matches_ column.

!(full)images/search_and_nav_result_section_actions.png(Result section actions)!

You can perform certain actions on the entries in the first column:

|_.  |_. Action |_. Function |
| !(inlinemediaobject)images/search_and_nav_letter_a.png(A)! | Click on the !(inlinemediaobject)images/search_and_nav_icon_collapse_children.png(collapse children)! button | "closes" the node and collapses all child nodes. |
| !(inlinemediaobject)images/search_and_nav_letter_b.png(B)! | Click on the !(inlinemediaobject)images/search_and_nav_icon_expand_children.png(expand children)! button | "Opens" the node and expands its immediate child nodes. |
| !(inlinemediaobject)images/search_and_nav_letter_c.png(C)! | Double-click on a matching element | Navigates to the matching element in the statechart editor, as long a it is not a descendant of an _internal_ or _interface_ element. |
| | Double-click on a non-matching path element | Closes an expanded node, opens a collapsed node. |




h3(#search_and_nav_finding_references). Finding references

Another realized search feature is to find references of model elements. You can perform this search on choosing _Find references_ in the context menu of:
* model elements in the editor
* model elements in the project explorer
* referenced object in syntax-checking editors inside statechart models like the definition section or the state behavior editor 

This will search for usages of the same element in the local statechart and display them in the "search view":#search_and_nav_search_view. Using this method can help you to save time searching for usages of variables, events and operations inside your statechart.

The next section introduces the differences between the first method and this method.




h3(#search_and_nav_differences_1). Differences between "Find references" and "Search dialog"

As stated in the previous section, _Find references_ is searching for the usages of the exact same model element as selected, whereas in the _Search dialog_, you have to enter a search string which will find all occurrences of model elements that match the search string.

Finding occurrences of model elements matching the search string makes it possible to search in different statecharts at the same time, while finding references of a model element is limited to the statechart defining that model element. Depending on your search goals, one method could be more suitable than the other.

To clarify the difference between these methods, different search operations were done using the same model. The used model can be taken from the following figure. It does not have any meaning and is only used for clarification purposes.

###. FIXME (RKL): It puzzles me that finding references not only finds references, but also finds definitions. Consequently, the function should be called "find occurrences".

!images/search_and_nav_differences_model.png(Example Model)!

|_. Search operation |_. Results |
| _Find references_ on variable _test_ in the default (unnamed) interface| Finds two matches:<ul><li>Entry action in the *test* state using the _test_ variable</li><li>Definition of the _test_ variable in the unnamed interface</li></ul> |
| _Find references_ on variable _test_ in named interface _first_| Finds one match:<ul><li>Definition of the _test_ variable in the named interface _first_</li></ul> |
| _Find references_ on state *test* | Finds one match:<ul><li>The *test* state itself</li></ul> |
| _Search Dialog_ with the same settings as in section "&quot;Search view&quot;":#search_and_nav_search_view and _&quot;test&quot;_ being the search string | Finds four matches:<ul><li>Entry action in the *test* state using the _test_ variable</li><li>Definition of the _test_ variable in the unnamed interface</li><li>Definition of the _test_ variable in the named interface _first_</li><li>The *test* state</li></ul> |
| _Search Dialog_ with the same settings as in section "&quot;Search view&quot;":#search_and_nav_search_view and _&quot;test&quot;_ being the search string | Finds one match:<ul><li>Definition of the _test_ variable in the named interface _first_</li></ul> |
| _Search Dialog_ with almost the same settings as in section "&quot;Search view&quot;":#search_and_nav_search_view, but with _Search for declarations_ deactivated and with _&quot;test&quot;_ being the search string | Finds match:<ul><li>The *test* state</li></ul> |
| _Search Dialog_ with almost the same settings as in section "&quot;Search view&quot;":#search_and_nav_search_view, but with _Search for states/regions_ deactivated and with _&quot;test&quot;_ being the search string | Finds three matches:<ul><li>Entry action in the *test* state using the _test_ vwe should ariable</li><li>Definition of the _test_ variable in the unnamed interface</li><li>Definition of the _test_ variable in the named interface _first_</li></ul> |

###. FIXME: Why is the entry action not found in case 6?

As can be seen in this case the search dialog has problems with searching references for the variable _test_ in the unnamed interface.

###. FIXME: We should not have such a sentence in the documentation. I don't understand what it means. It sounds like an error we should fix.




h3(#search_and_nav_open_model_element). Open model element 

_Open model element_ is another kind of search method. It can be used to quickly navigate to states and regions. To access _Open model element_, use the @[Ctrl+Shift+Q]@ shortcut or select _Navigate → Open model element_ in the main menu.

By doing so, the dialog shown in the next screenshot will open.

!images/search_and_nav_open_model_element_dialog.png(Open model element)!

The dialog consists of a single input element !(inlinemediaobject)images/search_and_nav_number_1.png(Searchbar)! and two output elements !(inlinemediaobject)images/search_and_nav_number_2.png(Result list)! / !(inlinemediaobject)images/search_and_nav_number_3.png(Result location)!.

A search operation performed with _Open model element_ is equivalent to "&quot;Searching via search dialog&quot;":#search_and_nav_searching_via_search_dialog with the following setting:

|_. Setting |_. Value |
| _Search string_|same as in !images/search_and_nav_number_1.png(Searchbar)! |
| _Case sensitive_ | ✘  |
| _Regular expression_ |  ✘ |
| _Search for States/Regions_ | ✔|
| _Search for Declarations_ |✘|
| _Search for Properties_ |✘ |
| _Scope: Workspace_ | ✘ |
| _Scope: Selected resource_ |✔ |

Differences between _Open model element_ and _Search dialog_ are subtle, but noticeable. The results will promptly appear in !(inlinemediaobject)images/search_and_nav_number_2.png(Result list)! while typing your search string in !(inlinemediaobject)images/search_and_nav_number_1.png(Searchbar)!. The hierarchy of a selected result is displayed in !(inlinemediaobject)images/search_and_nav_number_3.png(Result location)! as a text instead of using a tree.

Navigating to a result can be done by double-clicking on the result. Or select the result and clicking on the _OK_ button or hit the @[Enter]@ key.

The _Open model element_ dialog remembers any matching search results. On reopening the dialog, remembered model elements matching the new search string will be displayed above any newly-found elements. This makes it easier to navigate to them again at a later time.

!images/search_and_nav_open_model_element_dialog_saved_elements.png(Remembered elements)!

Remembered elements can be removed from the history by selecting them and pressing the @[Del]@ key or by right-clicking on a remembered element and choosing _Remove from history_ in the context menu.



h2(#edit_comparing_statecharts). Comparing statecharts

The statechart editor allows for comparing two or even three statecharts to each other, displaying the results, and possibly merging selected differences. Figure "&quot;Comparing two statecharts&quot;":#edit_fig_comparing_two_statecharts shows a sample comparison result.

p(#edit_fig_comparing_two_statecharts). 

!images/docu_comparing_statecharts_010_result.png(Comparing two statecharts)!

p=. Comparing two statecharts



h3(#edit_comparing_a_statechart_to_its_local_history). Comparing a statechart to its local history

Whenever a statechart is saved to its statechart file, the previous version of the file is saved to the local history.

bq. *Warning:* The local history typically contains a few recent versions of a file. However, you should never rely on anything being available in the local history at all. It is definitely no replacement for a data backup or a version control system

To compare a statechart to an older version in the local history, proceed as follows:

# In the _project_ view, right-click on a statechart model file. The context menu opens.
# In the context menu, select _Compare With → Local History…_.
# In the local history, double-click on the file's version to compare to.
# The comparison results are shown.



h3(#edit_comparing_two_statecharts). Comparing two statecharts

To compare two statecharts, proceed as follows:

# In the _project_ view, select two statechart model files.
# Right-click on one of the selected statechart model files. The context menu opens.
# In the context menu, select _Compare With → Each Other_.
# The comparison results are shown.



h3(#edit_comparing_three_statecharts). Comparing three statecharts

To compare three statecharts, proceed as follows:

# In the _project_ view, select three statechart model files.
# Right-click on one of the selected statechart model files. The context menu opens.
# In the context menu, select _Compare With → Each Other_.
# The _Select common ancestor_ dialog appears. It shows the three selected statechart model files.
# Select one of them. It will be regarded as the common ancestor of the two others.
# The comparison results are shown.




h2(#edit_exporting_a_statechart_as_an_image_file). Exporting a statechart as an image file

A complete statechart or parts of it can be saved as an image file as shown in the following steps:

* In the statechart editor:
** To create an image file _of the whole statechart_ with all regions and definition sections, inline the definition section via the button on the top right of it and then right-click on the main region and select _File → Save As Image File..._.
** To create an image file _of some statechart elements_, select these elements and right-click on one of them. In the example below, the main region has been selected.
* The context menu appears.<br/>!images/docu_exporting_statechart_as_image_010_save_as_menu_item.png(Selecting the "Save As Image File..." menu item)!
* In the context menu, select _File → Save As Image File..._.
* The _Save As Image File_ dialog appears.<br/>!images/docu_exporting_statechart_as_image_020_save_as_dialog.png(The "Save As Image File" dialog)!
* Specify the filesystem folder for the exported image file in the _Folder_ text field.
* Enter the name of the export image file into the _File Name_ text field. The filename extension depends on the selected image format (see below).
* Select the image format from the _Image Format_ drop-down menu. YAKINDU Statechart Tools supports the following formats:<br/><table><tbody><tr><th>Image format</th><th>Description</th></tr><tr><td>BMP, PNG</td><td>Lossless pixel image formats</td></tr><tr><td>JPG, JPEG</td><td>Lossy pixel image format. You can specify the image quality via the _Quality (%)_ setting.</td></tr><tr><td>SVG</td><td>Scalable Vector Graphics</td></tr><tr><td>PDF</td><td>Portable Document Format</td></tr></tbody></table><blockquote><p>*Note*</p><p>The image export functionality is subject to the capabilities of your Java Runtime Environment (JRE). You can export images only in those image formats your JRE actually supports.</p></blockquote>
* The _Quality (%)_ text field is active for JPEG images only. JPEG is a lossy format, and reducing the quality results in a smaller file size. However, due to the nature of statechart images, a lossless format like PNG is most often a better choice, for sure in quality and perhaps even in file size.
* Check _Overwrite existing file without warning_ if you don't want to be bothered by a confirmation dialog which will appear if the export file already exists.
* Check _Export to HTML_ to create both the image file plus an HTML file including it.




h2(#edit_working_with_statechart_tasks). Working with statechart tasks

While you are busily developing a statechart, it is quite common that you have ideas about what else you could or should do to improve the statechart. However, in order to not get side-tracked, you decide to do it later. Examples are to write a proper documentation for a state, to refine a transition whose final specification you don't have yet, etc.

For all these and other purposes you can define _tasks_ in all places in your statechart where a comment is allowed. A task is a special comment comprising the words @FIXME@ or @TODO@. Adding one of these words to a comment is called "tagging" the comment as a task.

The nice thing is that you don't have to remember all the places you took a note and defined a task. YAKINDU Statechart Tools lists all of your tasks in the _tasks_ view. Figure "&quot;Tasks defined by tags in the statechart showing up in the _tasks_ view&quot;":#edit_fig_tasks_defined_by_tags_in_the_statechart_showing_up_in_the_tasks_view is showing an example with various tasks being defined in a transition, in a state's behavior, in a state's documentation, and in the statecharts definition section.

p(#edit_fig_tasks_defined_by_tags_in_the_statechart_showing_up_in_the_tasks_view). 

!images/docu_task_tags_010_task_view.png(Tasks defined by tags in the statechart showing up in the "tasks" view)!

p=. Tasks defined by tags in the statechart showing up in the _tasks_ view

In the example, state *B* has been selected in the statechart editor (top), so that the tasks defined in the state's behavior and in its documentation are shown in the _properties_ view (middle).

Task have a priority. While @TODO@ stamps a task as being of normal priority, @FIXME@ indicates a high-priority task.

By default, tasks are ordered by priority in the _tasks_ view (bottom), and high-priority tasks are accentuated by a red exclamation mark. However, you can change the sorting order and other settings using the view's menu. Click on the little triangle on the right-hand side of the _task_ view's title to open the view menu.

Double-clicking on a task in the _tasks_ view navigates to the location where the task is defined. If needed, the corresponding statechart diagram is opened. The graphical element holding the task definition is highlighted.

bq.. *Note*

The _tasks_ view is updated only when the statechart is saved.



###.. h3(#edit_defining_task_tags). Defining task tags

# In the main menu, select _Window → Preferences_. The _Preferences_ Dialog opens.
# In the _Preferences_ Dialog goto _Java → Compiler → Task Tags_ to edit your task tag preferences. A task tag has one of the priorities _High_, _Normal_, or _Low_.




h2(#edit_using_the_example_wizard). Using the example wizard

The _example wizard_ gives you convenient access to the examples in the public YAKINDU Statechart Tools "examples repository":https://github.com/Yakindu/examples. You can browse the available examples and read their documentation in the wizard. By a simple click you can instantiate an example as a new Eclipse project. Within such a sample project, you can explore and modify the state machine models using the statechart editor, run the state machines in the simulator, generate source code, etc.

Upon its first invocation, the example wizard downloads the complete examples repository and creates a copy on your local disk. After that, all examples are immediately available to you, even if you are offline. The example wizard will take notice when new examples are available in the online repository and offers to download them. It is also possible to download the examples repository out-of-band and later tell the example wizard where it can find the local copy.



h3(#edit_downloading_the_examples_repository). Downloading the examples repository

When you start the example wizard for the first time, it does not yet have any examples available that it could show to you. Thus downloading the online examples repository is required as a special first step.

# In order to start the example wizard, select _File → New → Example…_ in the YAKINDU Statechart Tools main menu. The _New Example_ dialog opens.
# In the _New Example_ dialog, select _YAKINDU Statechart Examples_, then click on _Next >_. The example wizard opens.
# The example wizard outputs a message saying that it could not find any examples and offers to download them.
# Click on the _Download_ button. The example wizard downloads the online examples repository and creates a clone of it on your local computer. This can take some time. – Downloading can fail for a variety of reasons, not being able to access the Github server being one of them. If this happens, don't panic – and read how to "manually create a local copy of the examples repository":#edit_manually_creating_a_local_copy_of_the_examples_repository.

!images/docu_example_wizard_download.png(Example wizard when invoked for the first time)!

p=. Example wizard when invoked for the first time

When the download is completed, you can "browse the examples repository":#edit_browsing_the_example_repository.



h3(#edit_changing_the_repository_location). Changing the repository location

You can change the location used by the example wizard to store the online repository's local clone.

# When the example wizard shows the _Download_ button on its first start, click on the link _"change the storage location here"_. The example wizard's preferences dialog opens. Alternatively, open _Window → Preferences_ and select _YAKINDU SCT → Example wizard_.
# On the examples preferences page, enter the desired directory into the _Storage Location_ text field.
# Click on _OK_. The dialog closes.

You can change the storage location of your local examples repository clone at any time. In fact, it doesn't even need to be a clone of the official examples repository. Any directory containing subdirectories with YAKINDU Statechart Tools examples suffices.

* If the directory exists, the example wizard searches it for examples and displays them.
* If the directory does not exist, the example wizard behaves as if being called for the first time. That is, it informs the user that it does not have any examples yet and offers to download them.



h3(#edit_browsing_the_example_repository). Browsing the examples repository

The example wizard shows the available examples on the left-hand side.

Click on an example to select it and show its documentation on the right-hand side.

Click on _Finish_ to create the selected example as a new project in your workspace.

!images/docu_example_wizard_browse.png(Example wizard showing all available examples)!

p=. Example wizard showing all available examples



h3(#edit_manually_creating_a_local_copy_of_the_examples_repository). Manually creating a local copy of the examples repository

The _example wizard_ tries to download a copy of the YAKINDU Statechart Tools examples repository and install it on your local machine. However, if your Internet access is restricted or you don't have Internet access at all, this will fail.

To circumvent this problem, you can

# download the examples repository elsewhere, i.&nbsp;e. on a computer with Internet access,
# copy it to the computer you want to run YAKINDU Statechart Tools, and
# have the example wizard work with that local copy.

Subsequently we will explain the necessary steps in detail.

Downloading the repository as a ZIP archive:

# On a computer with Internet access, go to the "examples repository's release branch":https://github.com/Yakindu/examples/tree/release.
# Click on the green _Clone or download_ button. A submenu opens.
# In the submenu, click on _Download ZIP_.
# The download starts and transfers the ZIP archive file _examples-release.zip_ to your computer.
# Copy the _examples-release.zip_ file to the computer without Internet access and continue with the following steps on that machine.
# Unpack the archive file. A directory named _examples-release_ is created, containing the YAKINDU Statechart Tools examples repository.
# In YAKINDU Statechart Tools, select _Window → Preferences_. The _preferences_ dialog opens.
# In the _preferences_ dialog, navigate to _YAKINDU SCT → Example wizard_.
# Click on _Browse..._, and select the folder that you just extracted from the ZIP file, then click _OK_.
# On the next try, the example wizard will now show a catalogue of YAKINDU Statechart Tools examples.

Alternatively, you can clone the repository. Cloning the examples repository containing the YAKINDU Statechart Tools examples is more complex than just downloading a ZIP archive. However, you will get certain advantages in return, like the ability to detect and receive updates, the option to create your own examples and submit them as a pull request, or to get hold of the complete history of the examples repository – which could also be considered a drawback, taking its size into account.

# Clone "https://github.com/Yakindu/examples":https://github.com/Yakindu/examples to your local computer. If you are using a command-line tool, the proper command to create the directory _examples_ on your disk is:<br/>@git clone 'https://github.com/Yakindu/examples.git'@
# Step into that directory:<br/>@cd examples@
# Checkout the _release_ branch:<br/>@git checkout release@<br/>Now the _examples_ directory reflects the current release state.
# In the YAKINDU Statechart Tools main menu, select _File → New → Example…_. The _New Example_ dialog opens.
# In the _New Example_ dialog, select _YAKINDU statechart examples_ and click on _Next >_. The example wizard opens.
# When the example wizard is opened for the first time, there are no examples on the local disk yet.
# In YAKINDU Statechart Tools, select _Window → Preferences_. The _preferences_ dialog opens.
# In the _preferences_ dialog, navigate to _YAKINDU SCT → Example wizard_.
# Click on _Browse..._, and select the folder you just cloned, then click _OK_.
# On the next try, the example wizard will show a catalogue of YAKINDU Statechart Tools examples.



h3(#edit_updating_the_examples_respository). Updating the examples repository

When the example wizard is started and the storage location is a clone of the online examples directory, it checks whether there are any updates in the online examples repository. If new examples are available or existing examples have changed in the online repository, the example wizard offers to update your local examples repository clone accordingly.

!images/docu_example_wizard_update.png(Example wizard offering to update the examples repository)!

p=. Example wizard offering to update the examples repository

* Click on the _Update_ button to update your local repository.

If your storage location is a plain directory and not a clone of the online examples repository, no update will ever be done.



h3(#edit_contributing_your_own_examples). Contributing your own examples

If you have a project that you want to share with the community, you can contribute it as an example. Once the YAKINDU team has reviewed and applied your contribution, it will be available for all users of YAKINDU Statechart Tools via the example wizard's update functionality.

For more information on how to contribute examples, please visit our "Wiki page":https://github.com/Yakindu/examples/wiki/Creating-a-YAKINDU-Statechart-Tools-Example.




h2(#edit_preferences). Preferences

Many aspects of YAKINDU Statechart Tools can be configured by _preferences_. You can find them here:

# In the main menu, select _Window → Preferences_. The _Preferences_ dialog appears.
# In the navigation on the left-hand side, scroll to _YAKINDU SCT_. Open it and its subentries as needed.
# Click on an entry to display the associated preference page on the right-hand side of the _Preferences_ dialog, see, e.g., figure "&quot;Preferences: Diagram appearance&quot;":#edit_fig_preferences_diagram_appearance.

In the subsequent sections we will quickly walk through the preferences.



h3(#edit_diagram_appearance). Diagram appearance

p(#edit_fig_preferences_diagram_appearance). 
!images/docu_preferences_010_diagram_appearance_01.png(Preferences: Diagram appearance)! 

p=. Preferences: Diagram appearance


h4(#edit_colors_line_styles_and_fonts). Colors, line styles, and fonts

The "diagram appearance":#edit_fig_preferences_diagram_appearance preferences define
* the _default colors_ for the backgrounds and borders of states and regions,
* the _default routing style_ for transitions and other lines, with _oblique_ and _rectilinear_ being the options at your choice, and
* the _default font_ for any text.

Please keep in mind that these settings will apply to _new_ elements only. Existing regions, states, etc. will remain as they are. However, you can modify the properties of an existing element anytime, using its properties view.

h4(#font-scaling). Font scaling

This option is only available on Microsoft Windows. By default, font scaling is deactivated in YAKINDU Statechart Tools. If you are working on different machines with different Windows font scaling, this option can be enabled to have the same font and box sizes on all machines. 

h4(#syntax-coloring). Syntax coloring

By default, YAKINDU Statechart Tools highlights textual statechart language elements in different colors while the corresponding text fragment is being edited.

If the _"Enable syntax coloring"_ option is checked, syntax highlighting is turned on all the time, i.e., also for text that is not being edited.

You can configure the colors to actually use on the following preference pages:
* "_Expression syntax coloring_":#edit_expression_syntax_coloring
* "_Generator model syntax coloring_":#edit_generator_model_syntax_coloring
* "_SCTUnit syntax coloring_":#edit_sctunit_syntax_coloring


h4(#definition-section-pinning). Definition section pinning

Check or uncheck the _"Enable pinning of statechart definition section pinning"_ option to toggle between pinning and legacy mode of the definition section. Section "&quot;Using the definition section&quot;":#edit_using_the_definition_section explains what this is all about.


h4(#edit_showing_transition_and_region_priorities). Showing transition and region priorities

In order to display "transition and region priorities":../user-guide/statechart_language.html#sclang_transition_priorities in a statechart, set a check mark at the respective preference option. Section "&quot;Transition priorities&quot;":../user-guide/statechart_language.html#sclang_transition_priorities explains what transition priorities are and shows an example.


h4(#edit_disabling_live_validation). Disabling live validation

While you are editing a statechart, the statechart editor validates your model on each and every modification you make. That's very helpful, because the editor provides you with instant feedback, so you can see immediately what is right, wrong, or dubious, and you can take corrective action, if needed.

However, on very large and complex statechart models, validation may take a considerable amount of time, causing delays and impeding your editing. Remove the check mark from _Enable live validation_, and your model will be validated only before it is saved to the statechart file.



h3(#edit_example_wizard). Example wizard

p(#edit_fig_preferences_example_wizard). 
!images/docu_preferences_020_examples_01.png(Preferences: Example wizard)!

p=. Preferences: Example wizard

You can change the example wizard storage location here. This is a local directory where the "example wizard":#edit_example_wizard stores your local clone of the examples Git repository. The default is the _sct_examples_ directory in your home directory.

You could also change the location of the Git repository and the branch to use, but you won't probably want to do that.



h3(#edit_expressions_preferences). Expressions preferences

p(#edit_fig_preferences_expressions). 
!images/docu_preferences_030_expressions_01.png(Preferences: Expressions)!

p=. Preferences: Expressions

Certain dialogs in the statechart editor allow you to opt for never seeing them again. By clicking on the _Clear_ button on this preference page the hidden dialogs pertaining to the statechart language will be shown again at their respective locations.


h4(#edit_expression_syntax_coloring). Expression syntax coloring

p(#edit_fig_preferences_expression_syntax_coloring). 
!images/docu_preferences_040_expressions_syntax_coloring_01.png(Preferences: Expression syntax coloring)!

p=. Preferences: Expression syntax coloring

This preference page defines foreground color, background color, font, and style for displaying certain syntactical elements in statechart language texts.


h4(#edit_expression_templates). Expression templates

p(#edit_fig_preferences_expression_templates). 
!images/docu_preferences_050_expressions_template_01.png(Preferences: Expression templates)!

p=. Preferences: Expression templates

Templates are sections of textual code that occur frequently enough to make you want to insert them with a few keystrokes only. This function is known as _content assist_; the sections of code that are inserted are known as _templates_.

To insert an existing content assist template, type the initial character, then press @[Ctrl+Space]@. The templates whose names begin with that character will appear. Double-click on a template to insert it.

On this preference page you can create, edit, and delete statechart language templates.



h3(#edit_generator_model). Generator model

p(#edit_fig_preferences_generator_model). 
!images/docu_preferences_060_generator_model_01.png(Preferences: Generator model)!

p=. Preferences: Generator model

By default, code generators automatically generate artifacts defined by generator models in _.sgen_ files. Using this preference setting, you can switch this behavior off or on.


h4(#edit_generator_model_refactoring). Generator model refactoring

p(#edit_fig_preferences_generator_model_refactoring). 
!images/docu_preferences_070_generator_model_refactoring_01.png(Preferences: Generator model refactoring)!

p=. Preferences: Generator model refactoring

Change these preference settings for refactoring in generator models as you see fit.

The _"Save all modified resources automatically prior to refactoring"_ option is somewhat dangerous, because you might have made changes to files that you intentionally do _not_ want to save to disk – or at least not yet. For that reason, this option is turned off by default.

The _"Rename in editor without dialog if possible"_ pertains to how the renaming operation is performed. By default, if you click on a name and press @[Shift+Alt+R]@, you can edit the name directly in the source code, and all other occurences of that element are renamed while you are typing. If this is not possible or if this option is not checked, a dialog will ask you for the element's new name.


h4(#edit_generator_model_syntax_coloring). Generator model syntax coloring

p(#edit_fig_preferences_generator_model_syntax_coloring). 
!images/docu_preferences_080_generator_syntax_coloring_01.png(Preferences: Generator model syntax coloring)!

p=. Preferences: Generator model syntax coloring

This preference page defines foreground color, background color, font, and style for displaying certain syntactical elements in generator model texts.


h4(#edit_generator_model_templates). Generator model templates

p(#edit_fig_preferences_generator_model_templates). 
!images/docu_preferences_090_generator_templates_01.png(Preferences: Generator model templates)!

p=. Preferences: Generator model templates

Templates are sections of textual code that occur frequently enough to make you want to insert them with a few keystrokes only. This function is known as _content assist_; the sections of code that are inserted are known as _templates_.

To insert an existing content assist template, type the initial character, then press @[Ctrl+Space]@. The templates whose names begin with that character will appear. Double-click on a template to insert it.

On this preference page you can create, edit, and delete generator model language templates.



h3(#edit_sctunit). SCTUnit

p(#edit_fig_preferences_sctunit). 
!images/docu_preferences_091_sctunit_01.png(Preferences: SCTUnit)!

p=. Preferences: SCTUnit

Certain dialogs in SCTUnit allow you to opt for never seeing them again. By clicking on the _Clear_ button on this preference page the hidden dialogs pertaining to SCTUnit will be shown again at their respective locations.


h4(#edit_sctunit_refactoring). SCTUnit refactoring

p(#edit_fig_preferences_sctunit_refactoring). 
!images/docu_preferences_092_sctunit_refactoring_01.png(Preferences: SCTUnit refactoring)!

p=. Preferences: SCTUnit refactoring

Change these preference settings for refactoring in SCTUnit source files as you see fit.

The _"Save all modified resources automatically prior to refactoring"_ option is somewhat dangerous, because you might have made changes to files that you intentionally do _not_ want to save to disk – or at least not yet. For that reason, this option is turned off by default.

The _"Rename in editor without dialog if possible"_ pertains to how the renaming operation is performed. By default, if you click on a name and press @[Shift+Alt+R]@, you can edit the name directly in the source code, and all other occurences of that element are renamed while you are typing. If this is not possible or if this option is not checked, a dialog will ask you for the element's new name.


h4(#edit_sctunit_syntax_coloring). SCTUnit syntax coloring

p(#edit_fig_preferences_sctunit_syntax_coloring). 
!images/docu_preferences_093_sctunit_syntax_coloring_01.png(Preferences: SCTUnit syntax coloring)!

p=. Preferences: SCTUnit syntax coloring

This preference page defines foreground color, background color, font, and style for displaying certain syntactical elements in SCTUnit source texts.


h4(#edit_sctunit_templates). SCTUnit templates

p(#edit_fig_preferences_sctunit_templates). 
!images/docu_preferences_094_sctunit_templates_01.png(Preferences: SCTUnit templates)!

p=. Preferences: SCTUnit templates

Templates are sections of textual code that occur frequently enough to make you want to insert them with a few keystrokes only. This function is known as _content assist_; the sections of code that are inserted are known as _templates_.

To insert an existing content assist template, type the initial character, then press @[Ctrl+Space]@. The templates whose names begin with that character will appear. Double-click on a template to insert it.

On this preference page you can create, edit, and delete SCTUnit language templates.



h3(#edit_simulation). Simulation

p(#edit_fig_preferences_simulation). 
!images/docu_preferences_100_simulation_01.png(Preferences: Simulation)!

p=. Preferences: Simulation

Set your color preferences for the statechart simulator on this preference page.
