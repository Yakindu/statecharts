
h1(#embedded_systems_integration_guide). Embedded Systems Integration Guide

State Machine code generated by YAKINDU Statechart Tools can effectively be used on Embedded Systems. The integration contains different parts, but can mostly be described in a generic way, as most steps of the integration are platform independent.
The differences of the integration mostly stemp from the execution - CycleBased or EventDriven - of the state machine or the used functionalities, such as in, out and timed events. Other best practice implementation patterns can be based on whether a bare metal microcontroller or an operating system is used.

Factors affecting the integration:
* In the statechart
** Execution scheme of the state machine
*** Cycle based
*** Event driven
** Used event types
*** In events
*** Out events
*** Time events
* In the environment
** Bare-metal or RTOS
** Usage of interrupts
** Usage of sleep modes

This guide will give an overview of the most common and well known design patterns in a generic way and provides examples for an Arduino, a MSP430 and a STM32.

h2(#Bare-Metal-vs-Operation-System). Bare-Metal vs. RTOS

?
Bare metal -> schneller, effizienter, aber nicht skalierbar
OS -> Skalierbar, mehr Funktionalit√§t, aber langsamer

h2(#Bare-metal-cycle-based-integration). Bare-Metal CycleBased Integration

This section describes how to integrate a state machine with a cycle based execution semantic on any microcontroller, so on any embedded device. The integration can be structured in three parts, which results the main part of your program.
* Initialization - called once
* While loop - calling the state machine until it's final
* Final - called if the state machine is final
The execution of the program can be visualized as a state machine:

!(large)images/images_embedded_systems_integration_guide/platform_integration_simple.png(High level description of bare metal cycle based state machine integration)!

p=. High level description of bare metal cycle based state machine integration


 According to the used State Machine, there are different parts, which must be take into account:
* In Events 
* Timed Events
* Out Events

The main function could be realized as following. The hardware will be initialized. Then the timers will take into account. After this the state machine will be initialized and entered. With these steps, the initialization is has been done. 
At this point the state machine will be called as long as the state machine is not final. Note: If there is no final state defined the behavior is equals a while(true) loop. At first all in events will be raised. After this the timer will be updated, which internally raises time events, which are actually also in events. Then the runCycle will be called, which handles the logical execution of the state machine. After proceeding, the out events will be handled. The last step, if wanted, is setting the microcontroller into a sleep mode.

bc.. 
void main() {
	// Initialization
	
	hardwareInit();
	
	if(hasTimeEvents) {
		timerInit();
	}
	
	statemachine_init();
	statemachine_enter();

	// While loop
	while(!statemachine_isFinal()) {
		if(hasInEvents) {
			handleInEvents();
		}
		
		if(hasTimeEvents) {
			handleTimer();
		}

		statemachine_runCycle();
		
		if(hasOutEvents) {
			handleOutEvents();
		}
		
		if(usingSleepMode) {
			goToSleep()
			// wait for Interrupt
		}
	}
}
p. 

For now on, there are two different ways of how the events should be interact on the embedded system. One design pattern is polling. The other one is the usage of interrupts.

bc.. 
void handleInEvents() {
	if(inEvent1) {
		statemachine_raise_inEvent1();
		inEvent1 = false;
	}
	if(inEvent2) {
		statemachine_raise_inEvent2(inEvent2Value);
		inEvent2 = false;
	}
}

Sensor1_ISR{
	inEvent1 = true;
}

Sensor2_ISR{
	inEvent2 = true;
	inEvent2Value = readSensor2();
}
p. 
handle timer

bc.. 
void handleTimer() {
		if(updateTimerFlag) {
			updateTimer(TIMER_TICK_MS);
			updateTimerFlag = false;
		}
}

#define TIMER_TICK_MS 32 // 32 ms for example
Timer_ISR{ 
	updateTimerFlag = true;
}
p. 

handle out events

bc.. 
void handleOutEvents() {
	if(statemachine_israised_outEvent1()) {
		controlActuator1();
	}
	if(statemachine_israised_outEvent2()) {
		controlActuator2(statemachine_get_outEvent2_value());
	}
}
p. 


