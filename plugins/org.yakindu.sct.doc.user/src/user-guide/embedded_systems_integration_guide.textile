
h1(#embedded_systems_integration_guide). Embedded Systems Integration Guide

This chapter demonstrates how to integrate generated C code from YAKINDU Statechart Tools on your device and ends up by referring to according examples for each scenario. State machine code generated by YAKINDU Statechart Tools can effectively be used on embedded systems. The integration contains different parts, but can mostly be described in a generic way, as most steps of the integration are platform independent.
The differences of the integration mostly stem from the selected execution semantics - cycle based or event driven - as well as the used functionalities, such as in, out and timed events. Other best practice implementation patterns can be based on whether a bare metal microcontroller or an operating system is used. So, there are different factors which may have an impact on the integration:

In the statechart:
* State Machine execution
** CycleBased
** EventDriven
* Used event types
** In events
** Time events
** Out events
In the environment:
* Bare-metal or RTOS
* Usage of interrupts or polling
* Usage of sleep modes

This guide will give an overview of the most common and well known design patterns in a generic way and initially provides examples for an Arduino and only starts with the bare-metal integration. It will be continuously expanded.

h2(#polling-vs-interrupts). Polling vs.Interrupts

Programming bare-metal microcontrollers without any kind of RTOS or scheduler mainly leads to the architectural decision: Polling or Interrupts.
This section will give a short overview of how both design patterns work.

h3(#polling). Polling

Polling is a simple approach to get a first prototype running. Most programs look like this:

bc.. 
void main() {
	init();
	while(true){
		readInputs();
		doStuff();
		updateOutputs();
		delay_ms(100);
	}
}

p. 
The program starts with an initialization. After this, everything will be handled in a while loop, where the inputs will be polled cyclically - in this case every 100 milliseconds plus the execution time the program. Waiting for x milliseconds does not need to be realized in a blocking delay function, it also can be done by using sleep modes and a timer interrupt. But the main idea of polling is cyclic reacting on events.
For applications where events/inputs only rarely occur, this is not a good design choice, as the sensors are read frequently. This will lead to higher power consumption.

h3(#interrupts). Interrupts

Using interrupts is the second approach, where the system reacts on interrupts, which can occur asynchronously. Thus, the system does not need to cyclically poll the inputs. The normal execution of the program will be interrupted and it jumps to the Interrupt Service Routine (ISR), which then will be executed. Typically, the execution of the ISR should be as fast as possible, as other interrupts could occur while executing the ISR. Therefore, bool flags are commonly used, which serve as memory. A simple implementation look like this:

bc.. 
int main() {
	while(true) {
		if(bool_flag1 == true) {
			doStuff();
			bool_flag1 = false;
		}
		if(bool_flag2 == true) {
			doDiffferentStuff();
			bool_flag2 = false;
		}
		// sleep_mode();
	}
}

ISR_1 {
	bool_flag1 = true;
}

ISR_2 {
	bool_flag2 = true;
}

p. 
Each ISR uses one specific boolean flag, which stores wherever an interrupt has occurred. This pattern is often combined with a sleep mode, so that the microcontroller's CPU is only active after an interrupt. This pattern is often used for low power applications, which are powered by batteries.

h2(#Example-State-Machine-for-Integration). Example State Machine for Integration

The complexity of the state machine can raise in a development process. Thus, it's recommended to specify of how the API (Applicable Programming Interface) should be accessed. While the API depends on the execution and used event types, this guide tries to break down the main elements and define a expandable design pattern. Therefore, the following example will be used for all integration guides.
!(large)images/images_embedded_systems_integration_guide/platform_integration_example.jpeg(Example State Machine)!

p=. Example State Machine

The state machine contains three types of events: two __in events__ (inEvent1, inEvent2), two __out events__ (outEvent1, outEvent2) and one __timed event__ (after 2 s). Two states are connected with the inEvent1 and the after 2 s event. Each state raises one of __out event__. Additionally, a final state has been added, which also is part of the API. It only can be reached by raising the __in event__ inEvent2, if the state machine's __state__ StateA is active.

These are the main parts of the state machine, which can be used and must be handled:
* raise in events
* raise timed events
* handle out events
* check if the state machine is final

h2(#Bare-metal-cycle-based-integration). Bare-Metal Integration

This section describes how to integrate a state machine with a cycle based or event driven execution semantic on any microcontroller, so on any embedded device. The integration can be structured in three parts, which results the main part of your program.
* Initialization - called once
* While loop - calling the state machine until it's final
* Final - called if the state machine is final
The execution of the program can be visualized as a state machine:

!(large)images/images_embedded_systems_integration_guide/platform_integration_simple.png(High level description of bare metal cycle based state machine integration)!

p=. High level description of bare metal cycle based state machine integration


 According to the used State Machine, there are different parts, which must be take into account:
* In Events 
* Timed Events
* Out Events

h3(#main-function). Main Function

The main function could be realized as following: First, the hardware will be initialized. Then the timers will take into account. After this the state machine will be initialized and entered. 
At this point the state machine will be called as long as the state machine is not final. Note: If there is no final state defined the behavior is equals a while(true) loop. At first all in events will be raised. After this the timer will be updated, which internally raises time events. The behavior equals an in events. Then the runCycle will be called, which handles the logical execution of the state machine. This only needed, if the execution semantics is cycle based and must only be executed based on the elapsed time, e.g. 200 ms for a CycleBased(200) state machine. After proceeding, the out events will be handled. The last step, if wanted, is setting the microcontroller into a sleep mode.

bc.. 
void main() {
	// Initialization
	
	hardwareInit();
	
	if(hasTimeEvents) {
		timerInit();
	}
	
	statemachine_init();
	statemachine_enter();

	// While loop
	while(!statemachine_isFinal()) {
		if(hasInEvents) {
			handleInEvents();
		}
		
		if(hasTimeEvents) {
			handleTimer();
		}
		
		if(isCycleBased && elapsedTime >= cyclePeriod) {
			elapsedTime = 0;
			statemachine_runCycle();
		}
		
		if(hasOutEvents) {
			handleOutEvents();
		}
		
		if(usingSleepMode) {
			goToSleep()
			// wait for Interrupt
		}
	}
}
p. 

h3(#handle-in-events). Handle In Events 

For now on, there are two different ways of how the events should be interact on the embedded system. One design pattern is polling. The other one is the usage of interrupts.

A design using polling cyclic updates the status of the inputs and raise the according event.

bc.. 
void handleInEvents() {
	if(readGPIO(1)) {
		statemachine_raise_inEvent1();
	}
	if(readGPIO(2)) {
		statemachine_raise_inEvent2();
	}
}
p. 

As already described in the Interrupt section, a design using interrupts recommends bool flags as storage of the event.

bc.. 
void handleInEvents() {
	if(inEvent1) {
		statemachine_raise_inEvent1();
		inEvent1 = false;
	}
	if(inEvent2) {
		statemachine_raise_inEvent2(inEvent2Value);
		inEvent2 = false;
	}
}

Sensor1_ISR{
	inEvent1 = true;
}

Sensor2_ISR{
	inEvent2 = true;
	inEvent2Value = readSensor2();
}
p. 

h3(#handle-timer). Handle Timer

Handling the timer is more comprehensive. Each time event of the state machine must be updated and handled, because in detail there are nothing else than a in event. This means that for every timed trigger there must be one in event. Therefore, a timer service is provided in the examples. This timer service must be updated with the elapsed time since the its last call, which leads to the next implementation point: Determining the time.
On a pure bare-metal implementation there is no such thing as elapsed time. Everything depends on cycles. 

Imagine a microcontroller running with a clock of 16MHz. Running one instruction needs 1/16MHz = 625ns. A delay() function 1000000 would need 6,25 ms.A first approach updating the timer could be:

bc.. 
void main() {
	while(true) {
		delay(1000000);
		updateTimer(6,25);
		runCycle();
	}
}
p. 

But using this implementations got two big drawbacks:
* the delay function is blocking
* the execution time of the updateTimer and runCycle are not taking into account

A much more precise design is using timer interrupts, which can generate a periodic interrupt ever x cycles:

bc.. 
void handleTimer() {
	if(updateTimerFlag) {
		updateTimer(TIMER_TICK_MS);
		updateTimerFlag = false;
	}
}

#define TIMER_TICK_MS 32 // 32 ms for example
Timer_ISR{ 
	updateTimerFlag = true;
}
p. 

Some microcontrollers, like the Arduino, support functions like millis(), which are in fact using a similar method, but storing the elapsed time since starting the device. This time can be used to determine the elapsed time between two cycles in a loop:

bc.. 
void loop() {
	current_millis = millis();
	updateTimer(current_millis - last_cycle_time);
	statemachine_runCycle();
	last_cycle_time = current_millis;
}

p. 

For prototyping, this implementation can be used, but it should be considered that the timer will overflow after approximately 50 days. That's why we highly recommend a implementation with interrupts as described before.

h3(#handle-out-events). Handle Out Events

Out events raised by the state machine can be checked by using the state machine's API. If an out event gets raised its returning value is true, until the next runCycle is executed. This is why the out events should be handled <b>after</b> every runCycle call. They can be used to wire up different actuators. Mapping values, e.g. integers, to the out events, is also possible.

bc.. 
void handleOutEvents() {
	if(statemachine_israised_outEvent1()) {
		controlActuator1();
	}
	if(statemachine_israised_outEvent2()) {
		controlActuator2(statemachine_get_outEvent2_value());
	}
}
p. 

h3(#execution-as-state-machine). Execution As State Machine

This is a expanded view on the implementation, of how it can be realized as a state machine.
(needs to be updated)!

!(large)images/images_embedded_systems_integration_guide/platform_integration.png(Complete execution shown as State Machine)!

p=. Complete execution shown as State Machine

h3(#arduino-bare-metal). Arduino Bare-Metal Integration

There are two examples for a bare-metal integration using interrupts and polling for Arduino and can be used fo r both execution semantics: CycleBased and EventDriven. They have been tested with an Arduino Uno (ATmega328p) and an Arduino Mega (ATmega2560):

Add them to YAKINDU Statechart Tool with the example wizard: 
__File__ -> __New__ -> __Example...__ -> __YAKINDU Statechart Examples__ -> __Embedded Systems Integration Guide__ -> __Arduino - ...__






