
h1(#embedded_systems_integration_guide). Embedded Systems Integration Guide

State Machine code generated by YAKINDU Statechart Tools can effectively be used on Embedded Systems. The integration contains different parts, but can mostly be described in a generic way, as most steps of the integration are platform independent.
The differences of the integration mostly stemp from the execution - CycleBased or EventDriven - of the state machine or the used functionalities, such as in, out and timed events. Other best practice implementation patterns can be based on whether a bare metal microcontroller or an operating system is used.

Factors affecting the integration:
* In the statechart
** Execution scheme of the state machine
*** Cycle based
*** Event driven
** Used event types
*** In events
*** Out events
*** Time events
* In the environment
** Bare-metal or RTOS
** Usage of interrupts
** Usage of sleep modes

This guide will give an overview of the most common and well known design patterns in a generic way and provides examples for an Arduino, a MSP430 and a STM32.

h2(#Bare-Metal-vs-Operation-System). Bare-Metal vs. RTOS

?
Bare metal -> schneller, effizienter, aber nicht skalierbar
OS -> Skalierbar, mehr Funktionalit√§t, aber langsamer

h2(#Bare-metal-cycle-based-integration). Bare-Metal CycleBased Integration

This section describes how to integrate a state machine with a cycle based execution semantic on any microcontroller, so on any embedded device. The integration can be structured in three parts, which results the main part of your program.
* Initialization - called once
* While loop - calling the state machine until it's final
* Final - called if the state machine is final
The execution of the program can be visualized as a state machine:

!(large)images/images_embedded_systems_integration_guide/platform_integration_simple.png(High level description of bare metal cycle based state machine integration)!

p=. High level description of bare metal cycle based state machine integration


 According to the used State Machine, there are different parts, which must be take into account:
* In Events 
* Timed Events
* Out Events


h3(#main-function). Main Function

The main function could be realized as following. The hardware will be initialized. Then the timers will take into account. After this the state machine will be initialized and entered. With these steps, the initialization is has been done. 
At this point the state machine will be called as long as the state machine is not final. Note: If there is no final state defined the behavior is equals a while(true) loop. At first all in events will be raised. After this the timer will be updated, which internally raises time events, which are actually also in events. Then the runCycle will be called, which handles the logical execution of the state machine. After proceeding, the out events will be handled. The last step, if wanted, is setting the microcontroller into a sleep mode.

bc.. 
void main() {
	// Initialization
	
	hardwareInit();
	
	if(hasTimeEvents) {
		timerInit();
	}
	
	statemachine_init();
	statemachine_enter();

	// While loop
	while(!statemachine_isFinal()) {
		if(hasInEvents) {
			handleInEvents();
		}
		
		if(hasTimeEvents) {
			handleTimer();
		}

		statemachine_runCycle();
		
		if(hasOutEvents) {
			handleOutEvents();
		}
		
		if(usingSleepMode) {
			goToSleep()
			// wait for Interrupt
		}
	}
}
p. 

h3(#handle-in-events). Handle In Events 

For now on, there are two different ways of how the events should be interact on the embedded system. One design pattern is polling. The other one is the usage of interrupts.

bc.. 
void handleInEvents() {
	if(inEvent1) {
		statemachine_raise_inEvent1();
		inEvent1 = false;
	}
	if(inEvent2) {
		statemachine_raise_inEvent2(inEvent2Value);
		inEvent2 = false;
	}
}

Sensor1_ISR{
	inEvent1 = true;
}

Sensor2_ISR{
	inEvent2 = true;
	inEvent2Value = readSensor2();
}
p. 

h3(#handle-timer). Handle Timer

Handling the timer is more comprehensive. As in the state diagram can be used multiple time events, they all must be handled correctly. A good approach is a seperated timer library, which handles timed events. This will be explained in detail later on. At this point, they are straight forward as in events, except that a eplased time of the timer must be updated.
In this example it is assumed, that an timer interrupt occurs periodically every 32 seconds, which is used at as the elapsed time for the timer.

bc.. 
void handleTimer() {
		if(updateTimerFlag) {
			updateTimer(TIMER_TICK_MS);
			updateTimerFlag = false;
		}
}

#define TIMER_TICK_MS 32 // 32 ms for example
Timer_ISR{ 
	updateTimerFlag = true;
}
p. 

h3(#handle-out-events). Handle Out Events

Out events, that are raised by the state machine, can be checked. If an out event gets raised, it's returning value is true, as long as the next runCycle is be executed. This is why the out events should be handled <b>after</b> every runCycle call. They can be used to wire up different actuators. Mapping values, e.g. integers, to the out events, is also possible.

bc.. 
void handleOutEvents() {
	if(statemachine_israised_outEvent1()) {
		controlActuator1();
	}
	if(statemachine_israised_outEvent2()) {
		controlActuator2(statemachine_get_outEvent2_value());
	}
}
p. 

h3(#execution-as-state-machien). Execution As State Machine

!(large)images/images_embedded_systems_integration_guide/platform_integration.png(Complete execution shown as State Machine)!

p=. Complete execution shown as State Machine