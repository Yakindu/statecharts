<?xml version="1.0" encoding="UTF-8"?>
<!-- 
<!DOCTYPE article [
<!ENTITY nbsp "&#x00a0;">
<!ENTITY ysct "YAKINDU Statechart Tools">
]>
-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
 <info>
  <title>YAKINDU Statechart Tools Documentation</title>
  <date>
<?dbtimestamp format="Y-m-d H:M:S"?>
  </date>
 </info>

 <sect1 xml:id="yakindu-statechart-tools-installation-guide">
  <title>YAKINDU Statechart Tools Installation Guide</title>

  <para>This document was generated <?dbtimestamp format="Y-m-d H:M:S"?>.</para>

  <para>In order to start working with <application>YAKINDU Statechart Tools</application>, you have to install
   the software on your computer. We are assuming you have downloaded the software package and stored it somewhere
   on your machine.</para>

  <sect2 xml:id="dependencies">
   <title>Dependencies</title>

   <sect3 xml:id="eclipse">
    <title>Eclipse</title><indexterm><primary>Eclipse</primary></indexterm>

    <para><application>YAKINDU Statechart Tools</application> is based on the <application>Eclipse</application>
     integrated development environment (IDE) and runs inside <application>Eclipse</application>. The installation
     process as described below will put a full-fledged <application>Eclipse</application> instance on your computer.
     It is comprised in the <application>YAKINDU Statechart Tools</application> distribution file you downloaded.
     You will have to unpack and execute <application>Eclipse</application> in order to work with 
     <application>YAKINDU Statechart Tools</application> inside of it.</para>
   </sect3>

   <sect3 xml:id="java">
    <title>Java</title><indexterm><primary>Java</primary></indexterm>

    <para>While <application>YAKINDU Statechart Tools</application> is based on
     <application>Eclipse</application>, the latter in turn is based on Java. In order to use
     <application>Eclipse</application>, you also need a more or less recent Java version on your machine. Depending
     on what you are going to do with <application>YAKINDU Statechart Tools</application>, you either need a Java
     Runtime Environment (JRE) or a Java Development Kit (JDK). Since a JDK always contains a JRE, it is a safe
     bet to install the former. However, unless you are going to do some Java development – i. e. create a
     state machine, turn it into Java source code, and use the latter from your Java client code –, you might get
     away with a JRE. Installation of Java is beyond the scope of this document. You can find more information and
     download the software from <link xl:href="https://www.java.com/">https://www.java.com/</link>.</para>
    <para>In case you don't have Java on your machine yet and you are going to download and install it, make sure
     you are picking the variant with the correct bit size, i. e. either 32 or 64 bit, whichever is appropriate for
     your computer.</para>
   </sect3>
  </sect2>

  <sect2 xml:id="platform-overview">
   <title>Platform overview</title>

   <para>You can either install <application>YAKINDU Statechart Tools</application> as a stand-alone software package 
    under the following operating systems.</para>

   <itemizedlist>
    <listitem>
     <para><link linkend="installing-on-windows">Installing <application>YAKINDU Statechart Tools</application> on 
      Windows</link></para>
    </listitem>
    <listitem>
     <para><link linkend="installing-on-macosx">Installing <application>YAKINDU Statechart Tools</application> on Mac 
      OS X</link></para>
    </listitem>
    <listitem>
     <para><link linkend="installing-on-linux">Installing <application>YAKINDU Statechart Tools</application> on 
      Linux</link></para>
    </listitem>
   </itemizedlist>

   <para>Alternatively you can install <application>YAKINDU Statechart Tools</application> to an existing 
    <application>Eclipse</application> instance.</para>

   <itemizedlist>
    <listitem>
     <para><link linkend="installing-to-an-existing-eclipse-instance">Installing <application>YAKINDU Statechart 
      Tools</application> to an existing <application>Eclipse</application> instance</link></para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="installing-on-windows">
   <title>Installing on Windows</title>
   <indexterm><primary>Windows</primary><secondary>installing YAKINDU Statechart Tools</secondary></indexterm>
   <indexterm><primary>installation</primary><secondary>installation on Windows</secondary></indexterm>
   <para>This chapter describes how to install <application>YAKINDU Statechart Tools</application> on a Windows 7 machine.</para>

   <sect3 xml:id="unpacking-the-downloaded-file">
    <title>Unpacking the downloaded file</title>

    <para>Unpack the software distribution file. Use the file explorer to open the directory you downloaded the software
     distribution file to, right-click on the latter, and select <emphasis>Extract All…</emphasis> in the context menu.</para>

    <figure>
     <title>Unpacking the downloaded file on Windows [1]</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_010_eclipse_extract_1.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Unpacking the downloaded file on Windows [1]</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Choose a directory for <application>YAKINDU Statechart Tools</application> (YAKINDU SCT). The example below 
     assumes you want to install the software in the <emphasis>C:\Program Files\YAKINDU</emphasis> directory.</para>

    <para>Depending on your permissions, you might not be able to create a directory and install software under 
     <emphasis>C:\Program Files</emphasis>. In this case, please choose another installation directory at a location 
     you are allowed to write to.</para>

    <figure>
     <title>Unpacking the downloaded file on Windows [2]</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_020_eclipse_extract_2.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Unpacking the downloaded file on Windows [2]</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Click on <emphasis>Extract</emphasis> to start the extraction process. With Window's built-in unpacker, this 
     will take surprisingly much time. Alternatively, you can use a 3rd-party unpacker like 
     <link xl:href="http://www.7-zip.org/">7-Zip</link>. Saves you a lot of time!</para>

    <para>After unpacking, you will find a folder <emphasis>yakindu-sct</emphasis> in your installation directory, 
     i. e. <emphasis>C:\Program Files\YAKINDU\yakindu-sct</emphasis> in our example, as shown in the image below:</para>

    <figure>
     <title>The extracted "yakindu-sct" folder</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_030_eclipse_folder.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The extracted "yakindu-sct" folder</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The contents of the <emphasis>yakindu-sct</emphasis> folder looks like this:</para>

    <figure>
     <title>Contents of the extracted &quot;yakindu-sct&quot; folder</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_040_eclipse_contents.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Contents of the extracted &quot;yakindu-sct&quot; folder</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>There you are: You have installed <application>YAKINDU Statechart Tools</application>. Now you should start 
     it.</para>

   </sect3>


   <sect3 xml:id="starting-yakindu-statechart-tools">
    <title>Starting YAKINDU Statechart Tools</title>

    <para>Start <application>YAKINDU Statechart Tools</application> by running the <emphasis>SCT.exe</emphasis> executable.</para>

    <para>To do so, please double-click (or single-click, depending on your Windows settings) on the <emphasis>YAKINDU</emphasis> symbol shown in the sample screenshot above.</para>

    <para>Depending on the Windows settings and your permissions, you might get the following security warning, indicating that you downloaded the application from a potentially unsecure source:</para>

    <figure>
     <title>Windows security warning</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_045_security_warning.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Windows security warning</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Uncheck the <emphasis>Always ask before opening this file</emphasis> option. Click <emphasis>Run</emphasis> to continue starting the application. Subsequently starting <application>YAKINDU Statechart Tools</application> will not show this security warning again.</para>

    <para>While <application>YAKINDU Statechart Tools</application> is starting up, it is showing a splash screen:</para>

    <figure>
     <title><application>YAKINDU Statechart Tools</application> starting up and showing a splash screen</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_050_eclipse_splash.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>
        <application>YAKINDU Statechart Tools</application> starting up and showing a splash screen</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The software needs a <emphasis>workspace</emphasis> directory where it stores its so-called projects along with other data. During the first startup, the <emphasis>Workspace Launcher</emphasis> dialog asks you to specify the workspace directory in the <emphasis>Workspace</emphasis> field. Please select a new and empty one.</para>

    <para>In the example below, we chose the <emphasis>C:\Users\joedoe\workspace</emphasis> directory as our workspace. We also checked the <emphasis>"Use this as the default and do not ask again”</emphasis> option. This is sensible, because on subsequent startups, <application>YAKINDU Statechart Tools</application> won't ask for a workspace directory again. Instead it will always use the one we chose once and forever. (You can still change the workspace later via <emphasis>File → Switch Workspace</emphasis> in the main menu.)</para>

    <figure>
     <title>Selecting a workspace</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_060_eclipse_workspace_dialog.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Selecting a workspace</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Click on the <emphasis>OK</emphasis> button to proceed.</para>

    <para>On the first start, <application>YAKINDU Statechart Tools</application> presents a <emphasis>Welcome</emphasis> window:</para>

    <figure>
     <title><application>YAKINDU Statechart Tools</application> presenting the &quot;Welcome&quot; window</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_070_eclipse_welcome.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>
        <application>YAKINDU Statechart Tools</application> presenting the &quot;Welcome&quot; window</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>You can browse the material shown here, if you want. When you are done, please close the <emphasis>Welcome</emphasis> tab or click on <emphasis>Workbench</emphasis> at the upper right. Both actions are leading to the workbench:</para>

    <figure>
     <title>The <application>YAKINDU Statechart Tools</application> workbench</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/windows7_install_080_eclipse_workbench.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The <application>YAKINDU Statechart Tools</application> workbench</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>This is your working environment now. Congratulations, you have just installed <application>YAKINDU Statechart Tools</application> with <application>Eclipse</application>!</para>

    <para>You can <link xl:href="#five-minutes-tutorial">proceed</link> now to create your first YAKINDU Statecharts 
     Tools project.</para>
   </sect3>
  </sect2>


  <sect2 xml:id="installing-on-macosx">
   <title>Installing on Mac OS X</title>
   <indexterm><primary>Mac OS X</primary><secondary>installing YAKINDU Statechart Tools</secondary></indexterm>
   <indexterm><primary>installation</primary><secondary>installation on Mac OS X</secondary></indexterm>

   <para>This chapter describes how to install <application>YAKINDU Statechart Tools</application> on a Mac computer under Mac OS X.</para>

   <sect3 xml:id="unpacking-the-downloaded-file-1">
    <title>Unpacking the downloaded file</title>

    <para>When downloading the ZIP file containing the software distribution in a browser to your local disk, the <emphasis>Archive Utility</emphasis> automatically unpacks it by default. Upon success, the ZIP file is removed. Alternatively you can unpack the ZIP file manually by double-clicking it.</para>

    <para>Unpacking will provide you with the <emphasis>YAKINDU SCT</emphasis> application bundle.</para>

    <para>Move the unpacked application bundle to your <emphasis>Applications</emphasis> folder. Alternatively, you can also move it somewhere else as you see fit. The screenshot below shows the <emphasis>YAKINDU SCT</emphasis> application bundle having been moved to <emphasis>Applications</emphasis>.</para>

    <figure>
     <title>The YAKINDU Statecharts Tools application in the &quot;Applications&quot; directory</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/macosx_install_010_applications.png" align="center" contentwidth="40%"/>
      </imageobject>
      <textobject>
       <phrase>The YAKINDU Statecharts Tools application in the <filename>Applications</filename> directory</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>There you are: You have installed <application>YAKINDU Statechart Tools</application>. Now you should start it.</para>
   </sect3>


   <sect3 xml:id="starting-yakindu-statechart-tools-1">
    <title>Starting YAKINDU Statechart Tools</title>

    <para>Start <application>YAKINDU Statechart Tools</application> by running the <emphasis>YAKINDU SCT</emphasis> application.</para>

    <para>To do so, please double-click on the <emphasis>YAKINDU</emphasis> symbol shown in the sample screenshot above.</para>

    <para>Upon the first start, Mac OS X will verify the application and show you the following security warning, indicating that you did not download the application from Apple's App Store, but from a potentially unsecure source instead:</para>

    <figure>
     <title>Mac OS X warning</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/macosx_install_020_security_warning.png" align="center" contentwidth="40%"/>
      </imageobject>
      <textobject>
       <phrase>Mac OS X warning</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Click <emphasis>Open</emphasis> to continue starting the application. Subsequently starting <application>YAKINDU Statechart Tools</application> will not show that security warning again.</para>

    <para>While <application>YAKINDU Statechart Tools</application> is starting up, it is showing a splash screen:</para>

    <figure>
     <title>YAKINDU Statechart Tools starting up and showing a splash screen</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/macosx_install_050_eclipse_splash.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>
        <application>YAKINDU Statechart Tools</application> starting up and showing a splash screen</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The software needs a <emphasis>workspace</emphasis> directory where it stores its so-called projects along with other data. During the first startup, the <emphasis>Workspace Launcher</emphasis> dialog asks you to specify the workspace directory in the <emphasis>Workspace</emphasis> field. Please select a new and empty one.</para>

    <para>In the example below, we chose the <emphasis>/Users/joedoe/workspace</emphasis> directory as our workspace. We also checked the <emphasis>"Use this as the default and do not ask again”</emphasis> option. This is sensible, because on subsequent startups, <application>YAKINDU Statechart Tools</application> won't ask for a workspace directory again. Instead it will always use the one we chose once and forever. (You can still change the workspace later via <emphasis>File → Switch Workspace</emphasis> in the main menu.)</para>

    <figure>
     <title>Selecting a workspace</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/macosx_install_060_eclipse_workspace_dialog.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Selecting a workspace</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Click on the <emphasis>OK</emphasis> button to proceed.</para>

    <para>On the first start, <application>YAKINDU Statechart Tools</application> presents a <emphasis>Welcome</emphasis> window:</para>

    <figure>
     <title>YAKINDU Statechart Tools presenting the &quot;Welcome&quot; window</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/macosx_install_070_eclipse_welcome.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>
        <application>YAKINDU Statechart Tools</application> presenting the &quot;Welcome&quot; window</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>You can browse the material shown here, if you want. When you are done, please close the <emphasis>Welcome</emphasis> tab or click on <emphasis>Workbench</emphasis> at the upper right. Both actions are leading to the workbench:</para>

    <figure>
     <title>The YAKINDU Statechart Tools workbench</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/macosx_install_080_eclipse_workbench.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The <application>YAKINDU Statechart Tools</application> workbench</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>This is your working environment now. Congratulations, you have just installed <application>YAKINDU Statechart Tools</application> with <application>Eclipse</application>!</para>

    <para>You can <link xl:href="#five-minutes-tutorial">proceed</link> now to create your first YAKINDU Statecharts 
     Tools project.</para>
   </sect3>
  </sect2>


  <sect2 xml:id="installing-on-linux">
   <title>Installing on Linux</title>
   <indexterm><primary>Linux</primary><secondary>installing YAKINDU Statechart Tools</secondary></indexterm>
   <indexterm><primary>installation</primary><secondary>installation on Linux</secondary></indexterm>

   <para>This chapter describes how to install <application>YAKINDU Statechart Tools</application> on a Linux machine 
    using a command-line tool. The installation doesn't require <emphasis>root</emphasis> permissions.</para>

   <sect3 xml:id="unpacking-the-downloaded-file-2">
    <title>Unpacking the downloaded file</title>

    <para>Choose a directory for <application>YAKINDU Statechart Tools</application>. The commands below assume you want to install the software in the <emphasis>/my/software</emphasis> directory. Please modify the commands appropriately to install somewhere else!</para>

    <para>Go to the installation directory:</para>

    <programlisting>cd /my/software/</programlisting>

    <para>Unpack the software distribution file. If the downloaded file is located in <emphasis>/download/sct-linux.gtk.x86_64.zip</emphasis>, use the following command to unpack in the installation directory:</para>

    <programlisting>unzip /download/sct-linux.gtk.x86_64.zip</programlisting>

    <para>This will create a folder <emphasis>yakindu-sct</emphasis> in your installation directory, i. e.
     <emphasis>/my/software/yakindu-sct</emphasis> in our example, as shown in the image below:</para>

    <figure>
     <title>The extracted &quot;yakindu-sct&quot; folder</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/linux_install_010_eclipse_folder.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The extracted &quot;yakindu-sct&quot; folder</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The contents of the <emphasis>yakindu-sct</emphasis> folder looks like this:</para>

    <figure>
     <title>Contents of the extracted &quot;yakindu-sct&quot; folder</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/linux_install_020_eclipse_contents.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Contents of the extracted &quot;yakindu-sct&quot; folder</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>There you are: You have installed <application>YAKINDU Statechart Tools</application>. Now you should start it.</para>
   </sect3>


   <sect3 xml:id="starting-yakindu-statechart-tools-2">
    <title>Starting YAKINDU Statechart Tools</title>

    <para>Start <application>YAKINDU Statechart Tools</application> by running the <emphasis>SCT</emphasis> executable.</para>

    <para>To do so, please enter the command</para>

    <programlisting>
yakindu-sct/SCT
</programlisting>

    <para>in your installation directory. Or issue the command</para>

    <programlisting>/my/software/yakindu-sct/SCT</programlisting>

    <para>if your command shell is in any other working directory.</para>

    <para>From a file browser, you can start <application>YAKINDU Statechart Tools</application> by clicking on the <emphasis>SCT</emphasis> symbol, shown as a gear-wheel in the sample screenshot above.</para>

    <para>While <application>YAKINDU Statechart Tools</application> is starting up, it is showing a splash screen:</para>

    <figure>
     <title>YAKINDU Statechart Tools starting up and showing a splash screen</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/linux_install_030_eclipse_splash.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>
        <application>YAKINDU Statechart Tools</application> starting up and showing a splash screen</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The software needs a <emphasis>workspace</emphasis> directory where it stores its so-called projects along with other data. During the first startup, the <emphasis>Workspace Launcher</emphasis> dialog asks you to specify the workspace directory in the <emphasis>Workspace</emphasis> field. Please select a new and empty one.</para>

    <para>In the example below, we chose the <emphasis>/my/workspace</emphasis> directory as our workspace. We also checked the <emphasis>"Use this as the default and do not ask again”</emphasis> option. This is sensible, because on subsequent startups, <application>YAKINDU Statechart Tools</application> won't ask for a workspace directory again. Instead it will always use the one we chose once and forever. (You can still change the workspace later via <emphasis>File → Switch Workspace</emphasis> in the main menu.)</para>

    <figure>
     <title>Selecting a workspace</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/linux_install_040_eclipse_workspace_dialog.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Selecting a workspace</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Click on the <emphasis>OK</emphasis> button to proceed.</para>

    <para>On the first start, <application>YAKINDU Statechart Tools</application> presents a <emphasis>Welcome</emphasis> window:</para>

    <figure>
     <title>YAKINDU Statechart Tools presenting the &quot;Welcome&quot; window</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/linux_install_050_eclipse_welcome.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>
        <application>YAKINDU Statechart Tools</application> presenting the &quot;Welcome&quot; window</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>You can browse the material shown here, if you want. When you are done, please close the <emphasis>Welcome</emphasis> tab or click on <emphasis>Workbench</emphasis> at the upper right. Both actions are leading to the workbench:</para>

    <figure>
     <title>The YAKINDU Statechart Tools workbench</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/linux_install_060_eclipse_workbench.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The <application>YAKINDU Statechart Tools</application> workbench</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>This is your working environment now. Congratulations, you have just started <application>YAKINDU Statechart Tools</application>!</para>

    <para>You can <link xl:href="#five-minutes-tutorial">proceed</link> now to create your first YAKINDU Statecharts 
     Tools project.</para>
   </sect3>
  </sect2>


  <sect2 xml:id="installing-to-an-existing-eclipse-instance">
   <title>Installing to an existing Eclipse instance</title>
   <indexterm><primary>Eclipse</primary><secondary>installing YAKINDU Statechart Tools</secondary></indexterm>
   <indexterm><primary>installation</primary><secondary>installation to an existing Eclipse instance</secondary></indexterm>

   <para>This chapter describes the steps that are needed to install <application>YAKINDU Statechart Tools</application> to an existing <application>Eclipse</application> instance. Let's assume you already have <application>Eclipse</application> up and running and now you want to install <application>YAKINDU Statechart Tools</application> as an additional software item (plugin).</para>

   <para>In the the <emphasis>Help</emphasis> menu, select the <emphasis>Install New Software</emphasis> menu item:</para>

   <figure>
    <title>Selecting &quot;Help → Install New Software&quot; in the main menu</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_010_eclipse_menu_install_new_software.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Selecting &quot;Help → Install New Software&quot; in the main menu</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>The <emphasis>Install</emphasis> wizard opens:</para>

   <figure>
    <title>The &quot;Install&quot; wizard</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_020_eclipse_install_wizard.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>The &quot;Install&quot; wizard</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>Click on the <emphasis>Add…</emphasis> button near the upper right corner of the wizard.</para>

   <para>A dialog opens, asking you to specify the update repository<indexterm><primary>update 
    repository</primary></indexterm> you want to install the new software from. The appropriate update repository 
    depends on your <application>Eclipse</application> version. Please enter the respective update repository into the 
    <emphasis>Location</emphasis> field.</para>

   <table border="1">
    <caption>YAKINDU Statechart Tools update repositories</caption>
    <tbody>
     <tr valign="top">
      <th colspan="2">
       <para><application>Eclipse</application></para>
      </th>
      <th colspan="2">
       <para><application>YAKINDU Statechart Tools</application> Update Repository</para>
      </th>
     </tr>
     <tr valign="top">
      <th>
       <para>Name</para>
      </th>
      <th>
       <para>Version</para>
      </th>
      <th>
       <para>Release Build</para>
      </th>
      <th>
       <para>Milestone Build</para>
      </th>
     </tr>
     <tr valign="top">
      <td>
       <para>Neon</para>
      </td>
      <td>
       <para>4.6</para>
      </td>
      <td>
       <para><link xl:href="http://updates.yakindu.org/sct/neon/releases/">http://updates.yakindu.org/sct/neon/releases/</link></para>
      </td>
      <td>
       <para><link xl:href="http://updates.yakindu.org/sct/neon/milestones/">http://updates.yakindu.org/sct/neon/milestones/</link></para>
      </td>
     </tr>
     <tr valign="top">
      <td>
       <para>Mars</para>
      </td>
      <td>
       <para>4.5</para>
      </td>
      <td>
       <para><link xl:href="http://updates.yakindu.org/sct/mars/releases/">http://updates.yakindu.org/sct/mars/releases/</link></para>
      </td>
      <td>
       <para><link xl:href="http://updates.yakindu.org/sct/mars/milestones/">http://updates.yakindu.org/sct/mars/milestones/</link></para>
      </td>
     </tr>
     <tr valign="top">
      <td>
       <para>Luna</para>
      </td>
      <td>
       <para>4.4</para>
      </td>
      <td>
       <para><link xl:href="http://updates.yakindu.org/sct/luna/releases/">http://updates.yakindu.org/sct/luna/releases/</link></para>
      </td>
      <td>
       <para><link xl:href="http://updates.yakindu.org/sct/luna/milestones/">http://updates.yakindu.org/sct/luna/milestones/</link></para>
      </td>
     </tr>
    </tbody>
   </table>

   <para>Please note that <application>YAKINDU Statechart Tools</application> might take some time to catch up with more recent <application>Eclipse</application> releases. The corresponding update repositories will not be available until then.</para>

   <para>Instead of an officially stable <application>YAKINDU Statechart Tools</application>
    <emphasis>release</emphasis>, you can alternatively install a <emphasis>milestone</emphasis> build. Since milestone builds are newer than stable releases, they generally have more features available and more bugs fixed. However, they might also contain some new bugs that have gone unnoticed by now.</para>

   <para>Enter some text into the <emphasis>Name</emphasis> field. This text is abitrary in principle, but you should choose something that makes it easier for you to identify this particular update repository among other update repositories. In the example below, the repository's name is <literal>YAKINDU Statechart Tools (Luna)</literal>. It describes which piece of software the repository provides (<application>YAKINDU Statechart Tools</application>) and which <application>Eclipse</application> release that software is compatible with (Luna, i. e. <application>Eclipse</application> 4.4).</para>

   <figure>
    <title>Adding a software repository</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_030_eclipse_add_repository.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Adding a software repository</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>After entering name and location of the update repository, click <emphasis>OK</emphasis>.</para>

   <para><application>Eclipse</application> establishes a network connection to the update repository, asks it for available software items and shows them in the install wizard:</para>

   <figure>
    <title>Selecting YAKINDU Statechart Tools software items</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_040_eclipse_software_items.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Selecting <application>YAKINDU Statechart Tools</application> software items</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>Please check at least <emphasis>Xtext Integration Utilities</emphasis> and – no surprise – <emphasis>YAKINDU SCT</emphasis>. (You can also install the respective source code items. However, unless you want to have a look at that source code or even want to modify it, you don't need them.)</para>

   <para>Click <emphasis>Next &gt;</emphasis>.</para>

   <para><application>Eclipse</application> tries to integrate the new software with the software that is already installed. If it detects any mismatched between requirements and provisions, <application>Eclipse</application> will try to find a solution in order to mitigate this problem. The screenshot below shows such a case:</para>

   <figure>
    <title>Install remediation page</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_050_eclipse_trouble.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Install remediation page</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>Select the most appropriate solution, then click <emphasis>Next &gt;</emphasis>.</para>

   <para>The wizard shows the software to be installed and gives you the opportunity to review the changes:</para>

   <figure>
    <title>Reviewing the items to be installed</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_060_eclipse_review.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Reviewing the items to be installed</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>Click <emphasis>Next &gt;</emphasis>.</para>

   <para>The wizard asks you to review and accept the terms of the new software's license agreements.</para>

   <figure>
    <title>Accepting the new software's license agreements</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_070_eclipse_licenses.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Accepting the new software's license agreements</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>Select the radio button labelled <emphasis>I accept the terms of the license agreements</emphasis> (if you do), then click <emphasis>Finish</emphasis>.</para>

   <para><application>Eclipse</application> starts to download the software and installs it on your computer. This may take some time.</para>

   <figure>
    <title>Installing software in progress …</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_080_eclipse_installation.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Installing software in progress …</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>If the installation was completed successfully, Eclipse needs a restart in order to have the changes take
    effect. A dialog asks whether you want to restart Eclipse right now or later:</para>

   <figure>
    <title>Restarting Eclipse after software installation</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_090_eclipse_restart.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Restarting Eclipse after software installation</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>After the restart, Eclipse displays its <emphasis>Welcome</emphasis> window, now also featuring <application>YAKINDU Statechart Tools</application>:</para>

   <figure>
    <title>Eclipse presenting the &quot;Welcome&quot; window</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_install_100_eclipse_sct_help.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Eclipse presenting the &quot;Welcome&quot; window</phrase>
     </textobject>
    </mediaobject>
   </figure>
  </sect2>


  <sect2 xml:id="updating-yakindu-statechart-tools">
   <title>Updating YAKINDU Statechart Tools</title>
   <indexterm><primary>Eclipse</primary><secondary>updating YAKINDU Statechart Tools</secondary></indexterm>
   <indexterm><primary>update</primary></indexterm>

   <para>To check whether a new <application>YAKINDU Statechart Tools</application> release is available and to install 
    it, please select the <emphasis>Help → Check for Updates</emphasis> menu item.</para>

   <figure>
    <title>Selecting &quot;Help → Check for Updates&quot; in the main menu</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_update_010_eclipse_menu_check_for_updates.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Selecting &quot;Help → Check for Updates&quot; in the main menu</phrase>
     </textobject>
    </mediaobject>
   </figure>

   <para>If Eclipse finds any software items to be updated – not just <application>YAKINDU Statechart Tools</application> –, it will guide you through the process of updating them. Generally Eclipse has to be restarted afterwards to have any changes take effect.</para>

   <para>You can configure Eclipse as follows to automatically check for updates:</para>

   <para>Select the <emphasis>Window → Preferences</emphasis> menu item. The <emphasis>Preferences</emphasis> dialog opens.</para>

   <para>Go to the <emphasis>Install/Update → Automatic Updates</emphasis> section. Here you can configure whether and when Eclipse should check for updates and what to do when it finds any.</para>

   <figure>
    <title>Configuring automatic update</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/eclipse_update_020_eclipse_automatic_updates.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Configuring automatic update</phrase>
     </textobject>
    </mediaobject>
   </figure>
  </sect2>
 </sect1>


 <sect1 xml:id="yakindu-statechart-tools-user-guide">
  <title>YAKINDU Statechart Tools User Guide</title>
  <indexterm><primary>user guide</primary></indexterm>
  <indexterm><primary>YAKINDU Statechart Tools User Guide</primary></indexterm>

  <sect2 xml:id="what-are-yakindu-statechart-tools">
   <title>What are YAKINDU Statechart Tools?</title>

   <para>The statechart tools are a central part of YAKINDU: the modular toolkit for model-driven development of 
    embedded systems. It is based on the open-source development platform Eclipse. <application>YAKINDU Statechart 
    Tools</application> (YAKINDU SCT) provide the following tools to deal with state machine diagrams:</para>

   <itemizedlist>
    <listitem>
     <para><emphasis role="strong">YAKINDU SCT Editor</emphasis> to create and edit statecharts</para>
    </listitem>
    <listitem>
     <para><emphasis role="strong">YAKINDU Simulator</emphasis> to simulate the behavior of statecharts</para>
    </listitem>
    <listitem>
     <para><emphasis role="strong">YAKINDU Xpand generator projects</emphasis> to create a transformation of statecharts in Xpand</para>
    </listitem>
    <listitem>
     <para><emphasis role="strong">YAKINDU Xtend/Java generator projects</emphasis> to create a transformation in Xtend/Java</para>
    </listitem>
    <listitem>
     <para><emphasis role="strong">Integrated Validator</emphasis></para>
    </listitem>
   </itemizedlist>

   <para>The following graph shows these features and their relation to each other:</para>

   <figure>
    <title>Features of YAKINDU Statechart Tools</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/YAKINDU_features.png" align="center" width="80%" scalefit="1"/>
     </imageobject>
     <textobject>
      <phrase>Features of <application>YAKINDU Statechart Tools</application>
      </phrase>
     </textobject>
    </mediaobject>
   </figure>

   <sect3 xml:id="who-is-behind-yakindu-statechart-tools">
    <title>Who is behind YAKINDU Statechart Tools?</title>

    <para>The main part of <application>YAKINDU Statechart Tools</application> is an 
     open-source<indexterm><primary>open source</primary></indexterm> project 
     (<link xl:href="http://www.yakindu.org/">http://www.yakindu.org/</link> ). Most developers work for 
     itemis<indexterm><primary>itemis</primary></indexterm>, a well-known consulting company specialized on model-based 
     development.</para>

    <para>You may ask: Where does the money for open-source development come from? Well, itemis is providing 
     professional services around YAKINDU, be it training or on-site consulting, be it development of prototypes or 
     implementation of full-blown IDEs for programming languages, you name it. The itemis YAKINDU developers do not 
     only know the framework very well but are also experts in programming and domain-specific language 
     design<indexterm><primary>domain-specific language design</primary></indexterm>. If you need an advice get in 
     contact with itemis' YAKINDU team (<link xl:href="http://www.yakindu.de/">http://www.yakindu.de/</link> ).</para>
   </sect3>


   <sect3 xml:id="who-is-using-yakindu-statechart-tools">
    <title>Who is using <application>YAKINDU Statechart Tools</application>?</title>

    <para>Initially <application>YAKINDU Statechart Tools</application> have been designed for the embedded systems 
     industry: automotive, system controls, vending machines etc. However, <application>YAKINDU Statechart 
     Tools</application> are bringing benefit to everyone who needs to design, simulate and develop behavior. People 
     can use <application>YAKINDU Statechart Tools</application> to generate Java, C, or C++.</para>
   </sect3>


   <sect3 xml:id="what-is-the-structure-of-this-documentation">
    <title>What is the structure of this documentation?</title>

    <task role="fixme">
     <title>Decision needed</title>
     <procedure>
      <title>Decision needed</title>
      <step>
       <para>Decide what to do with this subsection regarding the document structure.</para>
      </step>
     </procedure>
    </task>

    <!-- FIXME:
    <orderedlist numeration="arabic">
     <listitem>
      <para><link linkend="yakindu-statechart-tools-user-guide">Overview</link></para>
     </listitem>
     <listitem>
      <para><link xl:href="../02_installation/installation.html">Installation</link></para>
     </listitem>
     <listitem>
      <para><link xl:href="../03_getting_started/getting_started.html">Getting Started</link></para>
     </listitem>
     <listitem>
      <para><link xl:href="../04_code_generation/code_generation.html">Code generation</link></para>
     </listitem>
     <listitem>
      <para><link xl:href="../05_reference/reference.html">Reference</link></para>
     </listitem>
     <listitem>
      <para><link xl:href="../06_tasks/tasks.html">Task</link></para>
     </listitem>
    </orderedlist>
    -->

   </sect3>
  </sect2>


  <sect2 xml:id="five-minutes-tutorial">
   <title>Five minutes tutorial</title>

   <para>This tutorial introduces <application>YAKINDU Statechart Tools</application> (SCT) which provides an 
    integrated modeling environment for the specification and development of reactive, event-driven systems based on 
    the concept of state machines or statecharts. It is an easy-to-use tool featuring sophisticated graphical 
    statechart editing, validation and simulation of statecharts as well as code generation for C, C++, and Java.</para>

   <para>This tutorial you will teach how to</para>

   <itemizedlist>
    <listitem>
     <para>create a new statechart model, and</para>
    </listitem>
    <listitem>
     <para>execute it using the simulation engine.</para>
    </listitem>
   </itemizedlist>

   <para>Please note that this tutorial will not explain statecharts
    <indexterm><primary>statecharts</primary></indexterm> in general, so you should familiarize yourself with the basic 
    concepts of state machines<indexterm><primary>state machines</primary></indexterm> first, see 
    <link xl:href="http://en.wikipedia.org/wiki/UML_state_machine">UML state machine</link>.</para>

   <para>In order to get a fully-working statechart implementation that you can integrate with your project, you will 
    have to familiarize yourself with <emphasis>code generation</emphasis>, which is covered by chapter 
    <link xl:href="#code-generation">Code generation</link> in this documentation. You can generate your state machine 
    implementation as source code in C, C++, and Java out of the box. Alternatively, you can write your own code 
    generator for other programming languages or for other purposes.</para>

   <para>Before we get started, make sure you have <application>YAKINDU Statechart Tools</application> installed. For 
    installation instructions, see the <link linkend="yakindu-statechart-tools-installation-guide">YAKINDU Statechart 
    Tools Installation Guide</link>.</para>


   <sect3 xml:id="the-light-switch-example">
    <title>The light switch example</title>
    <indexterm><primary>example</primary><secondary>light switch</secondary></indexterm>

    <para>The most basic example of a state machine that actually does something is a light switch. In this scenario 
     there is a light bulb and a switch to turn the bulb on and off. Of course there's also a power source and some 
     electrical cabling to put it all together, but for the purpose of our model we can omit them.</para>


    <sect4 xml:id="the-behaviour-of-a-light-switch">
     <title>The behaviour of a light switch</title>

     <para>When modeling the light switch example as a statechart, we can disregard everything (even the bulb) except for the switch. The behaviour of the switch is very simple:</para>

     <itemizedlist>
      <listitem>
       <para>Initially the light switch is off, i. e. it is in its <emphasis role="strong">Off</emphasis> state.</para>
      </listitem>
      <listitem>
       <para>If the light switch is operated while being in its <emphasis role="strong">Off</emphasis> state, it changes to its <emphasis role="strong">On</emphasis> state.</para>
      </listitem>
      <listitem>
       <para>If the light switch is operated while being in its <emphasis role="strong">On</emphasis> state, it changes to its <emphasis role="strong">Off</emphasis> state.</para>
      </listitem>
     </itemizedlist>
    </sect4>
   </sect3>


   <sect3 xml:id="modeling-the-light-switch-as-a-statechart">
    <title>Modeling the light switch as a statechart</title>

    <para>Now let's model the light switch as a statechart using <application>YAKINDU Statechart Tools</application>. This involves the following steps:</para>

    <orderedlist numeration="arabic">
     <listitem>
      <para>Creating an Eclipse project. It will serve as a container for the statechart model.</para>
     </listitem>
     <listitem>
      <para>Modeling the light switch using the <application>YAKINDU Statechart Tools</application> editor. The result will be a static statechart model.</para>
     </listitem>
     <listitem>
      <para>Simulating the model. We can play around with the model, operate the light switch and observe its behaviour.</para>
     </listitem>
    </orderedlist>


    <sect4 xml:id="creating-an-eclipse-project">
     <title>Creating an Eclipse project</title>
     <indexterm><primary>project</primary><secondary>creating an Eclipse project</secondary></indexterm>

     <para>The first step is to create a new Eclipse project that can serve as a container for our model. From the main 
      menu, select <emphasis>File → New → Project…</emphasis>:</para>

     <figure>
      <title>Selecting &quot;File → New → Project…&quot; in the main menu</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_010_menu_file_new_project.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Selecting &quot;File → New → Project…&quot; in the main menu</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>The <emphasis>New Project</emphasis> wizard opens, showing a couple of different project types structured in 
      various folders.</para>

     <figure>
      <title>The &quot;New Project&quot; wizard</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_020_wizard_new_project_general_project.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>The &quot;New Project&quot; wizard</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Select <emphasis>General → Project</emphasis> and click <emphasis>Next &gt;</emphasis>.</para>

     <para>The wizard shows its next page:</para>

     <figure>
      <title>&quot;Specifying project name and location&quot;</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_040_wizard_new_project.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>&quot;Specifying project name and location&quot;</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Specify a meaningful <emphasis>Project name</emphasis>, e. g. <emphasis role="strong">LightSwitch</emphasis>,
      and optionally select a <emphasis>Location</emphasis> to create the project in.</para>

     <para>Click <emphasis>Finish</emphasis>.</para>

     <para>Eclipse creates the new project:</para>

     <figure>
      <title>Project &quot;LightSwitch&quot; created</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_060_project_created.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Project &quot;LightSwitch&quot; created</phrase>
       </textobject>
      </mediaobject>
     </figure>
    </sect4>


    <sect4 xml:id="creating-a-folder-for-the-model">
     <title>Creating a folder for the model</title>
     <indexterm><primary>folder</primary><secondary>creating</secondary></indexterm>

     <para>Now that we have created the Eclipse project, we can establish the statechart model of the light switch. It 
      is good practice to use a separate directory for models, so let's create a new folder called 
      <emphasis>model</emphasis>.</para>

     <para>Right-click on the project's root, i. e. on <emphasis role="strong">LightSwitch</emphasis>, then select 
      <emphasis>New → Folder</emphasis> from the context menu.</para>

     <figure>
      <title>Selecting &quot;New → Folder&quot; in the context menu</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_100_menu_new_folder.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Selecting &quot;New → Folder&quot; in the context menu</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>The <emphasis>New Folder</emphasis> wizard opens:</para>

     <figure>
      <title>The &quot;New Folder&quot; wizard</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_110_wizard_new_folder.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>The &quot;New Folder&quot; wizard</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Give the model folder a reasonable name, e. g. <emphasis role="strong">model</emphasis>, and type it into 
      the <emphasis>Folder Name</emphasis> text field. Then click <emphasis>Finish</emphasis>.</para>

     <para>The new <emphasis>model</emphasis> folder is created and appears in the <emphasis>Project 
      Explorer</emphasis> view at the left.</para>
    </sect4>


    <sect4 xml:id="starting-with-an-empty-statechart-model">
     <title>Starting with an empty statechart model</title>
     <indexterm><primary>statechart model</primary><secondary>creating</secondary></indexterm>

     <sect5 xml:id="using-the-yakindu-statechart-wizard">
      <title>Using the YAKINDU Statechart wizard</title>
     <indexterm><primary>statechart wizard</primary></indexterm>

      <para>Now we are going to create an empty statechart model in the <emphasis>model</emphasis> folder. Right-click 
       on the <emphasis>model</emphasis> folder and select <emphasis>New → Other</emphasis> in the context menu:</para>

      <figure>
       <title>Selecting &quot;New → Other&quot; in the context menu</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/light_switch_120_menu_new_other.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>Selecting &quot;New → Other&quot; in the context menu</phrase>
        </textobject>
       </mediaobject>
      </figure>

      <para>The <emphasis>New</emphasis> wizard opens. Select <emphasis>YAKINDU SCT → Statechart model</emphasis></para>

      <figure>
       <title>Selecting &quot;YAKINDU SCT → Statechart model&quot;</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/light_switch_130_wizard_new.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>Selecting &quot;YAKINDU SCT → Statechart model&quot;</phrase>
        </textobject>
       </mediaobject>
      </figure>

      <para>Click <emphasis>Next &gt;</emphasis>. The wizard shows the <emphasis>New YAKINDU Statechart</emphasis> dialog:</para>

      <figure>
       <title>The &quot;New YAKINDU Statechart&quot; dialog</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/light_switch_140_wizard_new_yakindu_statechart.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>The &quot;New YAKINDU Statechart&quot; dialog</phrase>
        </textobject>
       </mediaobject>
      </figure>

      <para>The dialog asks you for the project, the directory, and the name of the model file to be created. Eclipse 
       project and directory should be correctly preset already. In our case the corresponding text field contains 
       <emphasis role="strong">LightSwitch/model</emphasis> which means the directory named <emphasis 
       role="strong">model</emphasis> in the <emphasis role="strong">LightSwitch</emphasis> project. You can change 
       that if you wish, but most likely you won't.</para>

      <para>The default file name in the <emphasis>File Name</emphasis> field is <emphasis 
       role="strong">default.sct</emphasis>, however. You should change that to something more meaningful. In our case 
       we type <emphasis role="strong">LightSwitch.sct</emphasis> into the <emphasis>File name</emphasis> field, see 
       the screenshot above.</para>

      <para>Click <emphasis>Finish</emphasis>.</para>

      <para>Since there's a dedicated perspective for statechart models, Eclipse asks you whether you want to change to it now or not:</para>
      <indexterm><primary>statechart modeling perspective</primary></indexterm>
      <indexterm><primary>YAKINDU Modeling perspective</primary></indexterm>

      <figure>
       <title>Dialog &quot;Confirm Perspective Switch&quot;</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/light_switch_150_dialog_confirm_perspective_switch.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>Dialog &quot;Confirm Perspective Switch&quot;</phrase>
        </textobject>
       </mediaobject>
      </figure>

      <para>Please answer the question regarding switching to the <emphasis>YAKINDU Modeling</emphasis> perspective by 
       clicking on the <emphasis>Yes</emphasis> button. The <emphasis>YAKINDU Modeling</emphasis> perspective has a 
       graphical editor for statechart models, and you will need it to create and modify statecharts. On the other hand 
       your answer really doesn't matter that much, because you can switch perspectives at any time. If you check 
       <emphasis>Do not offer to switch perspective in the future</emphasis> before clicking <emphasis>Yes</emphasis>, 
       Eclipse will never ask this question again, at least regarding the <emphasis>YAKINDU Modeling</emphasis> 
       perspective.</para>
     </sect5>


     <sect5 xml:id="the-initial-model">
      <title>The initial model</title>

      <para>An empty statechart is created and displayed in the <emphasis role="strong">statechart editor</emphasis> in 
       the middle of the Eclipse workbench. In the screenshot below the statechart editor is marked by a red rectangle. 
       Subsequently, we will use statechart editor to graphically develop the light switch statechart.</para>

      <figure xml:id="light_switch_220_statechart_editor">
       <title>The statechart editor</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/light_switch_220_statechart_editor.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>The statechart editor</phrase>
        </textobject>
       </mediaobject>
      </figure>

      <para>Actually the new statechart isn't really empty. It already contains the initial state (a small filled black 
       circle), a "normal” state, and a transition leading from the former to the latter.</para>
     </sect5>
    </sect4>


    <sect4 xml:id="statechart-validation">
     <title>Statechart validation</title>
     <indexterm><primary>validation</primary><secondary>statechart</secondary></indexterm>
     <indexterm><primary>statechart validation</primary></indexterm>

     <sect5 xml:id="error-markers-in-the-model-graph">
      <title>Error markers in the model graph</title>
     <indexterm><primary>error markers</primary></indexterm>

      <para>The "normal” state, however, has a small filled red circle containing a white ‘X' attached. This is an 
       error marker and tells you that something is wrong with your model, particularly with the object it is attached 
       to.</para>
     </sect5>


     <sect5 xml:id="error-markers-in-the-project-explorer">
      <title>Error markers in the project explorer</title>

      <para>The error marker is also shown in the <emphasis>Project Explorer</emphasis> view at the left-hand side of 
       the main window. In this way you can see immediately which of your projects contain errors. Click on the small 
       show/hide symbol (triangle) left of a project's or any other resource's name to show or hide its respective 
       contents. By doing so, you can quickly encircle the directories and files that are affected by errors. In the 
       screenshot above we have clicked open the <emphasis>LightSwitch</emphasis> project and the 
       <emphasis>model</emphasis> directory, showing the error is in the <emphasis>LightSwitch.sct</emphasis> 
       file.</para>
     </sect5>


     <sect5 xml:id="validation-principles">
      <title>Validation principles</title>

      <para>This error marker exemplifies <application>YAKINDU Statechart Tools</application>' model validation 
       capabilities. Statechart validation includes syntactical and semantical checks of the whole statechart. For 
       example, a statechart is checked for unreachable states, dead ends, or references to unknown events. These 
       validation constraints are checked during editing. In case any constraints are violated, error or warning 
       markers are attached to the faulty model elements. Thus the user receives direct and immediate feedback on the 
       validation state of his statechart.</para>

      <para>Hovering with the mouse over the error marker in the statechart editor reveals what the problem is. A 
      small popup appears and displays the error description: "A state must have a name."</para>

      <figure>
       <title>An error marker and a popup window explaining it</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/light_switch_210_error_marker_and_popup.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>An error marker and a popup window explaining it</phrase>
        </textobject>
       </mediaobject>
      </figure>
     </sect5>


     <sect5 xml:id="error-markers-in-the-problems-view">
      <title>Error markers in the "problems" view</title>

      <para>An alternative place to see error messages is the <emphasis>Problems</emphasis> view. This view has the 
       particular advantage to comprise all notifications in a clearly arranged list form, see the <link 
       linkend="light_switch_220_statechart_editor">screenshot above</link>. It displays:</para>

      <itemizedlist>
       <listitem>
        <para>A summary comprising the total number of errors, warnings, and others. In our case we have one error and 
         nothing else.</para>
       </listitem>

       <listitem>
        <para>Zero or more lists containing errors, warnings, and other types of messages, if available. In our example 
         there is a just a single list containing error messages. Click on the show/hide symbol to show the message 
         list's contents or the list's header only.</para>
       </listitem>
      </itemizedlist>

      <para>Double-clicking on an error message in the <emphasis>Problems</emphasis> view brings you directly to the 
       erroneous object.</para>

      <para>Hang on, we will correct the error in a second!</para>
     </sect5>
    </sect4>


    <sect4 xml:id="giving-a-state-a-name">
     <title>Giving a state a name</title>
     <indexterm><primary>state</primary><secondary>naming</secondary></indexterm>

     <para>As we have seen, the initial statechart is erroneous insofar as the state does not have a name. So let's fix 
      that.</para>

     <para>Remember the requirements of our light switch example? The first requirement demands the switch to be off 
      initially. The erroneous state is reached from the initial state immediately, so it is appropriate to name it 
      <emphasis role="strong">Off</emphasis>.</para>

     <informaltable role="scedit">
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>

        <row>
         <entry>Double-click on the string <literal>&lt;name&gt;</literal> in the state object. The string turns into a 
          text input field with <literal>&lt;name&gt;</literal> being highlighted:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info></info>
            <imagedata fileref="images/light_switch_230_statechart_editor_change_state_name_01.png" align="center" width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Type the state's new name, i. e. <literal>Off</literal>:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info></info>
            <imagedata fileref="images/light_switch_230_statechart_editor_change_state_name_02.png" align="center" width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Hit the <literal>[Enter]</literal> key or click anywhere outside the text field. Bingo! The state now 
          has a proper name and the error marker disappears:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_230_statechart_editor_change_state_name_03.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>However, since the state box's size is smaller now than before while the box's left position remains 
          unchanged, the graph looks crooked.</entry>
         <entry></entry>
        </row>

        <row>
         <entry>We can improve it by dragging the state box a little bit to the right. When it is centered below the 
          initial state symbol, a vertical blue line appears giving the user a visual hint:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_230_statechart_editor_change_state_name_04.png" align="center"
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Drop the state box at this very place, and everything looks much better now:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_230_statechart_editor_change_state_name_05.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Alternatively, we could have used the state box's handles to resize it. However, we just deselect the 
          box by clicking elsewhere:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_230_statechart_editor_change_state_name_06.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </sect4>


    <sect4 xml:id="creating-a-state">
     <title>Creating a state</title>
     <indexterm><primary>state</primary><secondary>creating</secondary></indexterm>

     <para>With the <emphasis role="strong">Off</emphasis> state only the light switch statechart isn't complete yet. 
      We also need an <emphasis role="strong">On</emphasis> state, and we going to create it now.</para>

     <informaltable role="scedit">
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>
        <row>
         <entry>In order to add another state, move the mouse pointer to the <emphasis>Palette</emphasis> compartment 
          at the right-hand side of the statechart editor. Click on the <emphasis>State</emphasis> symbol in the 
          palette without releasing the mouse button, and drag the symbol over to the editing area.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_240_statechart_editor_create_state_01.png" align="center"
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Release the mouse button over a gray area, a region:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_240_statechart_editor_create_state_02.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>The new state appears in the model graph:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_240_statechart_editor_create_state_03.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Rename the new state to <emphasis role="strong">On</emphasis>. Vertically align it to the 
          <emphasis role="strong">Off</emphasis> state, if you like:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_240_statechart_editor_create_state_04.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>You'll notice that the new state is showing an error marker. The reason is that it is not yet possible 
          to reach the <emphasis role="strong">On</emphasis> state.</entry>
         <entry></entry>
        </row>

        <row>
         <entry>Before we'll go on and fix that problem, here's another way to create a new state. When you are 
          hovering with the mouse pointer over the main region, i. e. the rectangle with a gray background, a popup 
          menu shows up. If you click on the ‘S' symbol in that menu, a new state will be created. Other options in 
          this menu are to create an initial state, a final state, or a choice.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_240_statechart_editor_create_state_05.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </sect4>


    <sect4 xml:id="creating-a-transition">
     <title>Creating a transition</title>
     <indexterm><primary>transition</primary><secondary>creating</secondary></indexterm>
     <indexterm><primary>YAKINDU Statechart Editor</primary><secondary>creating a transition</secondary></indexterm>
     <indexterm><primary>editor</primary><see>YAKINDU Statechart Editor</see></indexterm>
     <indexterm><primary>statechart editor</primary><see>YAKINDU Statechart Editor</see></indexterm>

     <para>As we have seen above, the <emphasis role="strong">On</emphasis> state is not reachable as of yet. So let's 
      model switching the light switch from "off” to "on” as a transition leading from the <emphasis 
      role="strong">Off</emphasis> state to the <emphasis role="strong">On</emphasis> state.</para>

     <informaltable role="scedit">
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>
        <row>
         <entry>In the <emphasis>Palette</emphasis>, click on the <emphasis>Transition</emphasis> symbol. The symbol's 
          background turn blue.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_250_statechart_editor_create_transition_01.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Click on the <emphasis role="strong">On</emphasis> state, but don't release the mouse button. Drag the 
          mouse pointer towards the <emphasis role="strong">Off</emphasis> state. A light gray line is shown as a 
          preview of the transition to be established:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_250_statechart_editor_create_transition_02.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Once the mouse pointer reaches the target state, it changes its shape:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_250_statechart_editor_create_transition_03.png" align="center" 
            width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Releasing the mouse button establishes the transition. A text input field to specify event trigger, 
          guard condition and effect appears. We want the transition to be triggered when the light switch is operated, 
          so let's type <literal>operate</literal> into the text field.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_250_statechart_editor_create_transition_04.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>If you suspect that something is not in order, because the input text is underlined in red, you are 
          right. We will explain and deal with that in a minute.</entry>
         <entry></entry>
        </row>

        <row>
         <entry>Clicking anywhere outside the text field terminates the editing mode:</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_250_statechart_editor_create_transition_05.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>

     <para>The event trigger <emphasis>operate</emphasis> is flagged as an error. The reason is that an event with that 
      name is not known yet. The screenshot below shows how to change that:</para>

     <figure>
      <title>Creating definitions [1]</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_260_statechart_editor_create_definitions_01.png" align="center" 
         width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Creating definitions [1]</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Double-click into the <emphasis role="strong">definition section</emphasis> <indexterm><primary>definition 
      section</primary></indexterm>on the left-hand side of the statechart editor. The section becomes an editable 
      text field.</para>

     <para>Enter the following text:</para>

     <programlisting>
internal:
    event operate
</programlisting>

     <para>Click anywhere outside of the text field, which terminates editing the definition section. The statechart 
      editor digests the definition, recognizes the definition of the <emphasis>operate</emphasis> event, and 
      validates the model as being okay:</para>

     <figure>
      <title>Creating definitions [2]</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/light_switch_260_statechart_editor_create_definitions_02.png" align="center" 
         width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Creating definitions [2]</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>In its current state the model would not allow to turn the light switch off again, which is somewhat 
      unsatisfactory. However, operating the light switch while it is on should turn it off. Let's model this by adding 
      another transition. It should lead from the source state <emphasis role="strong">On</emphasis> to the target 
      state <emphasis role="strong">Off</emphasis>.</para>

     <informaltable role="scedit">
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>
        <row>
         <entry>However, in order to not get two straight lines being close together in the graph, let's first make 
          some room and turn the present line into an arc. Move the mouse pointer over the transition line, but not 
          over the text. The mouse pointer changes its shape to indicate that you can insert a control point. Click and 
          hold to add the control point, then drag it to an appropriate position.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_270_statechart_editor_create_transition_01.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Now let's insert the second transition. This time we won't use the palette, but instead use another 
          method. Hover the mouse pointer over the source state, i. e. <emphasis role="strong">On</emphasis>. An 
          incoming and an outgoing arrow appear, both with a handle. Click and hold the handle of the outgoing arrow 
          and drag it to the <emphasis role="strong">Off</emphasis> target state.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_270_statechart_editor_create_transition_02.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>

        <row>
         <entry>Upon releasing the mouse button the transition is established. Type <literal>operate</literal> as the 
          transition's event trigger into the text field. Reshape the transition arrow to make the graph look 
          nice.</entry>
         <entry>
          <inlinemediaobject>
           <imageobject>
            <info/>
            <imagedata fileref="images/light_switch_270_statechart_editor_create_transition_03.png" align="center" 
             width="80%" scalefit="1"/>
           </imageobject>
          </inlinemediaobject>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </sect4>
   </sect3>


   <sect3 xml:id="simulating-the-light-switch-model">
    <title>Simulating the light switch model</title>
    <indexterm><primary>simulation</primary></indexterm>
    <indexterm><primary>statechart model simulation</primary></indexterm>

    <para>Simulating a model means to execute it, raise events manually, have time events and run cycle-based events 
     being triggered automatically, and observe its behaviour.</para>

    <para>Start the simulation by right-clicking on the <emphasis>LightSwitch.sct</emphasis> file in the project 
     explorer and selecting <emphasis>Run As → Statechart Simulation</emphasis>:</para>

    <figure>
     <title>Selecting &quot;Run As → Statechart Simulation&quot; in the context menu</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/light_switch_300_statechart_simulator_run_as_statechart_simulation.png" 
        align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Selecting &quot;Run As → Statechart Simulation&quot; in the context menu</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The perspective changes from <emphasis>SC Modeling</emphasis> to <emphasis>SC Simulation</emphasis>. This 
     perspective defines two additional views:</para>
    <indexterm><primary>perspective</primary><secondary>"SC Simulation"</secondary></indexterm>
    <indexterm><primary>"SC Simulation" perspective</primary></indexterm>

    <itemizedlist>
     <listitem>
      <para>The <emphasis>Debug</emphasis> view at the top shows all running statechart instances and allows to select 
       one of them. <application>YAKINDU Statechart Tools</application> allow multiple executions of the same 
       statechart as well as parallel executions of different statecharts at the same time.</para>
     </listitem>
     <listitem>
      <para>The <emphasis>Simulation</emphasis> view on the right-hand side is used to raise events and to inspect and 
       modify variables.</para>
      <indexterm><primary>view</primary><secondary>"Simulation"</secondary></indexterm>
      <indexterm><primary>"Simulation" view</primary></indexterm>
     </listitem>
    </itemizedlist>

    <para>Not surprisingly, the simulation starts at the initial state and then transitions to the <emphasis 
     role="strong">Off</emphasis> state immediately. The latter becomes the active state now. It is highlighted by a 
     red background:</para>

    <figure>
     <title>Light switch simulation in &quot;off&quot; state</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/light_switch_310_statechart_simulator_state_off.png" align="center" width="80%" 
        scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Light switch simulation in &quot;off&quot; state</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Now that the light switch is off, let's turn the lights on by operating the switch. In the simulation, we will have
     to raise the <emphasis>operate</emphasis> event. How can we do this?</para>

    <para>In the <emphasis>Simulation</emphasis> view at the right-hand side of the Eclipse workbench, click on the
     <emphasis>internal</emphasis> entry's show/hide symbol to display its contents.</para>

    <figure>
     <title>Displaying event names in the statechart simulator</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/light_switch_320_statechart_simulator_state_events.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Displaying event names in the statechart simulator</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>The <emphasis>operate</emphasis> event is shown. Click on it to raise the event, i. e. to operate the light 
     switch.</para>

    <para>The transition arc leading from the <emphasis role="strong">Off</emphasis> state to the <emphasis 
     role="strong">On</emphasis> state flashes briefly in red, and the <emphasis role="strong">On</emphasis> state 
     becomes active. Its background color changes to red while the <emphasis role="strong">On</emphasis> state's 
     background color becomes normal again.</para>

    <figure>
     <title>Light switch simulation in &quot;on&quot; state</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/light_switch_330_statechart_simulator_state_on.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Light switch simulation in &quot;on&quot; state</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>Click on <emphasis>operate</emphasis> again, and the active state changes back to <emphasis 
     role="strong">Off</emphasis>. Click on <emphasis>operate</emphasis> several times and enjoy watching the state 
     machine's behaviour.</para>

    <para>Stop the simulator by clicking at the little red termination button in the toolbar at the top.</para>
   </sect3>


   <sect3 xml:id="code-generation">
    <title>Code generation</title>
    <indexterm><primary>code generation</primary></indexterm>

    <para><application>YAKINDU Statechart Tools</application> include code generators for Java, C, and C++ out of the 
     box. The code generators are following a "code-only” approach: They are generating all the code that is needed and 
     do not rely on any additional runtime libraries. The generated code provides a well-defined application programming 
     interface and can be integrated easily with any client code. In this tutorial we will generate Java code for a 
     sample statechart modeling the handling of a phone call, the <emphasis role="strong">CallHandling</emphasis> 
     example.</para>

    <sect4 xml:id="the-callhandling-example">
     <title>The CallHandling example</title>
     <indexterm><primary>example</primary><secondary>call handling</secondary></indexterm>

     <para>The state machine handling a phone call works as follows:</para>

     <itemizedlist>
      <listitem>
       <para>After startup, the system is in an idle state and is waiting for incoming calls.</para>
      </listitem>
      <listitem>
       <para>When a call comes in, the user can either accept the call or dismiss it.</para>
      </listitem>
      <listitem>
       <para>If the users accepts the call and opens a connection, the system is tracking the duration of the call and 
        is waiting for the user to hang up.</para>
      </listitem>
      <listitem>
       <para>After hanging up, the system displays the total time of call and then returns to its idle state.</para>
      </listitem>
     </itemizedlist>

     <para>The complete statechart model is shown below:</para>

     <figure>
      <title>The CallHandling statechart model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_model.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>The CallHandling statechart model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>In order to eventually obtain the <emphasis role="strong">CallHandling</emphasis> example in the form of 
      executable code, we have to create the model in the statechart editor first, followed by creating a suitable 
      generator model, followed by executing the code generator to create the source code we need.</para>
    </sect4>


    <sect4 xml:id="creating-the-statechart-model">
     <title>Creating the statechart model</title>

     <para>In the <link xl:href="#five-minutes-tutorial">Five minutes tutorial</link> tutorial we have seen how to 
      operate the statechart editor. So let's create a new project now and use the statechart editor to create the 
      <emphasis role="strong">CallHandling</emphasis> statechart model as outlined above.</para>

     <para>In addition to what we have learned in the <link xl:href="#five-minutes-tutorial">Five Minutes 
      Tutorial</link> already, there is one new concept: interfaces.</para>

     <sect5 xml:id="creating-interfaces">
      <title>Creating interfaces</title>
      <indexterm><primary>interface</primary></indexterm>

      <para>Statecharts can describe very complex interactions between a multitude of actors and an even bigger 
       multitude of events these actors can receive or trigger. It is therefore good practice to structure such events 
       and associate them with their respective actors. For this purpose YAKINDU Statecharts Tools provides the concept 
       of so-called <emphasis>interfaces</emphasis>.</para>

      <para>In the <emphasis>CallHandling</emphasis> example, we have two actors: the user and the phone. Let's model 
       their communication as two interfaces:</para>

      <itemizedlist>
       <listitem>
        <para>The <emphasis>Phone</emphasis> interface provides a single incoming event named 
         <emphasis>incoming_call</emphasis>.</para>
       </listitem>
       <listitem>
        <para>The <emphasis>User</emphasis> interface comprises two incoming events: <emphasis>accept_call</emphasis> 
         and <emphasis>dismiss_call</emphasis>.</para>
       </listitem>
      </itemizedlist>

      <para>We have to enter the respective definitions in textual form into the statechart editor. Here's how the 
       interface definitions look like:</para>

      <programlisting>
interface User:
    in event accept_call
    in event dismiss_call

interface Phone:
    var duration : integer
    in event incoming_call
</programlisting>

      <para>As you can see, the <emphasis>Phone</emphasis> interface also has an integer variable
       <indexterm><primary>variable</primary></indexterm> <emphasis>duration</emphasis> which will track the duration 
       of the call. The interface definitions above have to go into the statechart editor's definition block on the 
       left-hand side of the statechart editor.</para>

      <para>If everything went well, any error markers in the model are gone. Your model should look like the one in 
       the screenshot below:</para>

      <figure>
       <title>The CallHandling statechart modeled in the statechart editor</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/callhandling_example_final.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject>
         <phrase>The CallHandling statechart modeled in the statechart editor</phrase>
        </textobject>
       </mediaobject>
      </figure>
     </sect5>
    </sect4>


    <sect4 xml:id="creating-a-generator-model">
     <title>Creating a generator model</title>
     <indexterm><primary>generator model</primary></indexterm>

     <para>For code generation, <application>YAKINDU Statechart Tools</application> use a textual generator model 
      called <emphasis role="strong">SGen</emphasis><indexterm><primary>SGen</primary></indexterm>. The generator model 
      holds key parameters for the code generation process and allows for the latter's customization.</para>

     <para>The first step to code generation is to create a new SGen model. Right-click on the 
      <emphasis>model</emphasis> folder in the project explorer and select <emphasis>New → Code Generator 
      Model</emphasis> from the context menu.</para>

     <figure>
      <title>Selecting &quot;New → Code Generator Model&quot; in the context menu</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_200_generation_create_generator_model.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Selecting &quot;New → Code Generator Model&quot; in the context menu</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>The <emphasis>YAKINDU Generator Model</emphasis> wizard opens. Change the <emphasis>File name</emphasis> to 
      <emphasis role="strong">CallHandling.sgen</emphasis>, then click <emphasis>Next &gt;</emphasis>.</para>

     <figure>
      <title>Selecting a filename for the generator model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_210_generation_new_sgen_model_1.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Selecting a filename for the generator model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>From the <emphasis>Generator</emphasis> drop-down menu at the top, select <indexterm><primary>Java code 
      generation</primary></indexterm>
      <indexterm><primary>code generation</primary><secondary>Java</secondary></indexterm><emphasis>YAKINDU SCT Java 
      Code Generator</emphasis>.</para>

     <para>In the statechart tree beneath that menu, check the <emphasis role="strong">CallHandling.sct</emphasis> 
      model, then click <emphasis>Finish</emphasis>.</para>

     <figure>
      <title>Selecting generator type and statechart model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_220_generation_new_sgen_model_2.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Selecting generator type and statechart model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Now the wizard creates the default SGen model for Java code generation and opens it in an 
      <indexterm><primary>SGen editor</primary></indexterm> 
      <indexterm><primary>editor</primary><secondary>SGen</secondary></indexterm>SGen editor. The project explorer on 
      the left-hand side shows the new model file <emphasis>CallHandling.sgen</emphasis>.</para>

     <figure>
      <title>The generator model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_230_generation_new_sgen_model_3.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>The generator model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Here's the generator model once again as plain text:</para>

     <programlisting>GeneratorModel for yakindu::java {

    statechart CallHandling {

        feature Outlet {
            targetProject = &quot;CallHandling&quot;
            targetFolder = &quot;src-gen&quot;
            libraryTargetFolder = &quot;src&quot;
        }
    }
}
</programlisting>

     <para>Let's have a closer look at the listing above:</para>

     <itemizedlist>

      <listitem>
       <para><literal>yakindu::java</literal> <indexterm><primary>yakindu::java</primary></indexterm> is the unique ID 
        of the Java code generator.</para>
      </listitem>

      <listitem>
       <para>The <literal>statechart CallHandling { … }</literal> block references the statechart model we want to 
        generate code for.</para>
      </listitem>

      <listitem>
       <para>The <literal>feature Outlet { … }</literal> <indexterm><primary>Outlet</primary></indexterm> block 
        specifies where the generated code artifacts are to be placed:</para>

       <itemizedlist>
        <listitem>
         <para>The parameters <literal>targetProject</literal> <indexterm><primary>targetProject</primary></indexterm> 
          and <literal>targetFolder</literal> <indexterm><primary>targetFolder</primary></indexterm>define the Eclipse 
          project <literal>CallHandling</literal> as destination for generated code and within that project the 
          <literal>src-gen</literal> folder.</para>
        </listitem>

        <listitem>
         <para>However, certain source code modules are generated only once and won't change with the underlying 
          statechart. By default, these source code artifacts are generated into the folder specified by the 
          <literal>libraryTargetFolder</literal> <indexterm><primary>libraryTargetFolder</primary></indexterm> option 
          which by default is <literal>src</literal>. You can change the folder name or even remove the 
          <literal>libraryTargetFolder</literal> option at all. In the latter case the "library” components are 
          generated into the <literal>targetFolder</literal>.</para>
        </listitem>
       </itemizedlist>
      </listitem>

     </itemizedlist>

     <para>A statechart reference may contain various configuration features. You will learn more about them 
      later.</para><remark role="fixme">Insert a reference here.</remark>
    </sect4>


    <sect4 xml:id="enhancing-the-generator-model-by-timing-capabilities">
     <title>Enhancing the generator model by timing capabilities</title>
     <indexterm><primary>time events</primary></indexterm>

     <para>The default generator model is insufficient yet. The <emphasis>CallHandling</emphasis> statechart model 
      uses <emphasis>after</emphasis> and <emphasis>every</emphasis> expressions. That is, it is dealing with 
      <emphasis role="strong">time events</emphasis>, requiring a timer service to trigger them. We can instruct the 
      code generator to provide us with a default timer service implementation by adding the following feature to the 
      generator model:</para>

     <programlisting>
feature GeneralFeatures {
    TimerService = true
}</programlisting>
    </sect4>


    <sect4 xml:id="generating-java-source-code">
     <title>Generating Java source code</title>
     <indexterm><primary>code generation</primary><secondary>Java</secondary></indexterm>
     <indexterm><primary>Java code generation</primary></indexterm>

     <para>What do we have to do to actually start the Java source code generation? Nothing!</para>

     <para>The generator model is executed by a so-called Eclipse 
      <indexterm><primary>builder</primary><secondary>Eclipse</secondary></indexterm> <emphasis>builder</emphasis>. 
      That is, as long as the <emphasis>Project → Build Automatically</emphasis> menu item is checked (which it is by 
      default), the artifacts are generated automatically with each modification of the statechart model or of the 
      generator model.</para>

     <para>As you can see in the project explorer, the folder <emphasis>src-gen</emphasis> has been created and 
      populated with the generated Java source code artifacts.</para>

     <figure>
      <title>Adding the timer service feature</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_240_generation_timer_service.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Adding the timer service feature</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Add the generated artifacts to the Java build path by right-clicking on the <emphasis>src-gen</emphasis> 
      folder and selecting <emphasis>Build Path → Use as source folder</emphasis> in the context menu.</para>

     <figure>
      <title>Declaring &quot;src-gen&quot; as a source folder</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/callhandling_250_generation_use_as_source_folder.png" align="center" width="80%" 
         scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Declaring &quot;src-gen&quot; as a source folder</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>If you want to execute your generator model manually, select <emphasis>Generate Statechart 
      Artifacts</emphasis> from the <literal>.sgen</literal> file's context menu in the project explorer.</para>
    </sect4>


    <sect4 xml:id="integration-with-client-code">
     <title>Integration with client code</title>
     <indexterm><primary>integration</primary></indexterm>

     <para>Now that we have a generated Java implementation of the <emphasis>CallHandling</emphasis> state machine 
      available, we want to actually use it from some client code. We'll create that client code in a second.</para>

     <sect5 xml:id="creating-client-code">
      <title>Creating client code</title>

      <para>Let's establish a new Java class <emphasis>CallHandlingClient</emphasis> and integrate the state machine 
       with it:</para>

      <orderedlist numeration="arabic">

       <listitem>
        <para>Right-clicking on the <emphasis>src</emphasis> folder.</para>
       </listitem>

       <listitem>
        <para>Select <emphasis>New → Class</emphasis> in the context menu.</para>
       </listitem>

       <listitem>
        <para>Name it <emphasis>CallHandlingClient</emphasis>.</para>

        <para><inlinemediaobject>
          <imageobject>
           <info/>
           <imagedata fileref="images/callhandling_300_java_integration_create_new_class.png" align="center" 
            width="80%" scalefit="1"/>
          </imageobject>
         </inlinemediaobject></para>
       </listitem>

       <listitem>
        <para>Click <emphasis>Finish</emphasis>.</para>
       </listitem>

      </orderedlist>

      <para>Next, copy the following code into the created class (without the line numbers, of course):</para>

      <programlisting>
 1  import org.yakindu.scr.TimerService;
 2  import org.yakindu.scr.callhandling.CallHandlingStatemachine;
 3
 4  public class CallHandlingClient {
 5
 6      public static void main(String[] args) throws InterruptedException {
 7
 8          // Create the state machine:
 9          CallHandlingStatemachine sm = new CallHandlingStatemachine();
10          sm.setTimer(new TimerService());
11
12          // Enter the state machine and implicitly activate its &quot;Idle&quot; state:
13          sm.enter();
14
15          // Raise an incoming call:
16          sm.getSCIPhone().raiseIncoming_call();
17          sm.runCycle();
18
19          // Accept the call:
20          sm.getSCIUser().raiseAccept_call();
21          sm.runCycle();
22
23          // Keep the phone conversation busy for a while:
24          for (int i = 0; i &lt; 50; i++) {
25              Thread.sleep(200);
26              sm.runCycle();
27          }
28
29          // Before hang-up, output the duration of the call:
30          System.out.println(String.format(&quot;The phone call took %d seconds.&quot;,
31                  sm.getSCIPhone().getDuration()));
32
33          // Hang up the phone:
34          sm.getSCIUser().raiseDismiss_call();
35          sm.runCycle();
36      }
37  }
</programlisting>

      <para>Let's have a detailed look at this client code:</para>

      <itemizedlist>

       <listitem>
        <para>First, this program creates a new instance of the state machine by calling the default constructor of 
         <literal>CallHandlingStatemachine</literal> (line 9).</para>
       </listitem>

       <listitem>
        <para>Since we are using time events, the statechart implementation requires an implementation of the 
         <literal>ITimer</literal> interface. Since we added the <literal>TimerService</literal> feature to the 
         generator model, the code generator creates a default implementation 
         <literal>org.yakindu.scr.TimerService</literal> that uses the <literal>java.util.Timer</literal> class. A new 
         instance of the default <literal>TimerService</literal> is created and set to the state machine (line 
         10).</para>
       </listitem>

       <listitem>
        <para>In line 13, <literal>sm.enter()</literal> enters the state machine and – via its initial state – 
         activates its <emphasis role="strong">Idle</emphasis> state.</para>
       </listitem>

       <listitem>
        <para>For each interface in the statechart definition block a getter method has been generated, here 
         <literal>getSCIPhone()</literal> and <literal>getSCIUser()</literal>. You can access all incoming events and 
         all variables via these interfaces. In line 16, the <emphasis>incoming_call</emphasis> event is raised, 
         activating the <emphasis role="strong">Incoming Call</emphasis> state after the next run cycle has been 
         executed (line 17).</para>
       </listitem>

       <listitem>
        <para>In line 20, we raise the <emphasis>accept_call</emphasis> event via the <emphasis>User</emphasis> 
         interface. It activates the <emphasis role="strong">Active Call</emphasis> state after the next run cycle has 
         been performed (line 21).</para>
       </listitem>

       <listitem>
        <para>From line 24 to line 27, the run cycle is executed periodically every 200 milliseconds.</para>
       </listitem>

       <listitem>
        <para>After that, the call's duration is printed to the console (lines 30 and 31).</para>
       </listitem>

       <listitem>
        <para>Finally, the <emphasis>dismiss_call</emphasis> event is raised (line 34), activating the 
         <emphasis role="strong">Dismiss Call</emphasis> state after the next run cycle (line 35).</para>
       </listitem>

      </itemizedlist>
     </sect5>


     <sect5 xml:id="executing-the-client-code">
      <title>Executing the client code</title>

      <para>You can execute the client code via <emphasis>Run As → Java Application</emphasis> from the class file's 
       context menu.</para>
     </sect5>
    </sect4>
   </sect3>
  </sect2>


  <sect2 xml:id="the-statechart-language">
   <title>The statechart language</title>
   <indexterm><primary>statechart language</primary></indexterm>

   <para>This chapter describes the statechart elements of the <application>YAKINDU Statechart Tools</application> 
    (YAKINDU SCT) editor. The YAKINDU SCT meta model is the model of finite state machines. It is based on the view of 
    a system that is defined by a finite number of states. The behavior of such a system is based on its active states. 
    These states are determined by the history of the state machine. Very important are the theoretical models for 
    state machines by <indexterm><primary>Mealy state machine</primary></indexterm> Mealy and 
    <indexterm><primary>Moore machine</primary></indexterm>Moore. Mealy state machines associate actions with 
    transitions. Moore machines associate actions with states (<emphasis role="state">entry</emphasis>,
    <emphasis role="state">exit</emphasis>). YAKINDU SCT can model both these types.</para>

   <para>The YAKINDU SCT meta model is designed similar to the <indexterm><primary>UML</primary></indexterm> UML 
    statechart meta model with the following differences:</para>

   <itemizedlist>

    <listitem>
     <para>YAKINDU SCT statecharts are self-contained with interfaces defined by events and variables.</para>
    </listitem>

    <listitem>
     <para>Core execution semantics are <indexterm><primary>run cycle</primary></indexterm>run cycle-driven, not 
      event-driven.</para>

     <itemizedlist>
      <listitem>
       <para>This allows to process concurrent events.</para>
      </listitem>

      <listitem>
       <para>Event-driven behavior can be defined on top.</para>
      </listitem>

     </itemizedlist>
    </listitem>

    <listitem>
     <para><indexterm><primary>time</primary></indexterm>Time is an abstract concept for statecharts.</para>
    </listitem>

    <listitem>
     <para><indexterm><primary>time</primary></indexterm>Time control is delegated to the environment.</para>
    </listitem>
   </itemizedlist>

   <para>The model interpreter and different flavors of generated code are following these same core semantics.</para>

   <para>Please refer to the Wikipedia article <link xl:href="http://en.wikipedia.org/wiki/UML_state_machine">UML state 
    machine</link> <indexterm><primary>UML state machine</primary></indexterm>for more details.</para>

   <para>A textual description language is used to declare and describe behaviors in a state machine. It is case 
    sensitive.</para>


   <sect3 xml:id="statechart">
    <title>Statechart</title>
     <indexterm><primary>statechart</primary></indexterm>
   </sect3>

   <sect3 xml:id="graphical-elements">
    <title>Graphical elements</title>

    <sect4 xml:id="region">
     <title>Region</title>
     <indexterm><primary>region</primary></indexterm>
     <indexterm><primary>regions</primary><secondary>parallel</secondary></indexterm>

     <para>As already mentioned, the YAKINDU statecharts are self-contained. They are organized in regions. Due to this
      it is possible to organize multiple state machines in different regions and to run them 
      <indexterm><primary>concurrency</primary></indexterm> concurrently.</para>

     <figure>
      <title>Parallel regions</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/parallelRegions.jpg" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Parallel regions</phrase>
       </textobject>
      </mediaobject>
     </figure>
    </sect4>


    <sect4 xml:id="state">
     <title>State</title>
     <indexterm><primary>state</primary></indexterm>

     <para>States are the central elements of a state machine. A state has to be placed inside a region and must have a 
      name that is unique inside this region. During simulation, each state can be active or passive. An active state 
      has actions that are accomplished. Either an action is carried out on entering a state, during active state, or 
      on exit.</para>
    </sect4>


    <sect4 xml:id="transition">
     <title>Transition</title>
     <indexterm><primary>transition</primary></indexterm>

     <para>A transition is the transfer of one state to another. Transitions are diagrammed as arrows. They can have 
      events and actions, but don't need to.</para>

     <para>The syntax of events and actions is defined by a <link linkend="the-statechart-language">textual description 
      language</link>. Please refer to section <link linkend="events">Events</link> of this documentation for more 
      details! For more details on actions please see chapter <link linkend="reaction-triggers">Actions</link>.</para>

     <para>If a state has more than a single outgoing transition without event, then among those transitions the one 
      that has been modeled first will be carried out.</para>
    </sect4>


    <sect4 xml:id="entry">
     <title>Entry</title>
     <indexterm><primary>entry</primary></indexterm>
     <indexterm><primary>entry state</primary></indexterm>
     <indexterm><primary>entry point</primary></indexterm>
     <indexterm><primary>entry node</primary></indexterm>

     <para>When a state machine starts or when the control flow enters a <link linkend="region">region</link>, an 
      <emphasis>entry</emphasis> defines which state is to be activated first. The flow passes through the state
      machine's or the region's entry and transitions to the target state the entry's transition is pointing to. 
      This state becomes active.</para>

     <para> An entry has a single outgoing transistion and no incoming ones. Its outgoing transition has neither a 
      trigger nor a guard condition.</para>

     <para>An entry is depicted as a filled circle, see <xref linkend="fig_state_entry_exit_final_explained"/>.</para>

     <figure xml:id="fig_state_entry_exit_final_explained">
      <title>Entry, exit, and final state</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/state_entry_exit_final_explained.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject><phrase>Entry, exit, and final state</phrase></textobject>
      </mediaobject>
     </figure>


     <sect5 xml:id="default-entry">
      <title>Default entry and initial state</title>
      <indexterm><primary>default entry</primary></indexterm>
      <indexterm><primary>entry</primary><secondary>default</secondary></indexterm>
      <indexterm><primary>initial state</primary></indexterm>
      <indexterm><primary>state</primary><secondary>initial</secondary></indexterm>

      <para>An entry without a name is called the <emphasis>default entry</emphasis>. It is similar to the
       UML's<indexterm><primary>UML</primary></indexterm> <emphasis>initial state</emphasis><indexterm><primary>initial 
       state</primary></indexterm><indexterm><primary>state</primary><secondary>initial</secondary></indexterm>. 
       However, while the transition from the initial state to an ordinary state may specify a guard, the transition 
       sourced at an entry cannot.</para>

       <para>A region may have at most one default entry.</para>
     </sect5>


     <sect5 xml:id="named-entries">
      <title>Named entries</title>
      <indexterm><primary>named entry</primary></indexterm>
      <indexterm><primary>entry</primary><secondary>named</secondary></indexterm>

      <para>The <link linkend="default-entry">default entry</link> specifies a single entry point into a region. 
       A region can provide a multitude of additional or alternative entry points, thus implementing different kinds of 
       behaviour, depending on which entry point has been taken. If a region comprises multiple entries, these entries 
       must be <emphasis>named</emphasis>. An entry's name must be unique within its region.</para>

      <para>The default entry implicitly has the name <literal>default</literal>. Alternatively, it is possible to 
       explicitly give the name <literal>default</literal> to the default entry. Semantically both variants are 
       equivalent. Whether an entry has no name or it has the name <literal>default</literal>: in both cases the entry 
       is called <emphasis>default entry</emphasis>.</para>

      <para>An incoming transition specifies a named entry to be used by the entry's <emphasis>name</emphasis>. This is 
       done in a so-called <emphasis>transition property</emphasis><indexterm><primary>property</primary></indexterm> 
       of the transition, according to the following format:</para>

      <synopsis><code># &gt;</code><emphasis>entry-name</emphasis></synopsis>

      <para>Named entries have no equivalent in the UML<indexterm><primary>UML</primary></indexterm>.</para>

      <example>
       <title>Named entries</title>

       <para>The sample statechart in <xref linkend="fig_state_entry"/> has a composite state
       named <emphasis role="state-name">Handle result</emphasis>. This composite state has a default entry as well as 
       an entry called <emphasis>failure</emphasis>. If state <emphasis role="state-name">A</emphasis> is active and the
       <emphasis role="trigger-name">error</emphasis> trigger fires, control is transitioned to the
       <emphasis role="state-name">Handle result</emphasis> composite state. The notation
       <literal>error # >failure</literal> specifies that the <emphasis>failure</emphasis> entry is to be
       used.</para></example>

      <figure xml:id="fig_state_entry">
       <title>Entry state</title>
       <mediaobject>
        <imageobject>
         <imagedata fileref="images/state_entry.png" align="center" width="80%" scalefit="1"/>
        </imageobject>
        <textobject><phrase>Entry state</phrase></textobject>
       </mediaobject>
      </figure>
     </sect5>
    </sect4>


    <sect4 xml:id="exit">
     <title>Exit</title>
     <indexterm><primary>exit state</primary></indexterm>
     <indexterm><primary>exit point</primary></indexterm>
     <indexterm><primary>exit node</primary></indexterm>
     <indexterm><primary>state</primary><secondary>exit</secondary></indexterm>

     <para>An <emphasis>exit</emphasis> is a pseudo state<indexterm><primary>pseudo state</primary></indexterm> that is
      used to leave and deactivate a composite state. Exits are counterpart to <link linkend="entry">entries</link>.
      They are also known as exit points, exit states, or exit nodes. See <xref linkend="final"/> for a different way
      to terminate a region or state machine.</para>

     <para>An exit may have multiple incoming transistions and has no outgoing one.</para>

     <para>An exit state is depicted as an unfilled circle with an X-shaped cross, see
      <xref linkend="fig_state_entry_exit_final_explained"/>.</para>

     <para>Within a region, multiple exits are allowed. Each exit must either have a name that is unique within its 
      region or be the <emphasis>default exit</emphasis>. The default exit is either unnamed or has the name 
      <literal>default</literal>, which is semantically equivalent. A region may have at most one default exit.</para>

     <para>When a composite state reaches an exit in any of its regions, all states in other regions of that composite 
      state, if any, are deactivated immediately. The composite state will be left and be deactivated. It maintains no 
      status information that could be probed from the outside. In other words, reaching an exit in one of a composite 
      state's regions has severe consequences for all the other regions since they are exited and disposed immediately. 
      After that, the containing composite state is also exited. There must be an unguarded transition that catches the 
      exit and leads to another state outside of the composite state. The semantics of exit is different from that of 
      final state; please see <xref linkend="final"/> for details.</para>

     <para>A transition that has a composite state as its source can specify which exits should triggered it. That
      is, different exits can lead to different behavior on the outside. A transition specifies the exits to 
      react upon as a so-called <emphasis>property</emphasis><indexterm><primary>property</primary></indexterm> 
      which looks like this:</para>

     <synopsis><code># </code><emphasis>exit-point-1</emphasis><code>&gt;</code> [ <emphasis>exit-point-2</emphasis><code>&gt;</code> ]…</synopsis>

     <para>Exits have no equivalent in the UML<indexterm><primary>UML</primary></indexterm>.</para>

     <example>
      <title>Exit</title>

      <para>The sample statechart in <xref linkend="fig_state_entry_exit"/> contains two composite states:</para>

      <itemizedlist>

       <listitem><para>The composite state <emphasis role="state-name">Process</emphasis> models a
        process with two passes (states) A and B. If both passes succeed, the composite state is left
        via the <emphasis>no_problem</emphasis> exit node. However, if an error occurs in either A or
        B the execution flow proceeds to the <emphasis>problem</emphasis> exit point and leaves the
        composite state there.</para></listitem>

       <listitem><para>The composite state <emphasis role="state-name">Handle result</emphasis> is
        intended to handle the processing result, be it success or failure. It has two entry points
        <emphasis>success</emphasis> and <emphasis>failure</emphasis>.</para></listitem>

      </itemizedlist>

      <para>The question is how to connect the exit points of <emphasis role="state-name">Process</emphasis>
       to the corresponding entry points of <emphasis role="state-name">Handle result</emphasis>. This is done by two 
       transitions leading from <emphasis role="state-name">Process</emphasis> to
       <emphasis role="state-name">Handle result</emphasis> and appropriate specifications.</para>

      <para>The transition shown on the left specifies <literal># no_problem> >success</literal>. This means: If the 
       source composite state is left via the <emphasis>no_problem</emphasis> exit point, enter the target composite 
       state at the <emphasis>success</emphasis> entry point. The specification of the transition on the right is 
       analogous: If the source state is left via the <emphasis>problem</emphasis> exit point, enter the target state 
       at the <emphasis>failure</emphasis> entry point.</para>

      <para>The order of exit and entry points in a transition specification is irrelevant. Instead, the position 
       of the <literal>&gt;</literal> character is decisive:</para>

      <itemizedlist>
        <listitem><para>If the <literal>&gt;</literal> character is to the <emphasis>right</emphasis> of a name, like in 
         <literal>exit_name&gt;</literal>, that name denotes an <emphasis>exit</emphasis>.</para></listitem>

        <listitem><para>If the <literal>&gt;</literal> character is to the <emphasis>left</emphasis> of a name, like in 
         <literal>&gt;entry_name</literal>, that name denotes an <emphasis>entry</emphasis>.</para></listitem>
      </itemizedlist>

      <para>Alternatively, <emphasis role="state-name">Process</emphasis> could have been modeled with two 
       different error exit states, say <emphasis>error_1</emphasis> and <emphasis>error_2</emphasis>. This
       would allow to respond differently to different error conditions, while still enabling to catch
       them both with a single flow. A transition with <literal># >error_1 >error_2 problem></literal>
       would do so.</para>
     </example>

     <figure xml:id="fig_state_entry_exit">
      <title>Entries and exits</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/state_entry_exit.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject><phrase>Entries and exits</phrase></textobject>
      </mediaobject>
     </figure>
    </sect4>

    <sect4 xml:id="final">
     <title>Final state</title>
     <indexterm><primary>final state</primary></indexterm>
     <indexterm><primary>state</primary><secondary>final</secondary></indexterm>

     <para>A <emphasis role="state">final state</emphasis> denotes the end of the execution flow of a state machine or 
      region. See <xref linkend="exit"/> for a different way to terminate a composite state.</para>

     <para>A final state is depicted as an unfilled circle with a smaller filled black circle inside, see
      <xref linkend="fig_state_entry_exit_final_explained"/>.</para>

     <para>A final state can have multiple incoming transitions and has no outgoing ones.</para>

     <para>Within a region, only a single final state is allowed, but each region may have its own final state.</para>

     <para>When a region reaches its final state, control stops there and waits until all other orthogonal regions, if 
      any, have reached their respective final states, too. The semantics of final states is different from that of 
      exits; please see <xref linkend="exit"/> for details.</para>

     <note>
      <para>Final states are proper states. This is different from the UML<indexterm><primary>UML</primary></indexterm>, 
       where a final state is a pseudo state<indexterm><primary>pseudo state</primary></indexterm>, i.&#x00a0;e. in the 
       UML, it cannot have any properties normal states can have, except for a name.</para>
     </note>
    </sect4>


    <sect4 xml:id="choice">
     <title>Choice</title>
     <indexterm><primary>choice state</primary></indexterm>
     <indexterm><primary>state</primary><secondary>choice</secondary></indexterm>

     <para>A choice is a pseudo state. It can be used to model a conditional path. A choice node divides a transition 
      into multiple parts.</para>

     <para>Usually the first transition points towards the choice node. One of the choice's outgoing transitions can 
     carry a condition.</para>
    </sect4>


    <sect4 xml:id="synchronization">
     <title>Synchronization</title>
     <indexterm><primary>synchronization state</primary></indexterm>
     <indexterm><primary>state</primary><secondary>synchronization</secondary></indexterm>

     <para>Synchronization is a means to either split a flow into several parallel regions of a substate or to join 
      several parallel flows from orthogonal regions into a single flow. The synchronization state corresponds to the 
      UML's<indexterm><primary>UML</primary></indexterm> concepts of fork<indexterm><primary>fork</primary></indexterm> 
      and join<indexterm><primary>join</primary></indexterm>.</para>

     <para>Whether a synchronization state behaves as a fork or as a join depends on its usage.</para>

     <itemizedlist>

      <listitem>
       <para>A synchronization with a single incoming transition and several outgoing ones <emphasis>forks</emphasis>
        the flow into several regions of the same substate. These regions are executed in parallel, see
        <xref linkend="orthogonal-states"/>.</para>
      </listitem>

      <listitem>
       <para>A synchronization with several incoming transitions from parallel regions of the same substate and a
        single outgoing transition <emphasis>joins</emphasis> the incoming flows into a single flow of execution.</para>
      </listitem>
     </itemizedlist>

     <para>A synchronization state is shown as a thick horizontal or vertical line, as can be seen in figure
      <xref linkend="fig_state_synchronization"/>.</para>

     <figure xml:id="fig_state_synchronization">
      <title>Synchronization state</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/state_synchronization.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject><phrase>Synchronization state</phrase></textobject>
      </mediaobject>
     </figure>

     <para>For a synchronization to actually join the incoming transitions and execute the outgoing one, all of the
      following conditions must be met:</para>

     <itemizedlist>

      <listitem>
       <para>All source states must be active.</para>
      </listitem>

      <listitem>
       <para>All guard conditions<indexterm><primary>guard condition</primary></indexterm> that are specified must be
        fulfilled.</para>
      </listitem>

      <listitem>
       <para>If one or more triggers are defined, at least one trigger must fire at a point in time while the conditions
        above are met.</para>
      </listitem>

     </itemizedlist>

     <example>
      <title>Synchronization</title>

     <para><xref linkend="fig_state_synchronization"/> shows an sample statechart containing a forking and a
      joining synchronization. After having left the <varname role="state-name">Initialize</varname> state,
      the synchronization state forks the execution flow into two regions
      <varname role="region-name">r1</varname> and <varname role="region-name">r2</varname>. Both are part of
      the <varname role="state-name">Process</varname> composite state and both are executed in
      parallel. That is, when activating <varname role="state-name">Process</varname>, the substates
      <varname role="state-name">Line A 1</varname> and 
      <varname role="state-name">Line B 1</varname> also become active. When the flows continues and both
      <varname role="state-name">Line A 2</varname> and 
      <varname role="state-name">Line B 2</varname> have been reached, the synchronization state on the
      right-hand side joins the flows and transitions to substates <varname role="state-name">Cleanup</varname>,
      making it the active state. However, as long as only one of them is active, the synchronization will
      wait for the other one to also become active before proceeding to
      <varname role="state-name">Process</varname>.</para>

      <para>The example also demonstrates different lengths and orientations of the synchronization symbol.
       In the statechart editor, first select the synchronization symbol, the use a handle in one of the
       symbol's corners to change length or orientation. The handles in the middle of the symbol
       have no effect.</para></example>
    </sect4>


    <sect4 xml:id="composite-state">
     <title>Composite state</title>
     <indexterm><primary>composite state</primary></indexterm>
     <indexterm><primary>state</primary><secondary>composite</secondary></indexterm>

     <para>A composite state is a state comprising one or more state machines. These state machines are also organized
      in regions within the composite state.</para>

     <para>Besides the simple composite state YAKINDU SCT knows about two kinds of composite states: orthogonal
      states and submachine states.</para>

     <para>Composite states contain other state machine branches.</para>
    </sect4>


    <sect4 xml:id="orthogonal-states">
     <title>Orthogonal states</title>
     <indexterm><primary>orthogonal states</primary></indexterm>
     <indexterm><primary>state</primary><secondary>orthogonal</secondary></indexterm>

     <para>In the context of state machines orthogonal states are states that are independent of each other. The 
      presumably most famous example is the 
      <indexterm><primary>example</primary><secondary>keyboard</secondary></indexterm> <indexterm><primary>keyboard 
      example</primary></indexterm> keyboard example:</para>

     <figure>
      <title>Orthogonal states</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/orthogonalState_example.jpg" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Orthogonal states</phrase>
       </textobject>
      </mediaobject>
     </figure>
    </sect4>


    <sect4 xml:id="shallow-history">
     <title>Shallow history</title>
     <indexterm><primary>shallow history state</primary></indexterm>
     <indexterm><primary>history state</primary><secondary>shallow</secondary></indexterm>
     <indexterm><primary>state</primary><secondary>shallow history</secondary></indexterm>

     <para>The shallow history state is a pseudo state that is placed inside regions of composite states. It is used 
      to remember the last active state inside a composite state. This makes it possible to jump back to the remembered 
      state instead of starting at the inner initial state again.</para>

     <para>The following example, showing the answering of a questionaire, explains this:</para>

     <figure>
      <title>Shallow history [1]</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/shallowHistory01.jpg" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Shallow history [1]</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Particularly interesting in this statechart are the events <varname 
      role="event-name">checkProgress</varname> and <varname role="event-name">goon</varname>. The event 
      <varname role="event-name">checkProgress</varname> jumps back to the <varname role="state-name">init</varname> 
      state while assigning the current progress count to the variable <varname role="variable-name">temp</varname>. 
      The event <varname role="event-name">goon</varname> jumps to the shallow history state that was placed inside 
      the composite state.</para>

     <figure>
      <title>Shallow history [2]</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/shallowHistory02.jpg" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Shallow history [2]</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <figure>
      <title>Shallow history [3]</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/shallowHistory03.jpg" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Shallow history [3]</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>When the <varname role="event-name">goon</varname> event is triggered, the most recent active state inside 
      of the composite state <varname role="state-name">answeringQuestions</varname> is activated again.</para>
    </sect4>

    <sect4 xml:id="deep-history">
     <title>Deep history</title>
     <indexterm><primary>deep history state</primary></indexterm>
     <indexterm><primary>history state</primary><secondary>deep</secondary></indexterm>
     <indexterm><primary>state</primary><secondary>deep history</secondary></indexterm>

     <para>Deep history is similar to shallow history, but more complex. With a deep history the latest state of 
      multiple nested states is remembered.</para>
    </sect4>
   </sect3>


   <sect3 xml:id="types">
    <title>Types</title>
    <indexterm><primary>type</primary></indexterm>
    <indexterm><primary>type system</primary></indexterm>

    <para>The language has a small integrated type system consisting of the following simple types:</para>

    <itemizedlist>
     <listitem>
      <para>integer</para>
     </listitem>
     <listitem>
      <para>real</para>
     </listitem>
     <listitem>
      <para>boolean</para>
     </listitem>
     <listitem>
      <para>string</para>
     </listitem>
     <listitem>
      <para>void</para>
     </listitem>
    </itemizedlist>


    <sect4 xml:id="declaring-variables">
     <title>Declaring variables</title>
     <indexterm><primary>declaration</primary><secondary>variable</secondary></indexterm>
     <indexterm><primary>variable</primary></indexterm>

     <para>Variables are typed. A variable is declared specifying its type:</para>

     <programlisting>
var intVar : integer
var realVar : real
var boolVar : boolean
var stringVar : string
</programlisting>
    </sect4>


    <sect4 xml:id="declaring-events">
     <title>Declaring events</title>
     <indexterm><primary>declaration</primary><secondary>event</secondary></indexterm>
     <indexterm><primary>event</primary></indexterm>

     <para>Events are typed. An event is declared specifying its type:</para>

     <programlisting>
event addInt : integer
event addReal : real
event checkValidity : boolean
event stringEvent : string
event voidEvent : void
</programlisting>
    </sect4>
   </sect3>


   <sect3 xml:id="statements">
    <title>Statements</title>
    <indexterm><primary>statement</primary></indexterm>

    <para>A statement is one of three kinds:</para>

    <itemizedlist>
     <listitem>
      <para>assignment</para>
     </listitem>
     <listitem>
      <para>event raising</para>
     </listitem>
     <listitem>
      <para>operation call</para>
     </listitem>
    </itemizedlist>


    <sect4 xml:id="assignments">
     <title>Assignments</title>
     <indexterm><primary>assignment</primary></indexterm>

     <para>The language has the following assignment operators:</para>
     <table>
      <caption>Assignment operators</caption>
      <tr>
       <td>simple assignment</td>
       <td>
        <code>=</code>
       </td>
      </tr>
      <tr>
       <td>multiply and assign</td>
       <td>
        <code>*=</code>
       </td>
      </tr>
      <tr>
       <td>divide and assign</td>
       <td>
        <code>/=</code>
       </td>
      </tr>
      <tr>
       <td>calculate modulo and assign</td>
       <td>
        <code>%=</code>
       </td>
      </tr>
      <tr>
       <td>add and assign</td>
       <td>
        <code>+=</code>
       </td>
      </tr>
      <tr>
       <td>subtract and assign</td>
       <td>
        <code>-=</code>
       </td>
      </tr>
      <tr>
       <td>bitshift left and assign</td>
       <td>
        <code>&lt;&lt;=</code>
       </td>
      </tr>
      <tr>
       <td>bitshift right and assign</td>
       <td>
        <code>&gt;&gt;=</code>
       </td>
      </tr>
      <tr>
       <td>bitwise AND and assign</td>
       <td>
        <code>&amp;=</code>
       </td>
      </tr>
      <tr>
       <td>bitwise XOR and assign</td>
       <td>
        <code>^=</code>
       </td>
      </tr>
      <tr>
       <td>bitwise OR and assign</td>
       <td>
        <code>|=</code>
       </td>
      </tr>
     </table>
    </sect4>


    <sect4 xml:id="raising-an-event">
     <title>Raising an event</title>
     <indexterm><primary>event raising</primary></indexterm>

     <para>An event is raised by calling a method whose name consists of the word <literal>raise</literal>, 
      immediately followed by the event name, e. g. <literal>raiseIncoming_call()</literal>. If the event is an 
      interface event, the name of the interface must also be appended.</para><remark role="fixme">Add an 
      example!</remark>
    </sect4>


    <sect4 xml:id="calling-an-operation">
     <title>Calling an operation</title>
     <indexterm><primary>operation</primary></indexterm>
     <indexterm><primary>operation call</primary></indexterm>

     <para>An operation is called similar to other programming languages with the operation name and passing concrete 
      parameters. The parameters can be expressions.</para><remark role="fixme">Add an example!</remark>
    </sect4>
   </sect3>


   <sect3 xml:id="expressions">
    <title>Expressions</title>
    <indexterm><primary>expression</primary></indexterm>

    <para>Expressions in <application>YAKINDU Statechart Tools</application> are similar to expressions in other
     programming languages. The language provides operators for logical expressions, number arithmetic, bitwise
     arithmetic, and bit shifting.</para>

    <para>The type of a logical expression is <emphasis role="strong">boolean</emphasis>.</para>


    <sect4 xml:id="LogicalAND">
     <title>Logical AND</title>
     <indexterm><primary>logical expression</primary></indexterm>
     <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>

     <programlisting>
expr1 &amp;&amp; expr2
</programlisting>
    </sect4>


    <sect4 xml:id="LogicalOR">
     <title>Logical OR</title>
     <indexterm><primary>logical expression</primary></indexterm>
     <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>

     <programlisting>
expr1 ||  expr2 
</programlisting>
    </sect4>


    <sect4 xml:id="LogicalNOT">
     <title>Logical NOT</title>
     <indexterm><primary>logical expression</primary></indexterm>
     <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>

     <programlisting>
!expr1 
</programlisting>
    </sect4>


    <sect4 xml:id="Conditionalexpression">
     <title>Conditional expression</title>
     <indexterm><primary>logical expression</primary></indexterm>
     <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>

     <programlisting>
expr1 ? expr2 : expr3
</programlisting>
    </sect4>


    <sect4 xml:id="BitwiseXOR">
     <title>Bitwise XOR</title>
     <indexterm><primary>bitwise arithmetic expression</primary></indexterm>
     <indexterm><primary>arithmetic expression</primary><secondary>bitwise</secondary></indexterm>
     <indexterm><primary>expression</primary><secondary>bitwise arithmetic</secondary></indexterm>

     <programlisting>
expr1 ^ expr2
</programlisting>
    </sect4>


    <sect4 xml:id="BitwiseOR">
     <title>Bitwise OR</title>
     <indexterm><primary>bitwise arithmetic expression</primary></indexterm>
     <indexterm><primary>arithmetic expression</primary><secondary>bitwise</secondary></indexterm>
     <indexterm><primary>expression</primary><secondary>bitwise arithmetic</secondary></indexterm>

     <programlisting>
expr1 | expr2
</programlisting>
    </sect4>


    <sect4 xml:id="BitwiseAND">
     <title>Bitwise AND</title>
     <indexterm><primary>bitwise arithmetic expression</primary></indexterm>
     <indexterm><primary>arithmetic expression</primary><secondary>bitwise</secondary></indexterm>
     <indexterm><primary>expression</primary><secondary>bitwise arithmetic</secondary></indexterm>

     <programlisting>expr1 &amp; expr2</programlisting>
    </sect4>


    <sect4 xml:id="LogicalRelationsandShiftOperators">
     <title>Logical Relations and Shift Operators</title>

     <informaltable>
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>

        <row>
         <entry>
          <indexterm><primary>logical expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>
          less than</entry>
         <entry><literal>&lt;</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>logical expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>
          equal or less than</entry>
         <entry><literal>&lt;=</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>logical expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>
          greater than</entry>
         <entry><literal>&gt;</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>logical expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>
          equal or greater than</entry>
         <entry><literal>&gt;=</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>logical expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>
          equal</entry>
         <entry><literal>==</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>logical expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>logical</secondary></indexterm>
          not equal</entry>
         <entry><literal>!=</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>bitwise arithmetic expression</primary></indexterm>
          <indexterm><primary>arithmetic expression</primary><secondary>bitwise</secondary></indexterm>
          <indexterm><primary>expression</primary><secondary>bitwise arithmetic</secondary></indexterm>
          shift left</entry>
         <entry><literal>&lt;&lt;</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>bitwise arithmetic expression</primary></indexterm>
          <indexterm><primary>arithmetic expression</primary><secondary>bitwise</secondary></indexterm>
          <indexterm><primary>expression</primary><secondary>bitwise arithmetic</secondary></indexterm>
          shift right</entry>
         <entry><literal>&gt;&gt;</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </sect4>

    <sect4 xml:id="Binaryarithmeticoperators">
     <title>Binary arithmetic operators</title>

     <informaltable>
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>
        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          plus</entry>
         <entry><literal>+</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          minus</entry>
         <entry><literal>-</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          multiply</entry>
         <entry><literal>*</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          divide</entry>
         <entry><literal>/</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          modulo</entry>
         <entry><literal>%</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </sect4>


    <sect4 xml:id="Unaryarithmeticoperators">
     <title>Unary arithmetic operators</title>

     <informaltable>
      <tgroup cols="2">
       <colspec align="left" />
       <colspec align="left" />
       <tbody>
        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          positive</entry>
         <entry><literal>+</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          negative</entry>
         <entry><literal>-</literal></entry>
        </row>

        <row>
         <entry>
          <indexterm><primary>arithmetic expression</primary></indexterm>
          <indexterm><primary>expression</primary><secondary>arithmetic</secondary></indexterm>
          complement</entry>
         <entry><literal>~</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </sect4>
   </sect3>


   <sect3 xml:id="scopes">
    <title>Scopes</title>
    <indexterm><primary>scope</primary></indexterm>

    <sect4 xml:id="Namespace" role="stext_keyword_namespace">
     <title>Namespace</title>
     <indexterm><primary>namespace</primary></indexterm>

     <para>The language allows to define unique namespaces which can be used to qualify references to the 
      statechart.</para>

     <programlisting>namespace trafficlights</programlisting>
    </sect4>


    <sect4 xml:id="interfacescope" role="stext_keyword_interface">
     <title>Interface scope</title>
     <indexterm><primary>interface scope</primary></indexterm>
     <indexterm><primary>scope</primary><secondary>interface</secondary></indexterm>

     <para>Declarations in the interface scope are externally visible. They can be shared within the environment.</para>

     <programlisting>
interface NamedInterface:
in event event1
out event event3 : integer
var variable1 : integer
</programlisting>
    </sect4>


    <sect4 xml:id="internal-scope" role="stext_keyword_internal">
     <title>Internal scope</title>
     <indexterm><primary>internal scope</primary></indexterm>
     <indexterm><primary>scope</primary><secondary>internal</secondary></indexterm>

     <para>Declarations made in an internal scope are visible to contained states only.</para>

     <programlisting>
internal:
var localVariable1: integer
event localEvent: integer
local event localEvent2
operation localOperation (int1 : integer, int2 : integer): integer
localEvent2 / raise NamedInterface.event3 : 
localOperation(valueof(localEvent) , NamedInterface.variable1)
</programlisting>
    </sect4>
   </sect3>


   <sect3 xml:id="declarations">
    <title>Declarations</title>
    <indexterm><primary>declaration</primary></indexterm>

    <para>Within scopes, variables, constants, events, variables, operations, and local reactions can be
     declared.</para>

    <sect4 xml:id="variables" role="stext_keyword_var">
     <title>Variables</title>
     <indexterm><primary>variable</primary></indexterm>

     <para>Variables can have different 
      <indexterm><primary>visibility</primary><secondary>variable</secondary></indexterm>visibilities. They can be 
      visible for the environment:</para>

     <programlisting>var variable1: real</programlisting>

     <para>Variables can be <emphasis>readonly</emphasis> (constants):</para>

     <programlisting>var readonly pi: real = 3.1415</programlisting>

     <para>Variables can be referenced by the environment.</para>

     <programlisting>var external variable3: integer = 34</programlisting>
    </sect4>


    <sect4 xml:id="constants" role="stext_keyword_const">
     <title>Constants</title>
     <para>Variables can be immutable. For this special variable the keyword <literal>const</literal> is used:</para>
     <programlisting>
const variable1: real
</programlisting>
    </sect4>

    <sect4 xml:id="events" role="stext_keyword_event">
     <title>Events</title>

     <sect5 xml:id="incoming-and-outgoing-events">
      <title>Incoming and outgoing events</title>
      <indexterm><primary>event</primary></indexterm>
      <indexterm><primary>incoming</primary><secondary>event</secondary></indexterm>
      <indexterm><primary>outgoing</primary><secondary>event</secondary></indexterm>

      <para>An event in an interface scope has a direction. It is either ingoing or outgoing:</para>

      <programlisting>
interface NamedInterface:
in event event1
out event event2
</programlisting>
     </sect5>


     <sect5 xml:id="events-with-variables">
      <title>Events with variables</title>
      <indexterm><primary>event</primary><secondary>with variable</secondary></indexterm>

      <para>An event in the local scope can carry variables:</para>

      <programlisting>
internal:
event localEvent1 : integer
</programlisting>

      <para>A local event can have a value assignment:</para>

      <programlisting>
internal:
event localEvent1: integer = 25
</programlisting>

      <para>Read access to the value of an event is possible in the statechart using the <literal>valueof()</literal>
       built-in method. Please note that reading an event's value is possible only when the event actually occurs, for 
       example in a guard:</para>

      <programlisting>localEvent1 [valueof(localEvent1) == 6]</programlisting>

      <para>An event parameter can be specified when raising an event, as in the following example:</para>

      <programlisting>raise event1 : 3+3</programlisting>

      <remark role="fixme">Explain how and where an event can be raised!</remark>
     </sect5>
    </sect4>


    <sect4 xml:id="operations" role="stext_keyword_operation">
     <title>Operations</title>
     <indexterm><primary>operation</primary></indexterm>

     <para>Operations can have none, one or multiple parameters. A parameter is declared with a name and a type. An 
      operation may have a single return type similar to Java.</para>

     <programlisting>operation localOperation (xValue : integer, yValue : integer):integer</programlisting>
    </sect4>


    <sect4 xml:id="local-reactions">
     <title>Local reactions</title>
     <indexterm><primary>local reaction</primary></indexterm>

     <para>Local reactions describe the internal behavior of a state. So they have internal scope. A local reaction is 
      declared as follows:</para>

     <programlisting>
LocalReaction: ReactionTrigger '/' ReactionEffect ('#' ReactionProperties)?

ReactionTrigger: (Event (&quot;,&quot; Event  )*  (=&gt; '[' Expression ']')?) | '[' Expression ']' 

ReactionEffect:  Statement (';' Statement )* (';')?

Statement: Assignment | EventRaising | OperationCall

ReactionProperties: (EntryPoint | ExitPoint)*
</programlisting>

     <para>Within a local reaction an interface event can be raised:</para>

     <programlisting>
internal:
localEvent1 / raise NamedInterface.event3 : localOperation (valueof(localEvent), NamedInterface.variable1);
</programlisting>

     <para>A local reaction can have a priority value. The latter is defined by appending the character 
      <literal>#</literal> and the numeric priority value to the local reaction's definition. Examples:</para>

     <remark role="fixme">Describe the meaning of priorities!</remark>

     <programlisting>
localEvent2 / NamedInterface.variable2 += 3; #1
localEvent3 / NamedInterface.variable4 += 2.0; #2
</programlisting>
    </sect4>
   </sect3>


   <sect3 xml:id="reaction-triggers">
    <title>Reaction triggers</title>
    <indexterm><primary>reaction trigger</primary></indexterm>
    <indexterm><primary>trigger</primary></indexterm>
    <indexterm><primary>action</primary></indexterm>

    <para>Actions are key constructs in state machines to model behavior. YAKINDU SCT knows about the following kinds 
     of actions.</para>

    <sect4 xml:id="after" role="stext_keyword_after">
     <title>after</title>
     <indexterm><primary>after</primary></indexterm>

     <para>The <emphasis>after</emphasis> trigger specifies a one-shot time event.</para>

     <para>After the specified time the reaction is triggered. An <emphasis>after</emphasis> trigger can be used in 
      transitions of states as well as in local reactions of states and statecharts. The specified time starts when the 
      state or statechart is entered.</para>

     <programlisting>after 20 s</programlisting>

     <para>Synopsis: <synopsis><literal>after</literal> <varname>time</varname> <varname>unit</varname></synopsis></para>

     <para>The <emphasis>time</emphasis> value is a integer literal or an expression with an integer value.</para>

     <para>The time <emphasis>unit</emphasis> is one of:</para>

     <itemizedlist>
      <listitem>
       <para role="stext_keyword_s"><literal>s</literal>: seconds</para>
      </listitem>
      <listitem>
       <para role="stext_keyword_ms"><literal>ms</literal>: milliseconds</para>
      </listitem>
      <listitem>
       <para role="stext_keyword_us"><literal>us</literal>: microseconds</para>
      </listitem>
      <listitem>
       <para role="stext_keyword_ns"><literal>ns</literal>: nanoseconds</para>
      </listitem>
     </itemizedlist>
    </sect4>


    <sect4 xml:id="every" role="stext_keyword_every">
     <title>every</title>
     <indexterm><primary>every</primary></indexterm>

     <para>The <emphasis>every</emphasis> trigger specifies periodic time events.</para>

     <para>The reaction is triggered recurrently after each passing of the specified period of time. An 
      <emphasis>every</emphasis> trigger can be used in transitions as well as in local reactions of states and 
      statecharts. The specified period of time starts when the state or statechart is entered and repeats 
      periodically.</para>

     <programlisting>every 200 ms</programlisting>

     <para>Synopsis: <synopsis><literal>every</literal> <varname>time</varname> <varname>unit</varname></synopsis></para>

     <para>The <emphasis>time</emphasis> value is a integer literal or an expression with an integer value.</para>

     <para>The time <emphasis>unit</emphasis> is one of:</para>

     <itemizedlist>
      <listitem>
       <para><literal>s</literal>: seconds</para>
      </listitem>
      <listitem>
       <para><literal>ms</literal>: milliseconds</para>
      </listitem>
      <listitem>
       <para><literal>us</literal>: microseconds</para>
      </listitem>
      <listitem>
       <para><literal>ns</literal>: nanoseconds</para>
      </listitem>
     </itemizedlist>
    </sect4>


    <sect4 xml:id="always" role="stext_keyword_always">
     <title>always</title>
     <indexterm><primary>always</primary></indexterm>

     <para>This trigger is always true and enables a reaction to be executed in every 
      <indexterm><primary>run-to-completion</primary></indexterm>run-to-completion step (RTC). The 
      <emphasis>always</emphasis> trigger is equivalent to the <emphasis>oncycle</emphasis> trigger.</para>
    </sect4>


    <sect4 xml:id="oncycle" role="stext_keyword_oncycle">
     <title>oncycle</title>
     <indexterm><primary>oncycle</primary></indexterm>

     <para>This trigger is always true and enables a reaction to be executed in every 
      <indexterm><primary>run-to-completion</primary></indexterm>run-to-completion step (RTC). The 
      <emphasis>always</emphasis> trigger is equivalent to the <emphasis>oncycle</emphasis> trigger.</para>
    </sect4>


    <sect4 xml:id="else" role="stext_keyword_else">
     <title>else</title>
     <indexterm><primary>else</primary></indexterm>

     <para>This trigger is intended to be used for the outgoing transitions of <emphasis>choice</emphasis> pseudo 
      states to make sure that there is always an outgoing transition that can be taken. It can only be be used in 
      transitions and implies the lowest evaluation priority for that transition. The <emphasis>default</emphasis> 
      trigger is equivalent to the <emphasis>else</emphasis> trigger.</para> 
    </sect4>


    <sect4 xml:id="default" role="stext_keyword_default">
     <title>default</title>
     <indexterm><primary>default</primary></indexterm>

     <para>This trigger is intended to be used for the outgoing transitions of <emphasis>choice</emphasis> pseudo 
      states to make sure that there is always an outgoing transition that can be taken. It can only be be used in 
      transitions and implies the lowest evaluation priority for that transition. The <emphasis>default</emphasis> 
      trigger is equivalent to the <emphasis>else</emphasis> trigger.</para> 
    </sect4>


    <sect4 xml:id="entry-1" role="stext_keyword_entry">
     <title>entry</title>
     <indexterm><primary>entry</primary></indexterm>

     <para>An <emphasis>entry</emphasis> trigger marks actions that are carried out when entering a state or state 
      machine.</para>
    </sect4>


    <sect4 xml:id="exit-1" role="stext_keyword_exit">
     <title>exit</title>
     <indexterm><primary>exit</primary></indexterm>

     <para>An <emphasis>exit</emphasis> trigger marks actions that are carried out when exiting a state or state 
      machine.</para>
    </sect4>
   </sect3>


   <sect3 xml:id="built-in-functions">
    <title>Built-in functions</title>
     <indexterm><primary>built-in functions</primary></indexterm>
     <indexterm><primary>functions</primary><secondary>built-in</secondary></indexterm>

    <sect4 xml:id="valueofevent" role="stext_keyword_valueof">
     <title>valueof(event)</title>
     <indexterm><primary>valueof(event)</primary></indexterm>
     <indexterm><primary>event</primary></indexterm>

     <para>An event can have a value. This function returns the value of the specified event.</para>
     
     <remark role="fixme">Specify what happens if the event does not have a value.</remark>

     <programlisting>myVar = valueof(myEvent)</programlisting>
    </sect4>


    <sect4 xml:id="as" role="stext_keyword_as">
     <title>as</title>
     <indexterm><primary>as</primary></indexterm>

     <para>Casts a variable. The following example casts a literal from integer to real.</para>

     <programlisting>myReal = 12 as real</programlisting>
    </sect4>


    <sect4 xml:id="activestate" role="stext_keyword_active">
     <title>active(state)</title>
     <indexterm><primary>active(state)</primary></indexterm>

     <para>Returns <emphasis>true</emphasis> if the specified state is active and <emphasis>false</emphasis> 
      otherwise.</para>

     <programlisting>myBool = active(StateA)</programlisting>
    </sect4>
   </sect3>
  </sect2>


  <sect2 xml:id="editing-statecharts">
   <title>Editing statecharts</title>
   <indexterm><primary>editing statecharts</primary></indexterm>
   <indexterm><primary>statechart editor</primary></indexterm>
   <indexterm><primary>YAKINDU Statechart Editor</primary></indexterm>

   <sect3 xml:id="creating-and-deleting-statecharts">
    <title>Creating and deleting statecharts</title>
    <indexterm><primary>creating a statechart</primary></indexterm>
    <indexterm><primary>deleting a statechart</primary></indexterm>

   </sect3>

   <sect3 xml:id="editor-ui">
    <title>Editor UI</title>
    <sect4 xml:id="sc-modeling-perspective">
     <title>"SC Modeling" perspective</title>
     <indexterm><primary>"SC Modeling" perspective</primary></indexterm>

    </sect4>


    <sect4 xml:id="canvas">
     <title>Canvas</title>
     <indexterm><primary>canvas</primary></indexterm>

    </sect4>
    <sect4 xml:id="editor-palette">
     <title>Editor palette</title>
     <indexterm><primary>editor palette</primary></indexterm>
     <indexterm><primary>palette</primary></indexterm>

    </sect4>


    <sect4 xml:id="outline-view">
     <title>Outline view</title>
     <indexterm><primary>outline view</primary></indexterm>
     <indexterm><primary>view</primary><secondary>outline</secondary></indexterm>

    </sect4>


    <sect4 xml:id="problems-view">
     <title>Problems view</title>
     <indexterm><primary>problems view</primary></indexterm>
     <indexterm><primary>view</primary><secondary>problems</secondary></indexterm>

    </sect4>
   </sect3>


   <sect3 xml:id="editing-states-and-other-nodes">
    <title>Editing states and other nodes</title>
    <indexterm><primary>editing states</primary></indexterm>
    <indexterm><primary>state</primary><secondary>editing</secondary></indexterm>

   </sect3>


   <sect3 xml:id="editing-transitions">
    <title>Editing transitions</title>
    <indexterm><primary>editing transitions</primary></indexterm>
    <indexterm><primary>transitions</primary><secondary>editing</secondary></indexterm>

   </sect3>


   <sect3 xml:id="editing-hierarchies">
    <title>Editing hierarchies</title>
    <indexterm><primary>editing hierarchies</primary></indexterm>
    <indexterm><primary>hierarchy</primary><secondary>editing</secondary></indexterm>

   </sect3>


   <sect3 xml:id="using-subdiagrams">
    <title>Using subdiagrams</title>
    <indexterm><primary>subdiagram</primary></indexterm>
    <indexterm><primary>composite state</primary></indexterm>
    <indexterm><primary>state</primary><secondary>composite</secondary></indexterm>

    <para>When using composite states, a statechart model often becomes too big to give a comprehensive overview of the 
     whole diagram. Although it is possible to collapse and expand a state's figure compartment, these actions would 
     spoil the diagram layout each time they are executed. Subdiagrams come as a solution.</para>

    <figure>
     <title>Composite state</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/extract_subdiagram.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Composite state</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>When the <emphasis>Extract Subdiagram</emphasis> refactoring is executed on a composite state, all containing 
     regions are extracted into a separate diagram. A small decorator in the lower-right corner of the state indicates 
     the existence of such a subdiagram. When you hover with the mouse cursor over this decorator, you'll see a small 
     preview of the subdiagram's content. The refactoring also creates the required 
     <emphasis role="state">entry</emphasis> and <emphasis role="state">exit</emphasis> points for you.</para>

    <figure>
     <title>Subdiagram popup window</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/extract_subdiagram2.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Subdiagram popup window</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>A click on the decorator opens the subdiagram in a separate editor tab. The breadcrumb at the top allows easy 
     navigation throughout the hierachy levels.</para>

    <figure>
     <title>Subdiagram editor</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/extract_subdiagram3.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>Subdiagram editor</phrase>
      </textobject>
     </mediaobject>
    </figure>
   </sect3>


   <sect3 xml:id="refactorings">
    <title>Refactorings</title>
    <indexterm><primary>refactoring</primary></indexterm>

   </sect3>


   <sect3 xml:id="using-editing-proposals">
    <title>Using editing proposals</title>
    <indexterm><primary>editing proposals</primary></indexterm>
    <indexterm><primary>proposal</primary><secondary>editing </secondary></indexterm>

   </sect3>


   <sect3 xml:id="comparing-statecharts">
    <title>Comparing statecharts</title>
    <indexterm><primary>comparing statecharts</primary></indexterm>
    <indexterm><primary>statechart</primary><secondary>comparing</secondary></indexterm>

   </sect3>


   <sect3 xml:id="exporting-a-statechart-as-an-image-file">
    <title>Exporting a statechart as an image file</title>
    <indexterm><primary>exporting a statechart as an image file</primary></indexterm>
    <indexterm><primary>statechart</primary><secondary>exporting as an image file</secondary></indexterm>
    <indexterm><primary>image file</primary><secondary>exporting a statechart as an</secondary></indexterm>

    <para>A statechart can be saved as an image file and e. g. be included in some documentation. The following 
     steps explain how to do the export.</para>

    <task>
     <title>Exporting a statechart as an image file</title>
     <procedure>

      <step>
       <para>In the statechart editor, right-click on the main region. The context menu appears.</para>

       <figure xml:id="fig_exporting_statechart_as_image_010_save_as_menu_item">
        <title>Selecting the "Save As Image File…" menu item</title>
        <mediaobject>
         <imageobject>
          <imagedata fileref="images/exporting_statechart_as_image_010_save_as_menu_item.png" align="center" width="80%" scalefit="1"/>
         </imageobject>
         <textobject>
          <phrase>Selecting the "Save As Image File…" menu item</phrase>
         </textobject>
        </mediaobject>
       </figure>
      </step>

      <step>
       <para>In the context menu, select <guimenuitem>File → Save As Image File…</guimenuitem>. The 
       <emphasis>Save As Image</emphasis> dialog appears.</para>

       <figure xml:id="fig_exporting_statechart_as_image_020_save_as_dialog">
        <title>The "Save As Image File" dialog</title>
        <mediaobject>
         <imageobject>
          <imagedata fileref="images/exporting_statechart_as_image_020_save_as_dialog.png" align="center" width="80%" scalefit="1"/>
         </imageobject>
         <textobject>
          <phrase>The "Save As Image File" dialog</phrase>
         </textobject>
        </mediaobject>
       </figure>
      </step>

      <step>
       <para>Specify the filesystem folder for the exported image file in the <emphasis>Folder</emphasis> text 
        field.</para>
      </step>

      <step>
       <para>Enter the name of the export image file into the <emphasis>File Name</emphasis> text field. The 
        file name extension depends on the selected image format (see below).</para>
      </step>

      <step>
       <para>Select the image format from the <emphasis>Image Format</emphasis> drop-down menu. 
        <application>YAKINDU Statechart Tools</application> supports the following formats:</para>

       <variablelist>

        <varlistentry>
         <term>BMP</term>
         <term>GIF</term>
         <term>PNG</term>
         <listitem><simpara>Lossless pixel image formats</simpara></listitem>
        </varlistentry>

        <varlistentry>
         <term>JPG</term>
         <term>JPEG</term>
         <listitem><simpara>Lossy pixel image format. Both JPG and JPEG essentially stand for the same image format. You 
          can specify the image quality via the <emphasis>Quality (%)</emphasis> setting.</simpara></listitem>
        </varlistentry>

        <varlistentry>
         <term>SVG</term>
         <listitem><simpara>Scalable Vector Graphics (SVG)</simpara></listitem>
        </varlistentry>

        <varlistentry>
         <term>PDF</term>
         <listitem><simpara>Portable Document Format (PDF)</simpara></listitem>
        </varlistentry>

       </variablelist>

       <para>Selecting an image format changes the export file name's extension appropriately, e. g. if the file name 
        you entered was <literal>foobar</literal>, and the you select PNG as image format, the file name will change to 
        <literal>foobar.png</literal>.</para>

       <note>
        <para>The image export functionality is subject to the capabilities of your Java runtime environment (JRE). 
        You can use only those image formats your JRE actually supports.</para>
       </note>
      </step>

      <step>
       <para>The <emphasis>Quality (%)</emphasis> text field is active for JPEG images only. JPEG is a lossy 
        format, and reducing the quality results in a smaller file size. However, due to the nature of statechart 
        images, a lossless format like PNG is most often a better choice, both in quality and in file size.</para>
      </step>

      <step>
       <para>Check <emphasis>Overwrite existing file without warning</emphasis> if you don't want to be 
        bothered by a confirmation dialog which will appear if the export file already exists.</para>
      </step>

      <step>
       <para>Check <emphasis>Export to HTML</emphasis> to create both the image file plus an HTML file to 
        include it.</para>
      </step>

     </procedure>
    </task>
   </sect3>
  </sect2>


  <sect2 xml:id="simulating-statecharts">
   <title>Simulating statecharts</title>
   <indexterm><primary>simulation</primary></indexterm>
   <indexterm><primary>statechart simulation</primary><see>simulation</see></indexterm>

   <sect3 xml:id="starting-a-simulation">
    <title>Starting a simulation</title>
    <indexterm><primary>simulation</primary><secondary>starting a</secondary></indexterm>

   </sect3>


   <sect3 xml:id="sc-simulation-perspective">
    <title>"SC Simulation" perspective</title>
    <indexterm><primary>"SC Simulation" perspective</primary></indexterm>

   </sect3>


   <sect3 xml:id="controlling-a-simulation">
    <title>Controlling a simulation</title>
    <indexterm><primary>simulation</primary><secondary>controlling a</secondary></indexterm>

   </sect3>


   <sect3 xml:id="interacting-with-a-simulation">
    <title>Interacting with a simulation</title>
    <indexterm><primary>simulation</primary><secondary>interacting with a</secondary></indexterm>

   </sect3>


   <sect3 xml:id="configuring-a-simulation">
    <title>Configuring a simulation</title>
    <indexterm><primary>simulation</primary><secondary>configuration</secondary></indexterm>

   </sect3>
  </sect2>


  <sect2 xml:id="generating-state-machine-code">
   <title>Generating state machine code</title>
    <indexterm><primary>code generation</primary></indexterm>

   <sect3 xml:id="configuring-a-generator">
    <title>Configuring a generator</title>
    <indexterm><primary>generator</primary><secondary>configuration</secondary></indexterm>
    <indexterm><primary>generator</primary><secondary>model</secondary></indexterm>

    <para>All generators can be customized by a generator model. This is a textual model in a file, specifying 
     generator features, i. e. the outlet path. The following screenshot shows a sample configuration for the Java code 
     generator.</para>

    <para>To get started with the generator model, <application>YAKINDU Statechart Tools</application> includes a 
     wizard that creates a basic configuration file with default values.</para>

    <figure>
     <title>SGen generator model with default values</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/sGenEditor.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>SGen generator model with default values</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <remark role="fixme">Explain what a "builder" is!</remark>

    <para>The generator model is associated with a builder<indexterm><primary>builder</primary></indexterm>. If 
     <emphasis>Project → Build Automatically</emphasis> is checked, the generator automatically creates its output 
     files for each modification the user makes to the statechart model. The sections below explain the specific 
     customizing features of the generator models.</para>

    <para>The following section describes the <emphasis role="strong">Core Features</emphasis> which are available for 
     all code generators.</para>


    <sect4 xml:id="Outlet" role="sgen_feature_outlet">
     <title>Outlet</title>
     <indexterm><primary>Outlet</primary><secondary>generator feature</secondary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Outlet</secondary></indexterm>

     <para>The <emphasis role="strong">Outlet</emphasis> feature specifies target project and target folder for the 
      generated artifacts. It is a <emphasis>required</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">

      <listitem>
       <para><emphasis>targetProject</emphasis><indexterm><primary>targetProject</primary></indexterm> (String, 
        required): The project to store the generated artifacts to.</para>
      </listitem>

      <listitem>
       <para><emphasis>targetFolder</emphasis><indexterm><primary>targetFolder</primary></indexterm> (String, 
        required): The folder to store the generated artifacts to. If a library folder is given, only the dynamic 
        (i. e. model-dependent artifacts) are generated into the target folder, if not all generated artifacts will be 
        generated into it. All artifacts in this folder will be overwritten during re-generation.</para>
      </listitem>

      <listitem>
       <para><emphasis>libraryTargetFolder</emphasis><indexterm><primary>libraryTargetFolder</primary></indexterm> 
        (String, optional): The folder to store the static (i. e. model-independent artifacts) to. In case this is not 
        specified, all artifacts will be generated into the target folder. All artifacts in this folder will be 
        preserved during re-generation.</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>
      
      <programlisting>
feature Outlet {
    targetProject = &quot;SampleProject&quot;
    targetFolder = &quot;src-gen&quot;
    libraryTargetFolder = &quot;src&quot;
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="LicenseHeader" role="sgen_feature_licenseheader">
     <title>LicenseHeader</title>
     <indexterm><primary>LicenseHeader</primary><secondary>generator feature</secondary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>LicenseHeader</secondary></indexterm>

     <para>The <emphasis role="strong">LicenseHeader</emphasis> feature specifies the license text to be added as a 
      header to the generated artifacts. It is an <emphasis role="strong">optional</emphasis> feature and has the 
      following parameter:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>licenseText</emphasis><indexterm><primary>licenseText</primary></indexterm> (String, required): 
        License text to be added as a file header</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>

      <programlisting>
feature LicenseHeader {
    licenseText = &quot;Copyright (c) 2012 committers of YAKINDU and others.&quot;
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="FunctionInlining" role="sgen_feature_functioninlining">
     <title>FunctionInlining</title>
     <indexterm><primary>FunctionInlining</primary><secondary>generator feature</secondary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>FunctionInlining</secondary></indexterm>

     <para>The <emphasis role="strong">FunctionInlining</emphasis> feature enables the inlining of expressions instead 
      of generating separate functions or methods. This might reduce the readability of the generated code, but 
      increases performance, because less operation calls are necessary. This is an
      <emphasis role="strong">optional</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">

      <listitem>
       <para><emphasis>inlineReactions</emphasis><indexterm><primary>inlineReactions</primary></indexterm> (Boolean, 
        optional): inlines the expression for reactions</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineEntryActions</emphasis><indexterm><primary>inlineEntryActions</primary></indexterm> 
        (Boolean, optional): inlines the expression for entry actions</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineExitActions</emphasis><indexterm><primary>inlineExitActions</primary></indexterm> 
        (Boolean, optional): inlines the expression for exit actions</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineEnterSequences</emphasis><indexterm><primary>inlineEnterSequences</primary></indexterm> 
        (Boolean, optional): inlines the expression for enter sequences</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineExitSequences</emphasis><indexterm><primary>inlineExitSequences</primary></indexterm> 
        (Boolean, optional): inlines the expression for exit sequences</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineChoices</emphasis><indexterm><primary>inlineChoices</primary></indexterm> (Boolean, 
        optional): inlines the expression for choices</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineEnterRegion</emphasis><indexterm><primary>inlineEnterRegion</primary></indexterm> 
        (Boolean, optional): inlines the expression for enter regions</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineExitRegion</emphasis><indexterm><primary>inlineExitRegion</primary></indexterm> (Boolean, 
        optional): inlines the expression for exit regions</para>
      </listitem>

      <listitem>
       <para><emphasis>inlineEntries</emphasis><indexterm><primary>inlineEntries</primary></indexterm> (Boolean, 
        optional): inlines the expression for entries</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>

     <programlisting>
feature FunctionInlining {
    inlineChoices = false
    inlineEnterRegion = true
    inlineEntries = true
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="Debug" role="sgen_feature_debug">
     <title>Debug</title>
     <indexterm><primary>Debug</primary><secondary>generator feature</secondary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Debug</secondary></indexterm>

     <para>The <emphasis role="strong">Debug</emphasis> feature dumps the execution model to the target folder as an 
      XMI model. It is an <emphasis role="strong">optional</emphasis> feature and has the following parameter:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>dumpSexec</emphasis><indexterm><primary>dumpSexec</primary></indexterm> (Boolean, required): 
        dumps the execution model as XMI model</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>

      <programlisting>
feature Debug {
    dumpSexec = true
}
</programlisting>
     </example>
    </sect4>
   </sect3>


   <sect3 xml:id="running-a-generator">
    <title>Running a generator</title>
     <indexterm><primary>running</primary><secondary>generator</secondary></indexterm>
     <indexterm><primary>generator running</primary></indexterm>

   </sect3>


   <sect3 xml:id="general-concepts-of-the-state-machine-code">
    <title>General concepts of the state machine code</title>
     <indexterm><primary>code generation</primary><secondary>general concepts</secondary></indexterm>

   </sect3>
  </sect2>


  <sect2 xml:id="c-code-generator">
   <title>C code generator</title>
    <indexterm><primary>code generator</primary><secondary>C</secondary></indexterm>
    <indexterm><primary>C</primary><secondary>code generator</secondary></indexterm>

   <sect3 xml:id="c-generator-features">
    <title>C generator features</title>
    <indexterm><primary>code generator features</primary><secondary>C</secondary></indexterm>
    <indexterm><primary>C</primary><secondary>code generator features</secondary></indexterm>

    <para>The C generator features are the same a the <link linkend="cpp-generator-features">C++ generator 
     features</link>.</para>
   </sect3>


   <sect3 xml:id="specifications-of-c-code">
    <title>Specification of C code</title>
    <indexterm><primary>specification</primary><secondary>generated code</secondary><tertiary>C</tertiary></indexterm>
    <indexterm><primary>API</primary><secondary>C</secondary></indexterm>
    <indexterm><primary>C</primary><secondary>API</secondary></indexterm>

    <para>The explanations below are using the 
     <emphasis>TrafficLight</emphasis><indexterm><primary>example</primary><secondary>TrafficLight</secondary></indexterm> 
     sample state machine to describe the API specifications of the code generated by the YAKINDU C and Java code 
     generators. The image below is showing the statechart. It models a pedestrian crossing with push-button operated 
     traffic lights ("pelican crossing”).</para>

    <figure>
     <title>The traffic light model</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/TrafficLight.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The traffic light model</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>You can checkout the C sample project
     <emphasis><link xl:href="https://github.com/Yakindu/statecharts/tree/master/examples/org.yakindu.sct.examples.c.trafficlight_">org.yakindu.sct.examples.c.trafficlight</link></emphasis>
     from the <link xl:href="https://github.com/Yakindu/statecharts"> <application>YAKINDU Statechart Tools</application>
     GitHub repository</link>. The C example contains statechart, SGen model, graphical widgets, and some glue code
     to connect the generated code with the widgets. The graphical widgets are based on Qt.</para>

    <para>To execute the C example, run the file <emphasis>org_yakindu_sct_examples_c_trafficlight_</emphasis> as
     <emphasis>Local C/C++ application</emphasis> from the Eclipse <emphasis>Run As</emphasis> context menu.</para>


    <sect4 xml:id="c-generated-code">
     <title>Generated code files</title>

     <para>You will find the generated code in the <emphasis>src-gen</emphasis> folder of the traffic light 
      example.</para>

     <para>The C code generator generates three header files. The first one is <emphasis>sc_types.h</emphasis>:</para>

     <programlisting>
#ifndef SC_TYPES_H_
#define SC_TYPES_H_

#ifdef __cplusplus
extern &quot;C&quot; {
#endif 

#include 
#include 

#define sc_string       char*

typedef bool            sc_boolean;
typedef int_fast16_t    sc_short;
typedef uint_fast16_t   sc_ushort;
typedef int32_t         sc_integer; 
typedef uint32_t        sc_uinteger; 
typedef double          sc_real;

typedef void*           sc_eventid;

#ifdef __cplusplus
}
#endif

#ifndef null
    #ifdef __cplusplus
        #define null 0
    #else
        #define null ((void *)0)
    #endif
#endif

#define bool_true true
#define bool_false false

#endif /* SC_TYPES_H_ */
</programlisting>

     <para>The header file contains some basic definitions for C++ compiler compatibility and typedefs to map the 
      YAKINDU statechart types to C types. The next header file is named after the statechart. In case of the traffic 
      light example it is called <emphasis>TrafficLightWaiting.h</emphasis>:</para>

     <programlisting>
#ifndef TRAFFICLIGHTWAITING_H_
#define TRAFFICLIGHTWAITING_H_

#include &quot;sc_types.h&quot;

#ifdef __cplusplus
extern &quot;C&quot; { 
#endif 

/*! \file Header of the state machine 'TrafficLightWaiting'.
*/

/*! Enumeration of all states */ 
typedef enum {
    TrafficLightWaiting_main_region_on,
    TrafficLightWaiting_main_region_on_r1_StreetGreen,
    TrafficLightWaiting_main_region_on_r1_PedWaiting,
    TrafficLightWaiting_main_region_on_r1_PedWaiting_r1_waitOn,
    TrafficLightWaiting_main_region_on_r1_PedWaiting_r1_waitOff,
    TrafficLightWaiting_main_region_on_r1_StreetAttention,
    TrafficLightWaiting_main_region_on_r1_StreetRed,
    TrafficLightWaiting_main_region_on_r1_PedestrianGreen,
    TrafficLightWaiting_main_region_on_r1_PedestrianRed,
    TrafficLightWaiting_main_region_on_r1_StreetPrepare,
    TrafficLightWaiting_main_region_off,
    TrafficLightWaiting_main_region_off_r1_YellowOn,
    TrafficLightWaiting_main_region_off_r1_YellowOff,
    TrafficLightWaiting_last_state
} TrafficLightWaitingStates;

/*! Type definition of the data structure for the TrafficLightWaitingIfaceTrafficLight interface scope. */
typedef struct {
    sc_boolean red;
    sc_boolean yellow;
    sc_boolean green;
} TrafficLightWaitingIfaceTrafficLight;

/*! Type definition of the data structure for the TrafficLightWaitingIfacePedestrian interface scope. */
typedef struct {
    sc_boolean request;
    sc_boolean red;
    sc_boolean green;
} TrafficLightWaitingIfacePedestrian;

/*! Type definition of the data structure for the TrafficLightWaitingIface interface scope. */
typedef struct {
    sc_boolean pedestrianRequest_raised;
    sc_boolean onOff_raised;
} TrafficLightWaitingIface;

/*! Type definition of the data structure for the TrafficLightWaitingTimeEvents interface scope. */
typedef struct {
    sc_boolean trafficLightWaiting_main_region_on_r1_PedWaiting_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_PedWaiting_r1_waitOn_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_PedWaiting_r1_waitOff_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_StreetAttention_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_StreetRed_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_PedestrianGreen_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_PedestrianRed_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_on_r1_StreetPrepare_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_off_r1_YellowOn_tev0_raised;
    sc_boolean trafficLightWaiting_main_region_off_r1_YellowOff_tev0_raised;
} TrafficLightWaitingTimeEvents;


/*! Define dimension of the state configuration vector for orthogonal states. */
#define TRAFFICLIGHTWAITING_MAX_ORTHOGONAL_STATES 1

/*! 
 * Type definition of the data structure for the TrafficLightWaiting state machine.
 * This data structure has to be allocated by the client code. 
 */
typedef struct {
    TrafficLightWaitingStates stateConfVector[TRAFFICLIGHTWAITING_MAX_ORTHOGONAL_STATES];
    sc_ushort stateConfVectorPosition; 

    TrafficLightWaitingIfaceTrafficLight ifaceTrafficLight;
    TrafficLightWaitingIfacePedestrian ifacePedestrian;
    TrafficLightWaitingIface iface;
    TrafficLightWaitingTimeEvents timeEvents;
} TrafficLightWaiting;

/*! Initializes the TrafficLightWaiting state machine data structures. Must be called before first usage.*/
extern void trafficLightWaiting_init(TrafficLightWaiting* handle);

/*! Activates the state machine */
extern void trafficLightWaiting_enter(TrafficLightWaiting* handle);

/*! Deactivates the state machine */
extern void trafficLightWaiting_exit(TrafficLightWaiting* handle);

/*! Performs a 'run to completion' step. */
extern void trafficLightWaiting_runCycle(TrafficLightWaiting* handle);

/*! Raises a time event. */
extern void trafficLightWaiting_raiseTimeEvent(const TrafficLightWaiting* handle, sc_eventid evid);

/*! Gets the value of the variable 'red' that is defined in the interface scope 'TrafficLight'. */ 
extern sc_boolean trafficLightWaitingIfaceTrafficLight_get_red(const TrafficLightWaiting* handle);
/*! Sets the value of the variable 'red' that is defined in the interface scope 'TrafficLight'. */ 
extern void trafficLightWaitingIfaceTrafficLight_set_red(TrafficLightWaiting* handle, sc_boolean value);
/*! Gets the value of the variable 'yellow' that is defined in the interface scope 'TrafficLight'. */ 
extern sc_boolean trafficLightWaitingIfaceTrafficLight_get_yellow(const TrafficLightWaiting* handle);
/*! Sets the value of the variable 'yellow' that is defined in the interface scope 'TrafficLight'. */ 
extern void trafficLightWaitingIfaceTrafficLight_set_yellow(TrafficLightWaiting* handle, sc_boolean value);
/*! Gets the value of the variable 'green' that is defined in the interface scope 'TrafficLight'. */ 
extern sc_boolean trafficLightWaitingIfaceTrafficLight_get_green(const TrafficLightWaiting* handle);
/*! Sets the value of the variable 'green' that is defined in the interface scope 'TrafficLight'. */ 
extern void trafficLightWaitingIfaceTrafficLight_set_green(TrafficLightWaiting* handle, sc_boolean value);
/*! Gets the value of the variable 'request' that is defined in the interface scope 'Pedestrian'. */ 
extern sc_boolean trafficLightWaitingIfacePedestrian_get_request(const TrafficLightWaiting* handle);
/*! Sets the value of the variable 'request' that is defined in the interface scope 'Pedestrian'. */ 
extern void trafficLightWaitingIfacePedestrian_set_request(TrafficLightWaiting* handle, sc_boolean value);
/*! Gets the value of the variable 'red' that is defined in the interface scope 'Pedestrian'. */ 
extern sc_boolean trafficLightWaitingIfacePedestrian_get_red(const TrafficLightWaiting* handle);
/*! Sets the value of the variable 'red' that is defined in the interface scope 'Pedestrian'. */ 
extern void trafficLightWaitingIfacePedestrian_set_red(TrafficLightWaiting* handle, sc_boolean value);
/*! Gets the value of the variable 'green' that is defined in the interface scope 'Pedestrian'. */ 
extern sc_boolean trafficLightWaitingIfacePedestrian_get_green(const TrafficLightWaiting* handle);
/*! Sets the value of the variable 'green' that is defined in the interface scope 'Pedestrian'. */ 
extern void trafficLightWaitingIfacePedestrian_set_green(TrafficLightWaiting* handle, sc_boolean value);
/*! Raises the in event 'pedestrianRequest' that is defined in the default interface scope. */ 
extern void trafficLightWaitingIface_raise_pedestrianRequest(TrafficLightWaiting* handle);

/*! Raises the in event 'onOff' that is defined in the default interface scope. */ 
extern void trafficLightWaitingIface_raise_onOff(TrafficLightWaiting* handle);


/*!
 * Checks if the statemachine is active (until 2.4.1 this method was used for states).
 * A statemachine is active if it was entered. It is inactive if it has not been entered at all or if it was exited.
 */
extern sc_boolean trafficLightWaiting_isActive(const TrafficLightWaiting* handle);

/*!
 * Checks if all active states are final. 
 * If there are no active states then the statemachine is considered as inactive and this method returns false.
 */
extern sc_boolean trafficLightWaiting_isFinal(const TrafficLightWaiting* handle);

/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
extern sc_boolean trafficLightWaiting_isStateActive(const TrafficLightWaiting* handle, TrafficLightWaitingStates state);

#ifdef __cplusplus
}
#endif 

#endif /* TRAFFICLIGHTWAITING_H_ */
</programlisting>

     <para>Within this header file an <literal>enum</literal> containing the state names is defined as well as data 
      structures for each of the statechart's interfaces. Additionally a structure for the statechart's time events is 
      defined. The interfaces' and time events' data structures are nested into the parent structure 
      <literal>TrafficLightWaiting</literal>. The client has to allocate this structure. It is a common parameter of 
      most methods the statechart defines. Below this structure is called the <emphasis>statechart data 
      structure</emphasis>.</para>

     <sect5 xml:id="c-fundamental-statechart-methods">
      <title>Fundamental statechart methods</title>
      <indexterm><primary>statechart methods</primary><secondary>C</secondary></indexterm>

      <para>The generated code contains fundamental methods to initialize, enter, and exit a state machine, as well as 
       a method to start a run-to-completion step.</para>

      <para>In the header file the method names are made up of the statechart name followed by the name of the 
       respective functionality. For example, the methods of the traffic light example are generated as follows:</para>

      <programlisting>
extern void trafficLightWaiting_init(TrafficLightWaiting* handle);
extern void trafficLightWaiting_enter(TrafficLightWaiting* handle);
extern void trafficLightWaiting_exit(TrafficLightWaiting* handle);
extern void trafficLightWaiting_runCycle(TrafficLightWaiting* handle);
</programlisting>

      <itemizedlist>

       <listitem>
        <para>The <literal>init()</literal><indexterm><primary>init()</primary><secondary>C</secondary></indexterm> 
         method is used to initialize the statechart data structure right after its instantiation. Variables are 
         initialized to their respective default values. If the statechart defines initialized variables, these 
         initializations are also done in the <literal>init()</literal> method.</para>
       </listitem>

       <listitem>
        <para>The <literal>enter()</literal><indexterm><primary>enter()</primary><secondary>C</secondary></indexterm> 
         method must be called to enter the state machine. It brings the state machine to a well-defined state.</para>
       </listitem>

       <listitem>
        <para>The <literal>exit()</literal><indexterm><primary>exit()</primary><secondary>C</secondary></indexterm> 
         method is used to leave a state machine statefully. If for example a history state is used in one of the top 
         regions, the last active state is stored and the state machine is left via <literal>exit()</literal>. 
         Re-entering it via <literal>enter()</literal> continues to work with the saved state.</para>
       </listitem>

       <listitem>
        <para>The 
         <literal>runCycle()</literal><indexterm><primary>runCycle()</primary><secondary>C</secondary></indexterm> 
         method is used to trigger a run-to-completion<indexterm><primary>run-to-completion</primary></indexterm> step 
         in which the state machine evaluates arising events and computes possible state changes. Somewhat simplified, 
         a run-to-completion cycle consists of the following steps:</para>

        <orderedlist numeration="arabic">
       
         <listitem>
          <para>Clear list of outgoing events.</para>
         </listitem>
       
         <listitem>
          <para>Check whether events have occurred which are leading to a state change.</para>
         </listitem>
       
         <listitem>
          <para>If a state change has to be done:</para>
       
          <orderedlist numeration="arabic">
       
           <listitem>
            <para>Execute exit actions of the present state.</para>
           </listitem>
       
           <listitem>
            <para>Save history state, if necessary.</para>
           </listitem>
       
           <listitem>
            <para>Make the new state active.</para>
            <remark role="fixme">We should also make the old state inactive, shouldn't we?</remark>
           </listitem>
       
           <listitem>
            <para>Execute entry actions of the new state.</para>
           </listitem>
       
          </orderedlist>
         </listitem>
       
         <listitem>
          <para>Clear list of incoming events.</para>
         </listitem>
       
        </orderedlist>
       </listitem>

      </itemizedlist>
     </sect5>


     <sect5 xml:id="accessing-variables-and-events">
      <title>Accessing variables and events</title>
      <indexterm><primary>variable</primary><secondary>C</secondary></indexterm>
      <indexterm><primary>event</primary><secondary>C</secondary></indexterm>

      <para>The getters and setters for each variable and event are also contained in the header file. The method names 
       are matching the following pattern:</para>

      <synopsis><varname>statechart_name</varname><literal>Iface</literal><varname>interface_name</varname><literal>_</literal>[<literal>set</literal>|<literal>get</literal>|<literal>raise</literal>]<literal>_</literal>[<varname>variable_name</varname>|<varname>event_name</varname>]</synopsis>

      <para>For example, the getter of the <varname>red</varname> variable of the <varname>pedestrian</varname> 
       interface is named 
       <literal>trafficLightWaitingIfacePedestrian_get_red(TrafficLightWaiting* handle)</literal></para>
     </sect5>
    </sect4>


    <sect4 xml:id="time-controlled-state-machines">
     <title>Time-controlled state machines</title>
     <indexterm><primary>time</primary></indexterm>
     <indexterm><primary>time-controlled state machine</primary></indexterm>
     <indexterm><primary>state machine</primary><secondary>time-controlled</secondary></indexterm>

     <para>If a statechart uses timing functionality or external operations, an additional header file is generated. 
      Its name matches the following pattern:</para>

     <synopsis><emphasis>statechart_name</emphasis><literal>Required.h</literal></synopsis>

     <para>This header file defines method hooks the client code has to implement externally.</para>

     <para>The traffic light example uses timing funtionality, namely <emphasis>after</emphasis> clauses. To support 
      time-controlled behavior, such an additional header file is generated.</para>

     <programlisting>
#ifndef TRAFFICLIGHTWAITINGREQUIRED_H_
#define TRAFFICLIGHTWAITINGREQUIRED_H_

#include &quot;sc_types.h&quot;
#include &quot;TrafficLightWaiting.h&quot;

#ifdef __cplusplus
extern &quot;C&quot; {
#endif 

/*! \file This header defines prototypes for all functions that are required by the state machine implementation.

This is a state machine uses time events which require access to a timing service. Thus the function prototypes:
    - trafficLightWaiting_setTimer and
    - trafficLightWaiting_unsetTimer
are defined.

These functions will be called during a 'run to completion step' (runCycle) of the statechart. 
There are some constraints that have to be considered for the implementation of these functions:
    - never call the statechart API functions from within these functions.
    - make sure that the execution time is as short as possible.

*/




/*!
 * This is a timed state machine that requires timer services
 */ 

/*! This function has to set up timers for the time events that are required by the state machine. */
/*! 
    This function will be called for each time event that is relevant for a state when a state will be entered.
    \param evid An unique identifier of the event.
    \time_ms The time in milli seconds
    \periodic Indicates the the time event must be raised periodically until the timer is unset 
*/
extern void trafficLightWaiting_setTimer(TrafficLightWaiting* handle, const sc_eventid evid, const sc_integer time_ms, const sc_boolean periodic);

/*! This function has to unset timers for the time events that are required by the state machine. */
/*! 
    This function will be called for each time event taht is relevant for a state when a state will be left.
    \param evid An unique identifier of the event.
*/
extern void trafficLightWaiting_unsetTimer(TrafficLightWaiting* handle, const sc_eventid evid);

#ifdef __cplusplus
}
#endif 

#endif /* TRAFFICLIGHTWAITINGREQUIRED_H_ */
</programlisting>

     <para>Basically the proper time handling has to be implemented by the developer, because timer functions generally
      depend on the hardware target used. So for each hardware target the client code must provide a method to set a 
      timer and another method to unset it. These methods have to be implemented externally and linked to the generated 
      code.</para>

     <para>The following methods are dealing with timing functionality:</para>

     <sect5 xml:id="c-settimer">
      <title>Method setTimer</title>
      <indexterm><primary>setTimer()</primary><secondary>C</secondary></indexterm>

      <para>A state machine calls the <literal>setTimer()</literal> method – short for the method's full name like e. g.
       <literal>void trafficLightWaiting_setTimer(TrafficLightWaiting* handle, const sc_eventid evid, const sc_integer 
       time_ms, const sc_boolean periodic)</literal> – to tell the timer service that it has to start a timer for the 
       given time event identifier and raise it after the period of time specified by the <emphasis>time_ms</emphasis> 
       parameter has expired. It is important to only start a timer thread or a hardware timer interrupt within the 
       <literal>setTimer()</literal> method and avoid any time-consuming operations like extensive computations, 
       sleeping or waiting. Never call the statechart API functions from within these functions! Otherwise the state 
       machine execution might hang within the timer service or might not show the expected runtime behavior.</para>

      <para>In order to have the timer service raise the time event periodically, the parameter
       <emphasis>periodic</emphasis> must be <emphasis>true</emphasis>.</para>
     </sect5>


     <sect5 xml:id="method-unsettimer">
      <title>Method unsetTimer</title>
      <indexterm><primary>unsetTimer()</primary><secondary>C</secondary></indexterm>

      <para>The state machine calls the method <literal>trafficLightWaiting_setTimer(TrafficLightWaiting* handle, const
       sc_eventid evid, const sc_integer time_ms, const sc_boolean periodic)</literal> to notify the timer service to 
       unset the timer for the given event ID.</para>
     </sect5>


     <sect5 xml:id="method-raisetimeevent">
      <title>Method raiseTimeEvent</title>
      <indexterm><primary>raiseTimeEvent()</primary><secondary>C</secondary></indexterm>

      <para>In order to notify the state machine about the occurence of a time event after a period of time has
       expired, the <literal>raiseTimeEvent()</literal> method – defined in the header file of the state machine – is 
       called on the state machine. In the case of the traffic light example it is named 
       <literal>trafficLightWaiting_raiseTimeEvent(const TrafficLightWaiting* handle, sc_eventid evid)</literal> (in 
       file <emphasis>TrafficLightWaiting.h</emphasis>).</para>

      <para>The time event is recognized by the state machine and will be processed during the next run cycle.</para>

      <para>You can conclude that in order to process the time events raised by the timing service without too much 
       latency, the runtime environment has to call the state machine's 
       <literal>runCycle()</literal><indexterm><primary>runCycle()</primary></indexterm> method as frequently as 
       needed. Consider for example a time event which is raised by the timer service after 500 ms. However, if the 
       runtime environment calls the state machine's <literal>runCycle()</literal> method with a frequency of once per 
       1000 ms only, the event will quite likely not be processed at the correct points in time.</para>
     </sect5>
    </sect4>


    <sect4 xml:id="c-operation-callbacks">
     <title>Operation callbacks</title>
     <indexterm><primary>operation callback</primary><secondary>C</secondary></indexterm>

     <para><application>YAKINDU Statechart Tools</application> support client code operations that can be used by a
      state machine and are executed as as actions. These operations have to be implemented in order to make a 
      statechart executable. The figure below shows a sample statechart using an operation:</para>

     <figure>
      <title>Specifying an operation callback in the model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/operationExample.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Specifying an operation callback in the model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Let's have a look at the generated code:</para>

     <programlisting>
#ifndef DEFAULTSMREQUIRED_H_
#define DEFAULTSMREQUIRED_H_

#include &quot;sc_types.h&quot;
#include &quot;DefaultSM.h&quot;

#ifdef __cplusplus
extern &quot;C&quot; {
#endif 

/*! \file This header defines prototypes for all functions that are required by the state machine implementation.

This state machine makes use of operations declared in the state machines interface or internal scopes. Thus the function prototypes:
    - defaultSMIfaceSample_myOperation
are defined.

These functions will be called during a 'run to completion step' (runCycle) of the statechart. 
There are some constraints that have to be considered for the implementation of these functions:
    - never call the statechart API functions from within these functions.
    - make sure that the execution time is as short as possible.

*/
extern sc_integer defaultSMIfaceSample_myOperation(DefaultSM* handle, const sc_integer p1, const sc_boolean p2);


#ifdef __cplusplus
}
#endif 

#endif /* DEFAULTSMREQUIRED_H_ */
</programlisting>

     <para>An additional method <literal>sc_integer defaultSMIfaceSample_myOperation(DefaultSM* handle,
      const sc_integer p1, const sc_boolean p2)</literal> has been generated. This method has to be implemented and 
      linked with the generated code, so that the state machine can use it.</para>
    </sect4>


    <sect4 xml:id="c-integrating-generated-code">
     <title>Integrating generated code</title>
     <indexterm><primary>integration</primary><secondary>generated code</secondary><tertiary>C</tertiary></indexterm>

     <para>To get a clue how to integrate a generated C state machines with your project have a look at the 
      <literal>main.cpp</literal> file and its <literal>main()</literal> method:</para>

     <programlisting>
#include &quot;org_yakindu_sct_examples_c_trafficlight.h&quot;

#include 
#include 
#include &quot;src-gen/sc_types.h&quot;
#include &quot;src-gen/TrafficLightWaiting.h&quot;
#include &quot;statemachine/TrafficLightTimer.h&quot;
#include &quot;statemachine/TrafficLightRunner.h&quot;

TrafficLightTimer *timer;

int main(int argc, char *argv[]) {
    TrafficLightWaiting handle;
    trafficLightWaiting_init(&amp;handle);
    timer = new TrafficLightTimer(&amp;handle);
    trafficLightWaiting_enter(&amp;handle);
    QApplication a(argc, argv);
    TrafficLightRunner *runner = new TrafficLightRunner(&amp;handle, 100);
    org_yakindu_sct_examples_c_trafficlight w(0, runner);
    w.show();
    int ret = a.exec();
    return ret;
}

void trafficLightWaiting_setTimer(const sc_eventid evid,
        const sc_integer time_ms, const sc_boolean periodic) {
    timer-&gt;setTimer(evid, time_ms, periodic);
}

void trafficLightWaiting_unsetTimer(const sc_eventid evid) {
    timer-&gt;unsetTimer(evid);
}
</programlisting>

     <para>First an instance of the statechart data structure is created and initialized by the 
     <literal>trafficLightWaiting_init(&amp;handle)</literal> method. The next step instantiates the timer. The class 
     <literal>TrafficLightTimer</literal> represents an implementation of a timer service and uses the timer 
     functionality of the Qt framework. The <literal>TrafficLightRunner</literal> is a runtime service which executes a 
     run-to-completion step of the state machine every 100 ms. The runner class and the GUI are wired in the class 
     <literal>org_yakindu_sct_examples_c_trafficlight</literal>:</para>

     <programlisting>
#include &quot;org_yakindu_sct_examples_c_trafficlight.h&quot;

org_yakindu_sct_examples_c_trafficlight::org_yakindu_sct_examples_c_trafficlight(
        QWidget *parent, TrafficLightRunner *runner) :
        QMainWindow(parent) {

    ui.setupUi(this);
    crossing = new CrossingWidget(this);

    trafficLight = new TrafficLightWidget(crossing);
    trafficLight-&gt;setGeometry(275, 75, 30, 90);

    pedestrianLight = new PedestrianLightWidget(crossing);
    pedestrianLight-&gt;setGeometry(50, 10, 70, 20);

    connect(runner, SIGNAL(cycleDone(TrafficLightWaiting*)), this, SLOT(update(TrafficLightWaiting*)));

    pedestrianReq = new QPushButton(&quot;pedestrian request&quot;, this);
    pedestrianReq-&gt;setGeometry(1, 365, 150, 30);
    connect(pedestrianReq, SIGNAL(released()), runner, SLOT(raisePedestrianRequest()));


    off = new QPushButton(&quot;off / on&quot;, this);
    off-&gt;setGeometry(249, 365, 150, 30);
    connect(off, SIGNAL(released()), runner, SLOT(raiseOnOff()));
}

void org_yakindu_sct_examples_c_trafficlight::update(
        TrafficLightWaiting *handle) {
    trafficLight-&gt;setSignals(handle-&gt;ifaceTrafficLight.red,
            handle-&gt;ifaceTrafficLight.yellow, handle-&gt;ifaceTrafficLight.green);
    pedestrianLight-&gt;setSignals(handle-&gt;ifacePedestrian.request,
            handle-&gt;ifacePedestrian.red, handle-&gt;ifacePedestrian.green);
    QMainWindow::update();
}

org_yakindu_sct_examples_c_trafficlight::~org_yakindu_sct_examples_c_trafficlight() {

}
</programlisting>
    </sect4>
   </sect3>
  </sect2>


  <sect2 xml:id="cpp-code-generator">
   <title>C++ code generator</title>
   <indexterm><primary>code generator</primary><secondary>C++</secondary></indexterm>
   <indexterm><primary>C++</primary><secondary>code generator</secondary></indexterm>

   <sect3 xml:id="cpp-generator-features">
    <title>C++ generator features</title>
     <indexterm><primary>code generator features</primary><secondary>C++</secondary></indexterm>
     <indexterm><primary>C++</primary><secondary>code generator features</secondary></indexterm>

    <sect4 xml:id="identifiersettings" role="sgen_feature_identifiersettings">
     <title>IdentifierSettings</title>
     <indexterm><primary>IdentifierSettings</primary><secondary>generator feature</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>IdentifierSettings</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>IdentifierSettings</primary><secondary>generator feature</secondary><tertiary>C</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>IdentifierSettings</secondary><tertiary>C</tertiary></indexterm>

     <para>The <emphasis role="strong">IdentifierSettings</emphasis> feature allows the configuration of module names
      and identifier character length:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>moduleName</emphasis><indexterm><primary>moduleName</primary></indexterm> (String, optional):
        name for header and implementation, default: statechart name</para>
      </listitem>
      <listitem>
       <para><emphasis>statemachinePrefix</emphasis><indexterm><primary>statemachinePrefix</primary></indexterm>
        (Boolean, optional): prefix which is prepended to function, state, and type names.</para>
      </listitem>
      <listitem>
       <para><emphasis>maxIdentifierLength</emphasis><indexterm><primary>maxIdentifierLength</primary></indexterm>
        (Integer, optional): maximum number of characters of an identifier, default: 31 characters, which is complying 
        with the ANSI C99 standard.</para>
      </listitem>
      <listitem>
       <para><emphasis>separator</emphasis><indexterm><primary>separator</primary></indexterm> (String, optional):
        character to replace whitespace and otherwise illegal characters in manes.</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration:</title>

     <programlisting>
feature IdentifierSettings {
    moduleName =  &quot;MyStatechart&quot; 
    statemachinePrefix =  &quot;myStatechart&quot; 
    maxIdentifierLength = 31
    separator =  &quot;_&quot; 
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="tracing" role="sgen_feature_tracing">
     <title>Tracing</title>
     <indexterm><primary>Tracing</primary><secondary>generator feature</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Tracing</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>Tracing</primary><secondary>generator feature</secondary><tertiary>C</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Tracing</secondary><tertiary>C</tertiary></indexterm>

     <para>The <emphasis role="strong">Tracing</emphasis> feature enables the generation of tracing callback 
      functions:</para>

     <itemizedlist>

      <listitem>
       <para><emphasis>enterState</emphasis><indexterm><primary>enterState</primary></indexterm> (boolean, optional):
        specifies whether to generate a callback function that is used to notify about state entering events</para>
      </listitem>

      <listitem>
       <para><emphasis>exitState</emphasis><indexterm><primary>exitState</primary></indexterm> (boolean, optional):
        specifies whether to generate a callback that is used to notify about state exiting events.</para>
      </listitem>

     </itemizedlist>

     <example>
      <title>Sample configuration</title>

      <programlisting>feature Tracing {
 enterState = true 
 exitState  = true
}</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="generatoroptions" role="sgen_feature_generatoroptions">
     <title>GeneratorOptions</title>
     <indexterm><primary>GeneratorOptions</primary><secondary>generator feature</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>GeneratorOptions</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>GeneratorOptions</primary><secondary>generator feature</secondary><tertiary>C</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>GeneratorOptions</secondary><tertiary>C</tertiary></indexterm>

     <para>The <emphasis role="strong">GeneratorOptions</emphasis> feature allows to change the behavior of the C++ 
      generator:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>innerFunctionVisibility</emphasis><indexterm><primary>innerFunctionVisibility</primary></indexterm> 
        (String, optional): This parameter is used to change the visibility of inner functions and variables. By 
        default <literal>private</literal> visibility is used. It can be changed to <literal>protected</literal> to 
        allow function overriding for a class which inherits from the generated state machine base class.</para>
      </listitem>
      <listitem>
       <para><emphasis>staticOperationCallback</emphasis><indexterm><primary>staticOperationCallback</primary></indexterm> 
        (Boolean, optional): If this parameter is set to <emphasis>true</emphasis>, the callback function declaration 
        for statechart operations is static and the functions are called statically by the state machine code.</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>

     <programlisting>
feature GeneratorOptions {
    innerFunctionVisibility =  &quot;protected&quot;
    staticOperationCallback = true
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="junitwrapper" role="sgen_feature_junitwrapper">
     <title>JUnitWrapper</title>
     <indexterm><primary>JUnitWrapper</primary><secondary>generator feature</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>JUnitWrapper</secondary><tertiary>C++</tertiary></indexterm>
     <indexterm><primary>JUnitWrapper</primary><secondary>generator feature</secondary><tertiary>C</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>JUnitWrapper</secondary><tertiary>C</tertiary></indexterm>

     <remark role="fixme">This is quite likely a Java feature, at least JUnit is.</remark>

     <para>Using the <emphasis>JUnitWrapper</emphasis> feature, it is possible to create JUnit tests that will run the
      generated gtests<remark role="fixme">What a gtests?</remark>.</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>WrapToJUnit</emphasis><indexterm><primary>WrapToJUnit</primary></indexterm> (Boolean): This parameter determines whether a JUnit wrapper test is to be generated <constant>(true)</constant> or not <constant>(false)</constant>.</para>
      </listitem>
     </orderedlist>
     
     <example>
      <title>Sample configuration</title>

      <programlisting>
feature JUnitWrapper {
    WrapToJUnit =  &quot;false&quot; 
}
</programlisting>
     </example>
    </sect4>
   </sect3>


   <sect3 xml:id="cpp-code-specification">
    <title>Specification of C++ code</title>
    <indexterm><primary>specification</primary><secondary>generated code</secondary><tertiary>C++</tertiary></indexterm>
    <indexterm><primary>API</primary><secondary>C++</secondary></indexterm>
    <indexterm><primary>C++</primary><secondary>API</secondary></indexterm>

    <para>The explanations below are using the
     <emphasis>TrafficLight</emphasis><indexterm><primary>example</primary><secondary>traffic light</secondary></indexterm> 
     sample state machine to describe the API specifications of the code generated by the YAKINDU C and Java code 
     generators. The image below is showing the statechart. It models a pedestrian crossing with push-button operated 
     traffic lights ("pelican crossing”).</para>

    <figure>
     <title>The traffic light model</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/TrafficLight.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The traffic light model</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>You can checkout the C++ sample project
     <link xl:href="http://svn.codespot.com/a/eclipselabs.org/yakindu/SCT2/trunk/examples">QtTrafficLightCpp</link> 
     from the <link xl:href="http://svn.codespot.com/a/eclipselabs.org/yakindu/SCT2/trunk">YAKINDU Google Code 
     repository</link>. The C++ example contains statechart, SGen model, graphical widgets, and some glue code to 
     connect the generated code with the widgets. The graphical widgets are based on Qt.</para>

    <remark role="fixme">C: To execute the C example, run the file _org_yakindu_sct_examples_c_trafficlight_ as 
     &quot;Local C/C\+\+ application&quot; from the Eclipse _Run As_ context menu.</remark> 

    <sect4 xml:id="cpp-generated-code">
     <title>Generated code files</title>

     <para>You will find the generated code in the <emphasis>src-gen</emphasis> folder of the traffic light
      example.</para>

     <para>The <emphasis>StatemachineInterface.h</emphasis> header file defines the fundamental state machine interface
      methods. This file also contains the definition of the abstract class <literal>StatemachineInterface</literal> 
      which contains pure virtual functions only. It is needed by each particular state machine and is independend from 
      concrete ones.</para>
    </sect4>


    <sect4 xml:id="cpp-statemachine-class">
     <title>Statemachine class</title>
     <indexterm><primary>C++</primary><secondary>Statemachine class</secondary></indexterm>

     <para>The state machine source code is generated as a C++ class with the same name as the statechart. For example,
      if the statechart is named <emphasis>DefaultSM</emphasis> the C++ class will also be called
       <emphasis>DefaultSM</emphasis> and will be generated as the source code file
        <emphasis>DefaultSM.cpp</emphasis>.</para>
    </sect4>


    <sect4 xml:id="cpp-abstract-class-statemachineinterface">
     <title>Abstract class StatemachineInterface</title>
     <indexterm><primary>C++</primary><secondary>StatemachineInterface class</secondary></indexterm>

     <para>Each generated state machine implements the interface <literal>StatemachineInterface</literal>:</para>

     <programlisting>
#ifndef STATEMACHINEINTERFACE_H_
#define STATEMACHINEINTERFACE_H_

/*
 * Basic interface for statemachines.
 */
class StatemachineInterface {
    public:

        virtual ~StatemachineInterface() = 0;

        /*
        * Initializes the statemachine. Use to init internal variables etc.
        */
        virtual void init() = 0;

        /*
        * Enters the statemachine. Sets the statemachine in a defined state.
        */
        virtual void enter() = 0;

        /*
        * Exits the statemachine. Leaves the statemachine with a defined state.
        */
        virtual void exit() = 0;

        /*
        * Start a run-to-completion cycle.
        */
        virtual void runCycle() = 0;

        /*
        * Checks if the statemachine is active. 
        * A statemachine is active if it was entered. It is inactive if it has not been entered at all or if it was exited.
        */ 
        virtual sc_boolean isActive() = 0;

        /*
        * Checks if all active states are final. 
        * If there are no active states then the statemachine is considered as inactive and this method returns false.
        */
        virtual sc_boolean isFinal() = 0;
};

inline StatemachineInterface::~StatemachineInterface() {}

#endif /* STATEMACHINEINTERFACE_H_ */
</programlisting>

     <sect5 xml:id="cpp-fundamental-statechart-methods">
      <title>Fundamental statechart methods</title>
      <indexterm><primary>statechart methods</primary><secondary>C++</secondary></indexterm>

      <para>The generated code contains fundamental methods to initialize, enter, and exit a state machine, as well as
       a method to start a run-to-completion step.</para>

      <para>The <literal>StatemachineInterface</literal> interface specifies the four functions
       <literal>init()</literal>, <literal>enter()</literal>, <literal>exit()</literal> and 
       <literal>runCycle()</literal>.</para>

      <itemizedlist>
       <listitem>
        <para>The <literal>init()</literal><indexterm><primary>init()</primary><secondary>C++</secondary></indexterm>
         function is used to initialize the internal objects of the state machine right after its instantiation. 
         Variables are initialized to their respective default values. If the statechart defines initialized variables, 
         these initializations are also done in the <literal>init()</literal> function.</para>
       </listitem>
       <listitem>
        <para>The <literal>enter()</literal><indexterm><primary>enter()</primary><secondary>C++</secondary></indexterm>
         function must be called to enter the state machine. It brings the state machine to a well-defined state.</para>
       </listitem>
       <listitem>
        <para>The <literal>exit()</literal><indexterm><primary>exit()</primary><secondary>C++</secondary></indexterm>
         function is used to leave a state machine statefully. If for example a history state is used in one of the top 
         regions, the last active state is stored and the state machine is left via <literal>exit()</literal>. 
         Re-entering it via <literal>enter()</literal> continues to work with the saved state.</para>
       </listitem>
       <listitem>
        <para>The
         <literal>runCycle()</literal><indexterm><primary>runCycle()</primary><secondary>C++</secondary></indexterm> 
         function is used to trigger a run-to-completion step in which the state machine evaluates arising events and 
         computes possible state changes. Somewhat simplified, a run-to-completion cycle consists of the following 
         steps:</para>

        <orderedlist numeration="arabic">
         <listitem>
          <para>Clear list of outgoing events.</para>
         </listitem>
         <listitem>
          <para>Check whether events have occurred which are leading to a state change.</para>
         </listitem>
         <listitem>
          <para>If a state change has to be done:</para>
          <orderedlist numeration="arabic">
           <listitem>
            <para>Execute exit actions of the present state.</para>
           </listitem>
           <listitem>
            <para>Save history state, if necessary.</para>
           </listitem>
           <listitem>
            <para>Make the new state active.</para>
            <remark role="fixme">We should also make the old state inactive, shouldn't we?</remark>
           </listitem>
           <listitem>
            <para>Execute entry actions of the new state.</para>
           </listitem>
          </orderedlist>
         </listitem>
         <listitem>
          <para>Clear list of incoming events.</para>
         </listitem>
        </orderedlist>
       </listitem>
      </itemizedlist>
     </sect5>
    </sect4>


    <sect4 xml:id="cpp-time-controlled-state-machines">
     <title>Time-controlled state machines</title>
     <indexterm><primary>time</primary></indexterm>
     <indexterm><primary>time-controlled state machine</primary></indexterm>
     <indexterm><primary>state machine</primary><secondary>time-controlled</secondary></indexterm>

     <para>If a statechart uses timing functionality, additional classes are generated.</para>

     <para>The traffic light example uses timing funtionality, namely <emphasis>after</emphasis> clauses. To support
      time-controlled behavior, the abstract classes 
      <literal>TimedStatemachineInterface</literal><indexterm><primary>TimedStatemachineInterface</primary><secondary>C++</secondary></indexterm>
      and 
      <literal>TimerInterface</literal><indexterm><primary>TimerInterface</primary><secondary>C++</secondary></indexterm>
      are generated.</para>

     <para>The <literal>TimedStatemachineInterface</literal> interface extends the generated state machine by a
      <literal>TimerInterface</literal> data member. The client code must provide an implementation of that 
      interface.</para>

     <para><literal>TimedStatemachineInterface</literal> also specifies the callback function
      <literal>raiseTimeEvent(sc_eventid event)</literal><indexterm><primary>raiseTimeEvent()</primary><secondary>C++</secondary></indexterm>,
      enabling the timer service to raise time events.</para>

     <programlisting>
#ifndef TIMEDSTATEMACHINEINTERFACE_H_
#define TIMEDSTATEMACHINEINTERFACE_H_

#include &quot;sc_types.h&quot;
#include &quot;TimerInterface.h&quot;

/*
* Interface for state machines which use timed event triggers.
*/
class TimedStatemachineInterface {
    public:

        virtual ~TimedStatemachineInterface() = 0;

        /*
        * Set the ITimerService for the state machine. It must be set
        * externally on a timed state machine before a run cycle can be correct
        * executed.
        */
        virtual void setTimer(TimerInterface* timer) = 0;

        /*
        * Returns the currently used timer service.
        */
        virtual TimerInterface* getTimer() = 0;

        /*
        * Callback method if a time event occurred.
        */
        virtual void raiseTimeEvent(sc_eventid event) = 0;
};

inline TimedStatemachineInterface::~TimedStatemachineInterface() {}

#endif /* TIMEDSTATEMACHINEINTERFACE_H_ */
</programlisting>

     <para>Basically the proper time handling has to be implemented by the developer, because timer functions generally
      depend on the hardware target used. So for each hardware target a timer service class implementing the 
      <literal>TimerInterface</literal> interface has to be developed.</para>

     <para>Let's have a look at the <literal>TimerInterface</literal> interface:</para>

     <programlisting>
#ifndef TIMERINTERFACE_H_
#define TIMERINTERFACE_H_

#include &quot;sc_types.h&quot;

//forward declaration of TimedStatemachineInterface to avoid cyclic dependency
class TimedStatemachineInterface;

/*
 * Basic interface for statemachines.
 */
class TimerInterface {
    public:

        virtual ~TimerInterface() = 0;

        /*
         * Starts the timing for a time event.
         */ 
        virtual void setTimer(TimedStatemachineInterface* statemachine, sc_eventid event, sc_integer time, sc_boolean isPeriodic) = 0;

        /*
         * Unsets the given time event.
         */
        virtual void unsetTimer(TimedStatemachineInterface* statemachine, sc_eventid event) = 0;

        /*
         * Cancel timer service. Use this to end possible timing threads and free
         * memory resources.
         */
        virtual void cancel() = 0;
};

inline TimerInterface::~TimerInterface() {}

#endif /* TIMERINTERFACE_H_ */
</programlisting>

     <para>The <literal>TimerInterface</literal> interface defines the following functions dealing with timing
      functionality:</para>

     <sect5 xml:id="cpp-settimer">
      <title>Function setTimer</title>
      <indexterm><primary>setTimer()</primary><secondary>C++</secondary></indexterm>

      <para>A state machine calls the <literal>setTimer(TimedStatemachineInterface* statemachine, sc_eventid event,
       sc_integer time, sc_boolean isPeriodic)</literal> function to tell the timer service that it has to start a 
       timer for the given time event and raise it after the period of time specified by the <emphasis>time</emphasis> 
       parameter has expired. It is important to only start a timer thread or a hardware timer interrupt within the 
       <literal>setTimer()</literal> function and to avoid any time-consuming operations like extensive computations, 
       <literal>Thread.sleep(…)</literal> or waiting. Otherwise the state machine execution might hang within the timer 
       service or might not show the expected runtime behavior.</para>

      <para>In order to have the timer service raise the time event periodically, the parameter 
      <emphasis>isPeriodic</emphasis> must be <emphasis>true</emphasis>.</para>
     </sect5>


     <sect5 xml:id="cpp-unsettimer">
      <title>Function unsetTimer</title>
      <indexterm><primary>unsetTimer()</primary><secondary>C++</secondary></indexterm>

      <para>The state machine calls the function <literal>unsetTimer(TimedStatemachineInterface* statemachine, 
       sc_eventid event)</literal> to notify the timer service to unset the timer for the given event ID.</para>
     </sect5>


     <sect5 xml:id="cpp-raisetimeevent">
      <title>Function raiseTimeEvent</title>
      <indexterm><primary>raiseTimeEvent()</primary><secondary>C++</secondary></indexterm>

      <para>In order to notify the state machine about the occurence of a time event after a period of time has expired,
       the function <literal>raiseTimeEvent(sc_eventid event)</literal> must be called on the state machine. For this 
       purpose, the state machine must implement the <literal>TimedStatemachineInterface</literal>) interface.</para>

      <para>The time event is recognized by the state machine and will be processed during the next run cycle.</para>

      <para>You can conclude that in order to process the time events raised by the timing service without too much
       latency, the runtime environment has to call the state machine's <literal>runCycle()</literal> function as 
       frequently as needed. Consider for example a time event which is raised by the timer service after 500 ms. 
       However, if the runtime environment calls the state machine's <literal>runCycle()</literal> function with a 
       frequency of once per 1000 ms only, the event will quite likely not be processed at the correct points in 
       time.</para>
     </sect5>
    </sect4>


    <sect4 xml:id="cpp-accessing">
     <title>Accessing interfaces, variables and events</title>
     <indexterm><primary>interface</primary><secondary>C++</secondary></indexterm>
     <indexterm><primary>variable</primary><secondary>C++</secondary></indexterm>
     <indexterm><primary>event</primary><secondary>C++</secondary></indexterm>

     <para>In a YAKINDU statechart, variables and events are contained in so-called <emphasis>interfaces</emphasis>.
      There can be at most one default, unnamed interface plus zero or more named interfaces. In the generated C++ 
      code, these interfaces can be found as internal subclasses of the main state machine class. This outer class' 
      name is derived from the statechart's name while the internal subclasses' names are derived from the respective 
      names of the statechart interfaces.</para>

     <para>Let's have a look at the following sample statechart interface declaration of a statechart named
      <emphasis>DefaultSM</emphasis>:</para>

     <programlisting>
interface Sample:
    var a:boolean
    in event evA:boolean
    out event evB:integer
</programlisting>

     <para>The generated interface code is shown below. Since the statechart's name is <emphasis>DefaultSM</emphasis>
      the state machine class' name is also <emphasis>DefaultSM</emphasis>, to be found in the 
      <emphasis>DefaultSM.h</emphasis> file. The following is a snippet from that file.</para>

     <programlisting>
        //! Inner class for Sample interface scope.
        class SCI_Sample {

            public:
                /*! Gets the value of the variable 'a' that is defined in the interface scope 'Sample'. */ 
                sc_boolean get_a();

                /*! Sets the value of the variable 'a' that is defined in the interface scope 'Sample'. */ 
                void set_a(sc_boolean value);

                /*! Raises the in event 'evA' that is defined in the interface scope 'Sample'. */ 
                void raise_evA(sc_boolean value);

                /*! Checks if the out event 'evB' that is defined in the interface scope 'Sample' has been raised. */ 
                sc_boolean isRaised_evB();

                /*! Gets the value of the out event 'evB' that is defined in the interface scope 'Sample'. */ 
                sc_integer get_evB_value();


            private:
                friend class DefaultSM;
                sc_boolean a;
                sc_boolean evA_raised;
                sc_boolean evA_value;
                sc_boolean evB_raised;
                sc_integer evB_value;
        };
</programlisting>

     <para>A statechart interface is generated as an internal subclass within the state machine class. The subclass' name is derived from the statechart interface's name by prepending the string <literal>SCI_</literal>.</para>

     <para>A special case is the unnamed statechart interface: It is generated as the C++ subclass <literal>SCInterface</literal>.</para>

     <para>An incoming event <emphasis>evA:boolean</emphasis> is generated as the raise function <literal>raise_evA(boolean value)</literal>. Since the event is of type <emphasis>boolean</emphasis> the function has a <emphasis>boolean</emphasis> parameter.</para>

     <para>For an outgoing event <emphasis>evB:integer</emphasis> the functions <literal>isRaised_evB()</literal> and <literal>get_evB_value()</literal> are generated. The former can be used to determine whether the event has already been raised by the state machine or not. The latter serves to query the value of the event.</para>

     <para>For variables, the code generator creates getter and setter functions, here <literal>sc_boolean get_a()</literal> and <literal>void set_a(sc_boolean value)</literal>.</para>

     <para>The code generator also creates appropriately named getter functions in the enclosing class which can be used to acquire the inner classes, here: <literal>SCI_Sample* getSCI_Sample()</literal>.</para>

     <para>The nesting class is the generated state machine source code. It holds instances of the nested interface class implementations and provides them via getter functions. Have a look at (some snippets of) the source code generated for the <emphasis>Sample</emphasis> statechart interface:</para>

     <programlisting>
void DefaultSM::SCI_Sample::raise_evA(sc_boolean value) {
    evA_value = value;
    evA_raised = true;
}

sc_boolean DefaultSM::SCI_Sample::isRaised_evB() {
    return evB_raised;
}

sc_integer DefaultSM::SCI_Sample::get_evB_value() {
    return evB_value;
}


sc_boolean DefaultSM::SCI_Sample::get_a() {
    return a;
}

void DefaultSM::SCI_Sample::set_a(sc_boolean value) {
    a = value;
}
</programlisting>

     <para>The value of an event can be accessed only if the event has been processed in a run-to-completion step. Otherwise the event could contain an illegal value.</para>

     <remark role="decide">
      In Java we have a section "Interface observers". What about a C++ equivalent?
     </remark>
    </sect4>


    <sect4 xml:id="cpp-operation-callbacks">
     <title>Operation callbacks</title>
     <indexterm><primary>operation callback</primary><secondary>C++</secondary></indexterm>

     <para><application>YAKINDU Statechart Tools</application> support client code operations that can be used by a
      state machine and are executed as as actions. These operations have to be implemented in order to make a 
      statechart executable. The figure below shows a sample statechart using an operation:</para>

     <figure>
      <title>Specifying an operation callback in the model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/operationExample.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Specifying an operation callback in the model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Let's have a look at the additionally generated code for operation support in the <emphasis>DefaultSM.h</emphasis> header file:</para>

     <programlisting>
                //! Inner class for Sample interface scope operation callbacks.
                class SCI_Sample_OCB {
                    public:
                        virtual ~SCI_Sample_OCB() = 0;

                        virtual sc_integer myOperation(sc_integer p1, sc_boolean p2) = 0;
                };

                /*! Set the working instance of the operation callback interface 'SCI_Sample_OCB'. */
                void setSCI_Sample_OCB(SCI_Sample_OCB* operationCallback);
</programlisting>

     <para>An additional interface <literal>SCI_Sample_OCB</literal> with the pure virtual function <literal>sc_integer myOperation(sc_integer p1, sc_boolean p2)</literal> has been generated. This interface has to be implemented, and an instance of the implementing class has to be provided to the state machine via the <literal>setSCI_Sample_OCB(SCI_Sample_OCB* operationCallback)</literal> function, so that the state machine can use it.</para>

     <programlisting>
#include &quot;DefaultSM.h&quot;

sc_integer DefaultSM::SCI_Sample_OCB::myOperation(sc_integer p1, sc_boolean p2) {
    // Your operation code should be placed here;
    return 0;
}

int main(int argc, char *argv[]) {
    DefaultSM *defaultSM = new DefaultSM();
    SCI_Sample_OCB *sci_Sample_OCB = new SCI_Sample_OCB();

    defaultSM-&gt;setSCI_Sample_OCB(sci_Sample_OCB);

    defaultSM-&gt;init();
    defaultSM-&gt;enter();
    defaultSM-&gt;runCycle();
}
</programlisting>

     <remark>Chapter "Integrating generated code" is available for Java and C, but missing for C++.</remark>
    </sect4>
   </sect3>
  </sect2>


  <sect2 xml:id="java-code-generator">
   <title>Java code generator</title>
    <indexterm><primary>code generator</primary><secondary>Java</secondary></indexterm>
    <indexterm><primary>Java</primary><secondary>code generator</secondary></indexterm>

   <sect3 xml:id="java-generator-features">
    <title>Java generator features</title>
    <indexterm><primary>code generator features</primary><secondary>Java</secondary></indexterm>
    <indexterm><primary>Java</primary><secondary>code generator features</secondary></indexterm>


    <sect4 xml:id="naming-feature" role="sgen_feature_naming">
     <title>Naming feature</title>
     <indexterm><primary>Naming</primary><secondary>generator feature</secondary><tertiary>Java</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Naming</secondary><tertiary>Java</tertiary></indexterm>

     <para>The <emphasis role="strong">Naming</emphasis> feature allows the configuration of package names as well as
      class name prefix / suffix.</para>
      
     <para>It is an <emphasis role="strong">optional</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>basePackage</emphasis><indexterm><primary>basePackage</primary></indexterm> (Boolean, required):
        The package to create for the generated java classes</para>
      </listitem>
      <listitem>
       <para><emphasis>implementationSuffix</emphasis><indexterm><primary>implementationSuffix</primary></indexterm> 
        (Boolean, optional): The suffix for the implementing classes</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>

      <programlisting>
feature Naming {
    basePackage = &quot;org.yakindu.sct&quot;
    implementationSuffix = &quot;Impl&quot;
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="synchronizedwrapper-feature" role="sgen_feature_synchronizedwrapper">
     <title>SynchronizedWrapper feature</title>
     <indexterm><primary>SynchronizedWrapper</primary><secondary>generator feature</secondary><tertiary>Java</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Naming</secondary><tertiary>Java</tertiary></indexterm>

     <para>The <emphasis role="strong">SynchronizedWrapper</emphasis> feature generates a synchronized wrapper for the
      state machine. This is an additional Java class providing thread-safe access to the generated state machine
      implementation. As the wrapper adds thread safety any number of client threads may call the state machine.</para>
     
     <para>It is an <emphasis role="strong">optional</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>namePrefix</emphasis><indexterm><primary>namePrefix</primary></indexterm> (String, optional):
        name prefix for the generated wrapper class</para>
      </listitem>
      <listitem>
       <para><emphasis>nameSuffix</emphasis><indexterm><primary>nameSuffix</primary></indexterm> (String, optional):
        name suffix for the generated wrapper class</para>
      </listitem>
     </orderedlist>
      
     <example>
      <title>Sample configuration</title>

      <programlisting>
feature SynchronizedWrapper {
    namePrefix = "Synchronized"
    nameSuffix = "Wrapper"
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="runnablewrapper" role="sgen_feature_runnablewrapper">
     <title>RunnableWrapper</title>
     <indexterm><primary>RunnableWrapper</primary><secondary>generator feature</secondary><tertiary>Java</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>RunnableWrapper</secondary><tertiary>Java</tertiary></indexterm>

     <para>The <emphasis role="strong">RunnableWrapper</emphasis> feature generates a runnable wrapper for the state
      machine. This is an additional Java class providing a thread-safe wrapper for the generated state machine
      implementation. In addition to the specific state machine interface it implements the
      <emphasis>Runnable</emphasis> interface and can be executed in a thread. It implements an event queue and
      event-driven execution semantics. As the wrapper adds thread safety any number of client threads may call the
      state machine.</para>

     <para>It is an <emphasis role="strong">optional</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>namePrefix</emphasis><indexterm><primary>namePrefix</primary></indexterm> (String, optional):
        name prefix for the generated wrapper class</para>
      </listitem>
      <listitem>
       <para><emphasis>nameSuffix</emphasis><indexterm><primary>nameSuffix</primary></indexterm> (String, optional):
        name suffix for the generated wrapper class</para>
      </listitem>
     </orderedlist>
      
     <example>
      <title>Sample configuration</title>

      <programlisting>
feature RunnableWrapper {
    namePrefix = "Runnable"
    nameSuffix = "Wrapper"
}
</programlisting>
     </example>
    </sect4>


    <sect4 xml:id="GeneralFeatures" role="sgen_feature_generalfeatures">
     <title>GeneralFeatures</title>
     <indexterm><primary>GeneralFeatures</primary><secondary>generator feature</secondary><tertiary>Java</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>GeneralFeatures</secondary><tertiary>Java</tertiary></indexterm>

     <para>The <emphasis role="strong">GeneralFeatures</emphasis> feature allows to configure additional services to be
      generated along with the state machine. Per default, all parameters are <emphasis>false</emphasis>. It is an 
      <emphasis role="strong">optional</emphasis> feature and has the following parameters:</para>

     <!-- # __EventBasedStatemachine__ (Boolean, optional): enables/disables the generation of a cycle based state machine implementation -->

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>InterfaceObserverSupport</emphasis><indexterm><primary>InterfaceObserverSupport</primary></indexterm> (Boolean, optional): enables/disables the generation of listener interfaces for the state machine</para>
      </listitem>
      <listitem>
       <para><emphasis>RuntimeService</emphasis><indexterm><primary>RuntimeService</primary></indexterm> (Boolean, optional): enables/disables the generation of a runtime service that triggers the run cycle of a cycle-based state machine</para>
      </listitem>
      <listitem>
       <para><emphasis>TimerService</emphasis><indexterm><primary>TimerService</primary></indexterm> (Boolean, optional): enables/disables the generation of a timer service implementation using <emphasis>java.util.Timer</emphasis></para>
      </listitem>
     </orderedlist>

     <!-- # __GenericInterfaceSupport__ (Boolean, optional): enables/disables the generation of generic interfaces -->
     <!-- # __StatemachineFactorySupport__ (Boolean, optional): enables/disables the generation of a factory class -->

     <example>
      <title>Sample configuration</title>
      <programlisting>
feature GeneralFeatures {
    InterfaceObserverSupport = true
    RuntimeService = true
    TimerService = true
}
</programlisting>
     </example>
    </sect4>
   </sect3>


   <sect3 xml:id="java-code-specification">
    <title>Specification of Java code</title>
    <indexterm><primary>specification</primary><secondary>generated code</secondary><tertiary>Java</tertiary></indexterm>
    <indexterm><primary>API</primary><secondary>Java</secondary></indexterm>
    <indexterm><primary>Java</primary><secondary>API</secondary></indexterm>

    <para>The explanations below are using the
     <emphasis>TrafficLight</emphasis><indexterm><primary>example</primary><secondary>traffice light</secondary></indexterm> 
     sample state machine to describe the API specifications of the code generated by the YAKINDU C and Java code 
     generators. The image below is showing the statechart. It models a pedestrian crossing with push-button operated 
     traffic lights ("pelican crossing”).</para>

    <figure>
     <title>The traffic light model</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/TrafficLight.png" align="center" width="80%" scalefit="1"/>
      </imageobject>
      <textobject>
       <phrase>The traffic light model</phrase>
      </textobject>
     </mediaobject>
    </figure>

    <para>You can checkout the Java sample project
     <emphasis><link xl:href="https://github.com/Yakindu/statecharts/tree/master/examples/org.yakindu.sct.examples.trafficlight">org.yakindusct.examples.trafficlight</link></emphasis>
     from the <link xl:href="https://github.com/Yakindu/statecharts"><application>YAKINDU Statechart Tools</application>
     GitHub repository</link>. The Java example contains statechart, SGen model, graphical widgets, and some glue code
     to connect the generated code with the widgets. The graphical widgets are based on SWT.</para>

    <para>To execute the Java example, run the file <emphasis>CrossingDemoCycleBased.java</emphasis> as "Java
     Application” from the Eclipse <emphasis>Run As</emphasis> context menu.</para>

    <sect4 xml:id="java-generated-code">
     <title>Generated code files</title>

     <para>Generally you will find generated code at the places specified in the SGen model, see <link linkend="Outlet">section "Outlet”</link> for details.</para>

     <para>In the case of the traffic light example, you will find the generated code in the <emphasis>src-gen</emphasis> folder.</para>

     <para>The package <emphasis>org.yakindu.sct.examples.trafficlight.cyclebased</emphasis> contains the general state machine interfaces and classes. They are needed by each particular state machine and are independend from concrete ones.</para>
    </sect4>


    <sect4 xml:id="the-state-machine-interface">
     <title>The state machine interface</title>

     <para>Each generated state machine implements the <literal>IStatemachine</literal> interface:</para>

     <programlisting>
package org.yakindu.sct.examples.trafficlight.cyclebased;

/**
 * Basic interface for state machines.
 */
public interface IStatemachine {

    /**
    * Initializes the state machine. Use to init internal variables etc.
    */
    public void init();

    /**
    * Enters the state machine. Sets the state machine in a defined state.
    */
    public void enter();

    /**
    * Exits the state machine. Leaves the state machine with a defined state.
    */
    public void exit();

    /**
    * Start a run-to-completion cycle.
    */
    public void runCycle();
}
</programlisting>

     <sect5 xml:id="java-fundamental-statechart-methods">
      <title>Fundamental statechart methods</title>
      <indexterm><primary>statechart methods</primary><secondary>Java</secondary></indexterm>

      <para>The generated code contains fundamental methods to initialize, enter, and exit a state machine, as well as
       a method to start a run-to-completion step.</para>

      <para>The <literal>IStatemachine</literal> interface specifies the four methods <literal>init()</literal>,
       <literal>enter()</literal>, <literal>exit()</literal>, and <literal>runCycle()</literal>.</para>

      <itemizedlist>

       <listitem>
        <para>The <literal>init()</literal><indexterm><primary>init()</primary><secondary>Java</secondary></indexterm>
         method is used to initialize the internal objects of the state machine right after its instantiation. 
         Variables are initialized to their respective default values. If the statechart defines initialized variables, 
         these initializations are also done in the <literal>init()</literal> method.</para>
       </listitem>

       <listitem>
        <para>The <literal>enter()</literal><indexterm><primary>enter()</primary><secondary>Java</secondary></indexterm>
         method must be called to enter the state machine. It brings the state machine to a well-defined state.</para>
       </listitem>

       <listitem>
        <para>The <literal>exit()</literal><indexterm><primary>exit()</primary><secondary>Java</secondary></indexterm>
         method is used to leave a state machine statefully. If for example a history state is used in one of the top 
         regions, the last active state is stored and the state machine is left via <literal>exit()</literal>. 
         Re-entering it via <literal>enter()</literal> continues to work with the saved state.</para>
       </listitem>

       <listitem>
        <para>The
         <literal>runCycle()</literal><indexterm><primary>runCycle()</primary><secondary>Java</secondary></indexterm> 
         method is used to trigger a run-to-completion step in which the state machine evaluates arising events and 
         computes possible state changes. Somewhat simplified, a run-to-completion cycle consists of the following 
         steps:</para>

        <orderedlist numeration="arabic">

         <listitem>
          <para>Clear list of outgoing events.</para>
         </listitem>

         <listitem>
          <para>Check whether events have occurred which are leading to a state change.</para>
         </listitem>

         <listitem>
          <para>If a state change has to be done:</para>

          <orderedlist numeration="arabic">

           <listitem>
            <para>Execute exit actions of the present state.</para>
           </listitem>

           <listitem>
            <para>Save history state, if necessary.</para>
           </listitem>

           <listitem>
            <para>Make the new state active.</para>
            <remark role="fixme">We should also make the old state inactive, shouldn't we?</remark> 
           </listitem>

           <listitem>
            <para>Execute entry actions of the new state.</para>
           </listitem>

          </orderedlist>

         </listitem>

        </orderedlist>

       </listitem>
       <listitem>
        <para>Clear list of incoming events.</para>
       </listitem>
      </itemizedlist>

      <!-- h5. Variable and event access
           Do we need some equivalent to the C section here? Here's the C text:>
           The getters and setters for each variable and event are also contained in the header file. The method names are matching the following pattern: _statechart_name_&lt;code&gt;Iface&lt;/code&gt;_interface_name_@_@[ &lt;code&gt;set&lt;/code&gt; | &lt;code&gt;get&lt;/code&gt; | &lt;code&gt;raise&lt;/code&gt; ]@_@[ _variable_name_ | _event_name_ ]. For example, the getter of the variable _red_ of the _pedestrian_ interface is named @trafficLightWaitingIfacePedestrian_get_red(TrafficLightWaiting* handle)@. -->
     </sect5>
    </sect4>


    <sect4 xml:id="java-time-controlled-state-machines">
     <title>Time-controlled state machines</title>
     <indexterm><primary>time</primary></indexterm>
     <indexterm><primary>time-controlled state machine</primary></indexterm>
     <indexterm><primary>state machine</primary><secondary>time-controlled</secondary></indexterm>

     <para>If a statechart uses timing functionality, additional classes are generated.</para>

     <para>The traffic light example uses timing funtionality, namely <emphasis>after</emphasis> clauses. To support time-controlled behavior, the interfaces <literal>ITimerCallback</literal> and <literal>ITimer</literal> are generated. Like <literal>IStatemachine</literal>, they are independend of any particular state machine and are generated in the <emphasis>libraryTargetFolder</emphasis> directory, if specified. See <link linkend="Outlet">section "Outlet”</link> for details.</para>

     <para>The generated state machine class implements the <literal>ITimerCallback</literal> and has a property <emphasis>timer</emphasis> of type <literal>ITimer</literal>. The client code must provide an <literal>ITimer</literal> implementation to the state machine by calling the latter's <literal>setTimer()</literal> method.</para>

     <para>Here's an example showing how to create a new instance of the state machine (here: class <literal>MyTimedStatemachine</literal>), create a new instance of a timer (here: class <literal>MyTimer</literal>), set the latter on the former, and start the state machine by entering it:</para>

     <programlisting>
MyTimedStatemachine sm = new MyTimedStatemachine();
sm.setTimer(new MyTimer());
sm.enter(); // Enter the state machine
</programlisting>
     <para>Timer functions generally depend on the hardware target used, therefore the proper time handling has to be implemented by the developer. In principle, for each hardware target a dedicated timer service class implementing the <literal>ITimer</literal> interface has to be developed.</para>
    </sect4>


    <sect4 xml:id="default-timer-implementation">
     <title>Default timer implementation</title>

     <para>However, upon request the Java code generator can create a default implementation of the <literal>ITimer</literal> interface, and in many cases it will be sufficient. This implementation is based on <literal>java.util.Timer</literal> and <literal>java.util.TimerTask</literal> and should be compatible with the Oracle JVM or the OpenJDK JVM.</para>

     <para>To generate the default timer service class, set the <emphasis>TimerService</emphasis> feature in the SGen model to <emphasis>true</emphasis>. Example:</para>

     <programlisting>
GeneratorModel for yakindu::java {

    statechart MyStateMachine {

        /* … */

        feature GeneralFeatures {
            TimerService = true
        }

    }
}
</programlisting>

     <para>The generated class is named <literal>TimerService</literal> and looks like this:</para>

     <programlisting>
package org.yakindu.scr;

import java.util.ArrayList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

/**
 * Default timer service implementation.
 * 
 */
public class TimerService implements ITimer {

    private final Timer timer = new Timer();

    private final List timerTaskList = new ArrayList();

    /**
     * Timer task that reflects a time event. It's internally used by
     * {@link TimerService}.
     * 
     */
    private class TimeEventTask extends TimerTask {

        private ITimerCallback callback;

        int eventID;

        /**
         * Constructor for a time event.
         * 
         * @param callback
         *            : Set to {@code true} if event should be repeated
         *            periodically.
         * 
         * @param eventID
         *            : Index position within the state machine's timeEvent
         *            array.
         */
        public TimeEventTask(ITimerCallback callback, int eventID) {
            this.callback = callback;
            this.eventID = eventID;
        }

        public void run() {
            callback.timeElapsed(eventID);
        }

        public boolean equals(Object obj) {
            if (obj instanceof TimeEventTask) {
                return ((TimeEventTask) obj).callback.equals(callback)
                        &amp;&amp; ((TimeEventTask) obj).eventID == eventID;
            }
            return super.equals(obj);
        }
    }

    public void setTimer(final ITimerCallback callback, final int eventID,
            long time, boolean isPeriodic) {

        // Create a new TimerTask for given event and store it.
        TimeEventTask timerTask = new TimeEventTask(callback, eventID);
        timerTaskList.add(timerTask);

        // start scheduling the timer
        if (isPeriodic) {
            timer.scheduleAtFixedRate(timerTask, time, time);
        } else {
            timer.schedule(timerTask, time);
        }
    }

    public void unsetTimer(ITimerCallback callback, int eventID) {
        int index = timerTaskList.indexOf(new TimeEventTask(callback, eventID));
        if (index != -1) {
            timerTaskList.get(index).cancel();
            timer.purge();
            timerTaskList.remove(index);
        }
    }

    /**
     * Cancel timer service. Use this to end possible timing threads and free
     * memory resources.
     */
    public void cancel() {
        timer.cancel();
        timer.purge();
    }
}
</programlisting>
    </sect4>


    <sect4 xml:id="timer-service">
     <title>Timer service</title>

     <para>A timer service must implement the <literal>ITimer</literal> interface and must be able to maintain a number of time events and the timers associated with them. A time event is identified by a numeric ID.</para>

     <para>If suitable, an application can use the default timer service class <literal>TimerService</literal>, see <link linkend="default-timer-implementation">"Default timer implementation"</link> for details.</para>

     <para>The <literal>ITimer</literal> interface looks like this:</para>

     <programlisting>
package org.yakindu.scr;

/**
 * Interface a timer has to implement. Use to implement your own timer
 * service.
 * 
 */
public interface ITimer {

    /**
     * Starts the timing for a given time event id.
     * 
     * @param callback
     *            : The target callback where the time event has to be raised.
     * 
     * @param eventID
     *            : The eventID the timer should use if timed out.
     * 
     * @param time
     *            : Time in milliseconds after the given time event should be
     *            triggered
     * 
     * @param isPeriodic
     *            : Set to true if the time event should be triggered periodically
     */
    public void setTimer(ITimerCallback callback, int eventID, long time, boolean isPeriodic);

    /**
     * Unset a time event.
     * 
     * @param callback
     *          : The target callback for which the time event has to be unset.
     * 
     * @param eventID
     *          : The time event id.
     */
    public void unsetTimer(ITimerCallback callback, int eventID);
}
</programlisting>

     <sect5 xml:id="java-settimer">
      <title>Method setTimer</title>
      <indexterm><primary>setTimer()</primary><secondary>Java</secondary></indexterm>

      <para>A state machine calls the <literal>setTimer(ITimerCallback callback, int eventID, long time, boolean isPeriodic)</literal> method to tell the timer service that it has to start a timer for the given <emphasis>eventID</emphasis>. The <emphasis>time</emphasis> parameter specifies the number of milliseconds until the timer expires. When this period of time has elapsed, the timer service must raise the time event by calling the method <literal>public void timeElapsed(int eventID)</literal> on the <literal>ITimerCallback</literal> specified by the <emphasis>callback</emphasis> parameter, i. e. usually the state machine.</para>

      <para>It is important to keep the execution of the <literal>setTimer()</literal> method short and use it only to start a timer thread, a hardware timer interrupt, or the like. Avoid any time-consuming operations like extensive computations, <literal>Thread.sleep(…)</literal>, waiting, etc. Otherwise the state machine execution might hang within the timer service or might not show the expected runtime behavior.</para>

      <para>If the parameter <emphasis>isPeriodic</emphasis> is <emphasis>false</emphasis>, the timer service raises the time event only once. If <emphasis>isPeriodic</emphasis> is <emphasis>true</emphasis>, the timer service raises the time event every <emphasis>time</emphasis> milliseconds.</para>
     </sect5>


     <sect5 xml:id="java-unsettimer">
      <title>Method unsetTimer</title>
      <indexterm><primary>unsetTimer()</primary><secondary>Java</secondary></indexterm>

      <para>If the state machine calls the <literal>unsetTimer(ITimerCallback callback, int eventID)</literal> method the timer service must unset the timer for the given <emphasis>eventID</emphasis>, i. e. the time event will not be raised.</para>
     </sect5>
    </sect4>


    <sect4 xml:id="raising-time-events-on-a-state-machine">
     <title>Raising time events on a state machine</title>
     <indexterm><primary>raising time events</primary><secondary>Java</secondary></indexterm>

     <para>If a statechart is using time events, the generated Java state machine class not only implements the
      <literal>IStatemachine</literal> interface, but it also implements the <literal>ITimerCallback</literal> 
      interface. <literal>ITimerCallback</literal> is defined as follows. It specifies a single method: 
      <literal>public void timeElapsed(int eventID)</literal>.</para>

     <programlisting>
package org.yakindu.scr;

/**
* Interface for state machines which use timed event triggers.
*/
public interface ITimerCallback {

    /**
    * Callback method if a time event occurred.
    * 
    * @param eventID
    *           :The id of the occurred event.
    */
    public void timeElapsed(int eventID);
}
</programlisting>

     <sect5 xml:id="java-timeelapsed">
      <title>Method timeElapsed</title>
      <indexterm><primary>timeElapsed()</primary><secondary>Java</secondary></indexterm>

      <para>It is the timer service's responsibility to actually raise a time event on a state machine. To do so, the timer service calls the state machine's <literal>timeElapsed()</literal> method and supplies the time event's <emphasis>eventID</emphasis> as a parameter. The state machine recognizes the time event and will process it during the next run cycle.</para>

      <para>You can conclude that in order to process time events without too much latency, the runtime environment has to call the state machine's <literal>runCycle()</literal> method as frequently as needed. Consider for example a time event which is raised by the timer service after 500 ms. However, if the runtime environment calls the state machine's <literal>runCycle()</literal> method with a frequency of once per 1000 ms only, the event will quite likely not be processed at the correct points in time.</para>
     </sect5>
    </sect4>


    <sect4 xml:id="RuntimeService">
     <title>Runtime service</title>

     <para>The <literal>RuntimeService</literal> class maintains all state machines that are expected to execute run-to-completion steps periodically. A client application can retrieve the <literal>RuntimeService</literal> singleton using <literal>RuntimeService.getInstance()</literal>. It can then pause, resume or cancel all state machines that are poised to run at a specified intervall.</para>
    </sect4>


    <sect4 xml:id="JavaInterVar">
     <title>Accessing interfaces, variables and events</title>
     <indexterm><primary>interface</primary><secondary>Java</secondary></indexterm>
     <indexterm><primary>variable</primary><secondary>Java</secondary></indexterm>
     <indexterm><primary>event</primary><secondary>Java</secondary></indexterm>

     <para>In a YAKINDU statechart, variables and events are contained in so-called <emphasis role="strong">interfaces</emphasis>. There can be at most one default, unnamed interface plus zero or more named interfaces. In the generated Java code, these interfaces can be found as inner interface of the interface specifying the state machine. The outer interface's name is derived from the statechart's name while the inner interfaces' names are derived from the respective names of the statechart interfaces.</para>

     <para>Let's have a look at the following sample statechart interface declaration:</para>

     <programlisting>
interface Sample:
    var a:boolean
    in event evA:boolean
    out event evB:integer
</programlisting>

     <para>The generated interface code looks like this:</para>

     <programlisting>
import org.yakindu.scr.IStatemachine;
import org.yakindu.scr.ITimerCallback;

public interface IDefaultSMStatemachine extends ITimerCallback, IStatemachine {
    public interface SCISample {
        public void raiseEvA(boolean value);
        public boolean isRaisedEvB();
        public long getEvBValue();
        public boolean getA();
        public void setA(boolean value);

    }

    public SCISample getSCISample();

}
</programlisting>

     <para>A statechart interface is generated as an inner Java interface within the state machine interface. The Java interface's name is derived from the statechart interface's name by prepending the string <literal>SCI</literal>.</para>

     <para>A special case is the unnamed statechart interface: It is generated as the Java interface <literal>SCInterface</literal>.</para>

     <para>An incoming event <emphasis>evA:boolean</emphasis> is generated as the raise method <literal>raiseEvA(boolean value)</literal>. Since the event is of type <emphasis>boolean</emphasis> the method has a <emphasis>boolean</emphasis> parameter.</para>

     <para>For an outgoing event <emphasis>evB:integer</emphasis> the methods <literal>boolean isRaisedEvB()</literal> and <literal>long getEvBValue()</literal> are generated. The former can be used to determine whether the event has already been raised by the state machine or not. The latter serves to query the value of the event.</para>

     <para>For variables, the code generator creates getter and setter methods, here <literal>boolean getA()</literal> and <literal>void setA(boolean value)</literal>.</para>

     <para>The code generator also creates appropriately named getter methods in the enclosing interface which can be used to acquire the nested interfaces, here: <literal>SCISample getSCISample()</literal>.</para>

     <para>The nesting interface is implemented by the generated state machine source code. Each nested interface is implemented as an internal class of the state machine class. The latter holds instances of the nested interface implementations and provides them via getter methods. Have a look at (some snippets of) the source code generated for the <emphasis>Sample</emphasis> interface:</para>

     <programlisting>
import org.yakindu.scr.ITimer;

public class DefaultSMStatemachine implements IDefaultSMStatemachine {

    protected class SCISampleImpl implements SCISample {

        private boolean evA;

        private boolean evAValue;

        public void raiseEvA(boolean value) {
            evA = true;
            evAValue = value;
        }

        protected boolean getEvAValue() {
            if (!evA)
                throw new IllegalStateException(&quot;Illegal event value acces. Event EvA is not raised!&quot;);
            return evAValue;
        }

        private boolean evB;

        private long evBValue;

        public boolean isRaisedEvB() {
            return evB;
        }

        protected void raiseEvB(long value) {
            evB = true;
            evBValue = value;
        }

        public long getEvBValue() {
            if (!evB)
                throw new IllegalStateException(&quot;Illegal event value acces. Event EvB is not raised!&quot;);
            return evBValue;
        }

        private boolean a;

        public boolean getA() {
            return a;
        }

        public void setA(boolean value) {
            this.a = value;
        }

        protected void clearEvents() {
            evA = false;
        }

        protected void clearOutEvents() {
            evB = false;
        }
    }

    protected SCISampleImpl sCISample;

    public SCISample getSCISample() {
        return sCISample;
    }

    /* … */
}
</programlisting>

     <para>The value of an event can be accessed only if the event has been processed in a run-to-completion step. Otherwise an <literal>IllegalStateException</literal> will be thrown.</para>
    </sect4>


    <sect4 xml:id="JavaInterfaceObservers">
     <title>Interface observers</title>
     <indexterm><primary>interface observer</primary><secondary>Java</secondary></indexterm>

     <para>If the general feature <emphasis>InterfaceObserverSupport</emphasis> is enabled in the SGen model, the generated interfaces will support the registration of observers.</para>

     <para>Enabling the <emphasis>InterfaceObserverSupport</emphasis> feature looks like this in the <emphasis>.sgen</emphasis> file:</para>

     <programlisting>
feature GeneralFeatures {
    InterfaceObserverSupport = true
}
</programlisting>

     <para>Now the generated code has additional features:</para>

     <programlisting>
package org.yakindu.scr.defaultsm;
import java.util.List;
import org.yakindu.scr.IStatemachine;
import org.yakindu.scr.ITimerCallback;

public interface IDefaultSMStatemachine extends ITimerCallback, IStatemachine {
    public interface SCISample {
        public void raiseEvA(boolean value);
        public boolean isRaisedEvB();
        public long getEvBValue();
        public boolean getA();
        public void setA(boolean value);
        public List getListeners();

    }

    public interface SCISampleListener {
        public void onEvBRaised(long value);
    }

    public SCISample getSCISample();

}
</programlisting>

     <para>An additional listener interface is generated, here <literal>SCISampleListener</literal>. It contains a callback method for each outgoing event. Here it is a single one: <literal>void onEvBRaised(long value)</literal>.</para>

     <para>The client code has to provide an implementation of the listener interface. A listener method gets called by the state machine when it raises an outgoing event.</para>

     <para>To register or unregister a listener, use the <literal>getListeners()</literal> method of the nesting interface. This method returns a <literal>java.util.List</literal> parameterized with the appropriate listener type. Initially this list is empty. Add or remove listeners as needed.</para>

     <para>A callback method specified by the listener interface should complete its operations quickly, because otherwise the state machine execution might be delayed for too long, potentially leading to unexpected runtime behavior.</para>
    </sect4>


    <sect4 xml:id="java-operation-callback">
     <title>Operation callbacks</title>
     <indexterm><primary>operation callback</primary><secondary>Java</secondary></indexterm>

     <para><application>YAKINDU Statechart Tools</application> support <emphasis>operations</emphasis> that are
      executed by a state machine as actions, but are implemented by client-side code. The figure below shows a sample 
      statechart using an operation:</para>

     <figure>
      <title>Specifying an operation callback in the model</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/operationExample.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Specifying an operation callback in the model</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>Let's have a look at the generated code:</para>

     <programlisting>
import java.util.List;
import org.yakindu.scr.IStatemachine;

public interface IDefaultSMStatemachine extends IStatemachine {
    public interface SCISample {
        public void raiseEvA(boolean value);
        public boolean isRaisedEvB();
        public long getEvBValue();
        public boolean getA();
        public void setA(boolean value);
        public List getListeners();

        public void setSCISampleOperationCallback(SCISampleOperationCallback operationCallback);
    }

    public interface SCISampleListener {
        public void onEvBRaised(long value);
    }

    public interface SCISampleOperationCallback {
        public long myOperation(long p1, boolean p2);
    }

    public SCISample getSCISample();

}
</programlisting>

     <para>An additional interface <literal>SCISampleOperationCallback</literal> specifying the method <literal>public
      long myOperation(long p1, boolean p2)</literal> has been generated. The client code has to</para>

     <itemizedlist>

      <listitem>
       <para>provide an implementation of this interface and</para>
      </listitem>

      <listitem>
       <para>pass an instance of it to the state machine via the
        <literal>setSCISampleOperationCallback(SCISampleOperationCallback operationCallback)</literal> method.</para>
      </listitem>

     </itemizedlist>

     <para>Here's some sample code that passes an implementation of the operation to a state machine, and then executes
      the latter:</para>

     <programlisting>
public static void main(String[] args) {
    DefaultSMStatemachine statemachine = new DefaultSMStatemachine();

    SCISampleOperationCallback callback = new SCISampleOperationCallback() {

        @Override
        public long myOperation(long p1, boolean p2) {
            // Your operation code should be placed here;
            return 0;
        }
    };

    statemachine.getSCISample().setSCISampleOperationCallback(callback);

    statemachine.init();
    statemachine.enter();
    statemachine.runCycle();
}
</programlisting>
    </sect4>


    <sect4 xml:id="JavaIntegratingGeneratedCode">
     <title>Integrating generated code</title>
     <indexterm><primary>code integration</primary><secondary>Java</secondary></indexterm>

     <para>To get a clue how to integrate a generated Java state machine with your project have a look at the
      <literal>CrossingDemoCycleBased</literal> class and its abstract superclass <literal>CrossingDemoBase</literal>. 
      The <literal>main()</literal> method is in <literal>CrossingDemoCycleBased</literal>:</para>

     <programlisting>
public static void main(String[] args) {

    new CrossingDemoCycleBased().runTrafficLight();
}
</programlisting>

     <para>A new instance of the class is created and the method <literal>runTrafficLight()</literal> is called. This method can be found in the superclass:</para>

     <programlisting>
public void runTrafficLight() {

        setUpAndRunStatemachine();
        createUIContent();

        shell.open();
        while (!shell.isDisposed()) {
            // update traffic lights
            readStatemachineOutput();

            crossing.repaint();

            if (!display.readAndDispatch()) {
                display.sleep();
            }
        }

        tearDownStatemachine();
}
</programlisting>

     <para>This method sets up the state machine and creates the GUI content. In a while loop it reads the content of the state machine and repaints the GUI. If the user exits the GUI shell, the loop terminates and the state machine is torn down. The really interesting methods are <methodname>setUpAndRunStatemachine()</methodname>, <methodname>readStatemachineOutput()</methodname>, and <methodname>tearDownStatemachine()</methodname>:</para>

     <programlisting>
protected void setUpAndRunStatemachine() {

    statemachine = new TrafficLightWaitingStatemachine();
    statemachine.setTimerService(new TimerService());
    statemachine.init();
    statemachine.enter();

    RuntimeService.getInstance().registerStatemachine(statemachine, 100);
}
</programlisting>

     <para>First a new instance of the generated state machine is created. Since the traffic light statechart uses timing clauses, it is provided with a timer service, here with the default implementation of the <literal>ITimerService</literal> interface. In the next steps the state machine is initialized and entered. After the <literal>enter()</literal> method has been executed, the machine is in a defined state.</para>

     <para>Finally the state machine is passed to the runtime service. This service executes the <literal>runCycle()</literal> method of the state machine every 100 ms, that is the state machine executes a run-to-completion step every 100 ms.</para>

     <programlisting>
protected void readStatemachineOutput() {
    trafficLightFigure.setRed(statemachine.getSCITrafficLight()
            .getRed());
    trafficLightFigure.setYellow(statemachine.getSCITrafficLight()
            .getYellow());
    trafficLightFigure.setGreen(statemachine.getSCITrafficLight()
            .getGreen());
        pedestrianLightFigure.setWhite(statemachine.getSCIPedestrian()
            .getRequest());
    pedestrianLightFigure.setRed(statemachine.getSCIPedestrian()
            .getRed());
    pedestrianLightFigure.setGreen(statemachine.getSCIPedestrian()
            .getGreen());
}
</programlisting>

     <para>The generated code contains getters and setters for each variable and event. So it's easy to read values from or write values to a state machine, raise events, or ask the state machine whether outgoing events have been raised during the last run-to-completion step. Within the <literal>readStatemachineOutput()</literal> method, these methods are used to get the lights values from the state machine and set them to the UI elements. The methods <literal>pedestrianRequestButtonClicked()</literal> and <literal>onOffButtonClicked()</literal> raise some events.</para>

     <para>Hint: When outgoing events are raised within the state machine, they remain active until the next run-to-completion step is started.</para>

     <programlisting>
@Override
protected void tearDownStatemachine() {
    // End TimerHandler and RuntimeService.
    statemachine.getTimerService().cancel();
    RuntimeService.getInstance().cancelTimer();
}
</programlisting>

     <para>If the UI thread has been terminated by the user, the state machine will be shut down. It is necessary to explicitly end the timer service. Finally the runtime service is cancelled.</para>
    </sect4>
   </sect3>
  </sect2>


  <sect2 xml:id="custom-code-generator">
   <title>Custom code generator</title>
   <indexterm><primary>custom code generator</primary></indexterm>
  
   <sect3 xml:id="CreatingCustomCodeGenerators">
    <title>Creating custom code generators</title>

    <para><application>YAKINDU Statechart Tools</application> provide a rich feature set to support custom code
     generators out of the box. These code generators can be either written in Java, 
     <link xl:href="http://www.eclipse.org/xtend/">Xtend</link>, or 
     <link xl:href="http://www.eclipse.org/modeling/m2t/?project=xpand">Xpand</link>.</para>

    <sect4 xml:id="WritingacustomcodegeneratorwithXtend2Java">
     <title>Writing a custom code generator with Xtend2/Java</title>
     <indexterm><primary>Xtend2/Java</primary></indexterm>

     <para>First, you have to create a new Xtend2 generator project. Click <emphasis>File → New → Other… → YAKINDU → YAKINDU Xtend2/Java Generator Project</emphasis> to create a new Xtend2 generator project.</para>

     <figure>
      <title>Creating an Xtend2 generator project</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="images/xtendGenerator.png" align="center" width="80%" scalefit="1"/>
       </imageobject>
       <textobject>
        <phrase>Creating an Xtend2 generator project</phrase>
       </textobject>
      </mediaobject>
     </figure>

     <para>The wizard asks for a <emphasis role="strong">Project name</emphasis> and the name of the <emphasis role="strong">Generator class</emphasis>, which has to be the fully-qualified class name. If you check the <emphasis role="strong">Use Xtend</emphasis> checkbox, the generator class will initially be created as an <link xl:href="http://www.eclipse.org/xtend/">Xtend</link> class. Otherwise, Java will be used for the generator.</para>

     <para>The check box <emphasis role="strong">Configure for Plugin Export</emphasis> adds all required extension point registrations to the new project for exporting it as a plugin. The generator model can refer to the new generator plugin via its unique <emphasis role="strong">Generator ID</emphasis>. If you want to contribute custom generator features for your code generator, check the <emphasis role="strong">Create Feature Library</emphasis> check box.</para>

     <para>After clicking on <emphasis role="strong">Finish</emphasis> a new project is created in your workspace. All required plugin dependencies and extension points are registered and you can start to write your code generator based on the ExecutionFlow meta model [Link].</para>
    </sect4>
   </sect3>


   <sect3 xml:id="ExecutingacustomXtend2Javacodegenerator">
    <title>Executing a custom Xtend2/Java code generator</title>
     <indexterm><primary>Xtend2/Java</primary></indexterm>

    <para><application>YAKINDU Statechart Tools</application> provide a convenient way to execute your generator while
     you are developing it.</para>

    <para>For this, you have to create a new <emphasis role="strong">generator model</emphasis> with the generator ID <emphasis role="strong">yakindu::generic</emphasis>, either by using the <emphasis role="strong">New Statechart Generator Model</emphasis> wizard or by simply creating a new text file with the file extension <literal>.sgen</literal>. The feature described below allows to configure your code generator.</para>

    <sect4 xml:id="Generator" role="sgen_feature_generator">
     <title>Generator</title>
     <indexterm><primary>Generator</primary><secondary>generator feature</secondary><tertiary>custom</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Generator</secondary><tertiary>custom</tertiary></indexterm>

     <para>The <emphasis role="strong">Generator</emphasis> feature allows to configure a custom code generator located
      in the workspace and written in Java or in another JVM language. It is a <emphasis 
      role="strong">required</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">

      <listitem>
       <para><emphasis>generatorProject</emphasis><indexterm><primary>generatorProject</primary></indexterm> (String, required): the name of the generator project</para>
      </listitem>

      <listitem>
       <para><emphasis>generatorClass</emphasis><indexterm><primary>generatorClass</primary></indexterm> (String, required): the fully-qualified name of the code generator class</para>
      </listitem>

      <listitem>
       <para><emphasis>configurationModule</emphasis><indexterm><primary>configurationModule</primary></indexterm> (String, optional): the fully-qualified class name of a Guice module to configure the code generator</para>
      </listitem>

     </orderedlist>

     <example>
      <title>Sample configuration</title>

      <programlisting>
feature Generator {
    generatorProject = &quot;org.yakindu.sct.mygenerator&quot;
    generatorClass = &quot;org.yakindu.sct.MyGenerator&quot;
}
</programlisting>
     </example>
    </sect4>
   </sect3>


   <sect3 xml:id="ExecutingacustomXpandcodegenerator">
    <title>Executing a custom Xpand code generator</title>
    <indexterm><primary>Xpand</primary></indexterm>

    <para>In order to execute an Xpand-based custom code generator, you have to create a new
     <emphasis role="strong">Generator Model</emphasis> with the generator ID <emphasis
     role="strong">yakindu::xpand</emphasis><indexterm><primary>yakindu::xpand</primary></indexterm>, either by using 
     the <emphasis role="strong">New Statechart Generator Model</emphasis> wizard or by simply creating a new text 
     file with the file extension <emphasis role="strong">.sgen</emphasis>. The following feature allows to configure 
     your code generator.</para>

    <sect4 xml:id="Template" role="sgen_feature_template">
     <title>Template</title>
     <indexterm><primary>Generator</primary><secondary>generator feature</secondary><tertiary>custom</tertiary></indexterm>
     <indexterm><primary>generator feature</primary><secondary>Generator</secondary><tertiary>custom</tertiary></indexterm>

     <para>The <emphasis role="strong">Generator</emphasis> feature allows to configure a custom code generator located
      in the workspace and written in Java or in another JVM language. It is a <emphasis 
      role="strong">required</emphasis> feature and has the following parameters:</para>

     <orderedlist numeration="arabic">
      <listitem>
       <para><emphasis>templateProject</emphasis><indexterm><primary>templateProject</primary></indexterm> (String,
        required): the name of the generator project</para>
      </listitem>
      <listitem>
       <para><emphasis>templatePath</emphasis><indexterm><primary>templatePath</primary></indexterm> (String,
        required): the fully-qualified template path of the main template</para>
      </listitem>
     </orderedlist>

     <example>
      <title>Sample configuration</title>

      <programlisting>
feature Template {
    templateProject = &quot;ExampleProject&quot;
    templatePath = &quot;org::yakindu::sct::generator::xpand::Main::main&quot;
}
</programlisting>
     </example>
    </sect4>
   </sect3>
  </sect2>
 </sect1>

 <index><title>Index</title></index>

</article>
