import sgraph : '../../../org.yakindu.sct.model.sgraph/model/emf/sgraph.ecore#/'
import stext : '../../../org.yakindu.sct.model.stext/model/SText.ecore#/'
import base : '../../../org.yakindu.base.types/model/base.ecore#/'
import expressions : '../../../org.yakindu.base.expressions/model/Expressions.ecore#/'
import types : '../../../org.yakindu.base.types/model/types.ecore#/'

package sgraph

context Statechart
inv UniqueInterfaceNames: self.scopes->select(s | s.oclIsTypeOf(stext::InterfaceScope))->collect(is | is.oclAsType(stext::InterfaceScope))->forAll(is1, is2 | is1.name = is2.name implies is1 = is2)

inv EventsAreUsedInTransitions: self.scopes -> select(oclIsTypeOf(stext::InterfaceScope)) -> collect(events) -> forAll(e | self.checkEventUsedInTransitions(e))

context CompositeElement 
/* Hinweis zu meiner Implementierung: Ich habe es auf statechart Level implementiert, das führt dann dazu, dass ich dann innerhalb jedes CompositeStates nochmal tiefer
 * absteigen muss, um tatsächlich alle Transitionen zu treffen. Das scheint hier aber nurch Verwendung von CompositeElement bereits abgedeckt zu sein. :)
 */
def: checkEventUsedInTransitions(e : types::Event) : Boolean =
	self.regions -> exists(r | r.vertices -> exists(v | v.outgoingTransitions -> exists(t | t.trigger.oclIsTypeOf(stext::ReactionTrigger) 
			and t.trigger.oclAsType(stext::ReactionTrigger).triggers -> exists(es | es.oclIsTypeOf(stext::RegularEventSpec) and es.oclAsType(stext::RegularEventSpec).checkEventUsed(e)))))

/* An dieser Stelle müsste die Prüfung noch erweitert werden um auch die Nutzung der Events in den States selbst zu erfassen. 
 * Für eine Weihnachtsaufgabe erscheint mir das allerdings etwas zu viel.
 */

context Vertex

def: getParent(): CompositeElement = self.parentRegion.composite

def : getAllOutgoingTransitionsInParentHierarchy(v: Vertex) : Set(Transition) =
	if (v.getParent() -> oclIsTypeOf(State))
	then
		getAllOutgoingTransitionsInParentHierarchy(v.getParent() -> oclAsType(State))
		-> union(v.outgoingTransitions)
	else
		v.outgoingTransitions
	endif

/*
 * FRAGE: Geht das besser? Eigentlich wollte ich nur die Vereinigung von regions -> forAll(r | r.vertices) ...
 * Scheint eh nicht mehr gebraucht zu werden, aber die Frage besteht trotzdem noch.
 */
def: getVerticesForRegions(regions: OrderedSet(Region)) : Set(Vertex) = 
	if (regions -> size() = 1) then
		regions -> first().vertices
	else
		regions -> first().vertices -> union( getVerticesForRegions(regions -> excluding(regions -> first())))
	endif

def: getOutgoingTransitionsForVertices(vertices: Set(Vertex)) : Set(Transition) =
	let seq_vert : Sequence(Vertex) = vertices -> asSequence() in
		if (seq_vert -> size() = 1) then
			seq_vert -> first().outgoingTransitions
		else
			seq_vert -> first().outgoingTransitions -> union(getOutgoingTransitionsForVertices( seq_vert -> excluding(seq_vert->first()) -> asSet()))
		endif

def: getAllOutgoingTransitionInChildHierarchy(v: Vertex): Set(Transition) =	 
	if (v -> oclIsTypeOf(State) and v -> oclAsType(State).composite)
	then	 
	v.outgoingTransitions -> union( getOutgoingTransitionsForVertices(
		getVerticesForRegions(
		v -> oclAsType(State).regions
		)))
	else
		v.outgoingTransitions
	endif

/*
 * Small extension: Both effects must be non empty 
 */
inv smell_1a: self.outgoingTransitions -> forAll(t1, t2 | not t1.effect.oclIsUndefined() and not t2.effect.oclIsUndefined() and t1.effect = t2.effect 
	implies t1 = t2
)

inv smell_1b: self.incomingTransitions -> forAll(t1 | t2 | not t1.effect.oclIsUndefined() and not t2.effect.oclIsUndefined() and t1.effect = t2.effect
	implies t1 = t2
)


context State

inv smell_3a: self.composite and self.regions->size() = 1 implies 
	self.regions->at(0).vertices -> select( v | v -> oclIsTypeOf(FinalState) or v -> oclIsTypeOf(Exit)) -> size() <= 1
	
-- Smell 3b is equivalent to: At least one state in hierarchy has a outgoing transition
inv smell_3b: not self->oclIsTypeOf(FinalState) implies getAllOutgoingTransitionsInParentHierarchy(self) -> size() > 0

-- inv smell_1c: self.outgoingTransitions -> forAll( t | getAllOutgoingTransitionsInParentHierarchy(t) )

context sgraph::Region

-- at most one unamed entry
inv smell_2a: self.vertices -> select( v | v -> oclIsTypeOf(Entry) and v -> oclAsType(Entry).name = '') -> size() <= 1

-- at most one final state
inv smell_2b: self.vertices -> select (v | v -> oclIsTypeOf(FinalState)) -> size() <= 1

/*
 * OCL statement fror smell 2c is omitted, because this smell is already implemented in SCT
 */
 
 

endpackage

package stext

context stext::RegularEventSpec
def: checkEventUsed(e: types::Event) : Boolean =
	if (self.event.oclIsTypeOf(expressions::PrimitiveValueExpression)) 
		then 
			let pe = self.event.oclAsType(expressions::PrimitiveValueExpression)
			in pe.value.oclIsTypeOf(expressions::StringLiteral) and pe.value.oclAsType(expressions::StringLiteral).value = e.name
		else
			false
	endif
	

endpackage